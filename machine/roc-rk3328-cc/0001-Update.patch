From 46117321d4f6459c4ff0514d52465fa052d32d93 Mon Sep 17 00:00:00 2001
From: wxt <3264117476@qq.com>
Date: Sun, 23 Nov 2025 13:03:25 +0800
Subject: [PATCH] Update

---
 .../bindings/phy/rockchip,inno-usb3phy.yaml   |  166 ++
 .../rockchip/rk3328-dram-default-timing.dtsi  |  311 +++
 .../rockchip/rk3328-dram-renegade-timing.dtsi |  311 +++
 arch/arm64/boot/dts/rockchip/rk3328-roc.dtsi  |   51 +
 .../boot/dts/rockchip/rk3328-roc.dtsi.orig    |  415 ++++
 arch/arm64/boot/dts/rockchip/rk3328.dtsi      |  138 ++
 arch/arm64/boot/dts/rockchip/rk3328.dtsi.orig | 1997 +++++++++++++++++
 arch/arm64/boot/dts/rockchip/rk3328.dtsi.rej  |   23 +
 drivers/clk/rockchip/clk-ddr.c                |  131 ++
 drivers/clk/rockchip/clk-ddr.c.orig           |  139 ++
 drivers/clk/rockchip/clk-rk3328.c             |   13 +-
 drivers/clk/rockchip/clk.h                    |    3 +-
 drivers/devfreq/Kconfig                       |   12 +
 drivers/devfreq/Makefile                      |    1 +
 drivers/devfreq/event/rockchip-dfi.c          |   77 +-
 drivers/devfreq/event/rockchip-dfi.c.orig     |  837 +++++++
 drivers/devfreq/rk3328_dmc.c                  |  836 +++++++
 drivers/phy/rockchip/Kconfig                  |   10 +
 drivers/phy/rockchip/Makefile                 |    1 +
 drivers/phy/rockchip/phy-rockchip-inno-usb3.c |  870 +++++++
 include/dt-bindings/clock/rockchip-ddr.h      |   63 +
 include/dt-bindings/memory/rk3328-dram.h      |  159 ++
 include/soc/rockchip/rk3228_grf.h             |   14 +
 include/soc/rockchip/rk3328_grf.h             |   14 +
 include/soc/rockchip/rockchip_sip.h           |   11 +
 25 files changed, 6589 insertions(+), 14 deletions(-)
 create mode 100644 Documentation/devicetree/bindings/phy/rockchip,inno-usb3phy.yaml
 create mode 100644 arch/arm64/boot/dts/rockchip/rk3328-dram-default-timing.dtsi
 create mode 100644 arch/arm64/boot/dts/rockchip/rk3328-dram-renegade-timing.dtsi
 mode change 100644 => 100755 arch/arm64/boot/dts/rockchip/rk3328-roc.dtsi
 create mode 100644 arch/arm64/boot/dts/rockchip/rk3328-roc.dtsi.orig
 create mode 100644 arch/arm64/boot/dts/rockchip/rk3328.dtsi.orig
 create mode 100644 arch/arm64/boot/dts/rockchip/rk3328.dtsi.rej
 create mode 100644 drivers/clk/rockchip/clk-ddr.c.orig
 create mode 100644 drivers/devfreq/event/rockchip-dfi.c.orig
 create mode 100644 drivers/devfreq/rk3328_dmc.c
 create mode 100644 drivers/phy/rockchip/phy-rockchip-inno-usb3.c
 create mode 100644 include/dt-bindings/clock/rockchip-ddr.h
 create mode 100644 include/dt-bindings/memory/rk3328-dram.h
 create mode 100644 include/soc/rockchip/rk3228_grf.h
 create mode 100644 include/soc/rockchip/rk3328_grf.h

diff --git a/Documentation/devicetree/bindings/phy/rockchip,inno-usb3phy.yaml b/Documentation/devicetree/bindings/phy/rockchip,inno-usb3phy.yaml
new file mode 100644
index 000000000000..cde489ca87ab
--- /dev/null
+++ b/Documentation/devicetree/bindings/phy/rockchip,inno-usb3phy.yaml
@@ -0,0 +1,166 @@
+# SPDX-License-Identifier: GPL-2.0-only
+%YAML 1.2
+---
+$id: http://devicetree.org/schemas/phy/rockchip,inno-usb3phy.yaml#
+$schema: http://devicetree.org/meta-schemas/core.yaml#
+
+title: Rockchip USB 3.0 phy with Innosilicon IP block
+
+maintainers:
+  - Heiko Stuebner <heiko@sntech.de>
+
+properties:
+  compatible:
+    enum:
+      - rockchip,rk3328-usb3phy
+
+  reg:
+    maxItems: 1
+
+  clocks:
+    minItems: 3
+    maxItems: 3
+
+  clock-names:
+    items:
+      - const: refclk-usb3otg
+      - const: usb3phy-otg
+      - const: usb3phy-pipe
+
+  interrupts:
+    minItems: 4
+
+  interrupt-names:
+    items:
+      - const: bvalid
+      - const: id
+      - const: linestate
+      - const: rxdet
+
+  resets:
+    minItems: 6
+
+  reset-names:
+    items:
+      - const: usb3phy-u2-por
+      - const: usb3phy-u3-por
+      - const: usb3phy-pipe-mac
+      - const: usb3phy-utmi-mac
+      - const: usb3phy-utmi-apb
+      - const: usb3phy-pipe-apb
+
+  "#address-cells":
+    const: 2
+
+  "#size-cells":
+    const: 2
+
+  ranges: true
+
+patternProperties:
+
+  utmi-port@[0-9a-f]+$:
+    type: object
+    additionalProperties: false
+
+    properties:
+      compatible:
+        enum:
+          - rockchip,rk3328-usb3phy-utmi
+
+      reg:
+        maxItems: 1
+
+      "#phy-cells":
+        const: 0
+
+      phy-supply:
+        description:
+          Phandle to a regulator that provides power to VBUS.
+          See ./phy-bindings.txt for details.
+
+    required:
+      - compatible
+      - reg
+      - "#phy-cells"
+
+  pipe-port@[0-9a-f]+$:
+    type: object
+    additionalProperties: false
+
+    properties:
+      compatible:
+        enum:
+          - rockchip,rk3328-usb3phy-pipe
+
+      reg:
+        maxItems: 1
+
+      "#phy-cells":
+        const: 0
+
+      phy-supply:
+        description:
+          Phandle to a regulator that provides power to VBUS.
+          See ./phy-bindings.txt for details.
+
+    required:
+      - compatible
+      - reg
+      - "#phy-cells"
+
+required:
+  - compatible
+  - reg
+  - clocks
+  - clock-names
+  - interrupts
+  - interrupt-names
+  - resets
+  - reset-names
+
+additionalProperties: false
+
+examples:
+  - |
+    #include <dt-bindings/clock/rk3328-cru.h>
+    #include <dt-bindings/interrupt-controller/arm-gic.h>
+    #include <dt-bindings/interrupt-controller/irq.h>
+    soc {
+      #address-cells = <2>;
+      #size-cells = <2>;
+
+      usb3phy: usb3-phy@ff460000 {
+        compatible = "rockchip,rk3328-usb3phy";
+        reg = <0x0 0xff460000 0x0 0x10000>;
+        clocks = <&cru SCLK_REF_USB3OTG>, <&cru PCLK_USB3PHY_OTG>, <&cru PCLK_USB3PHY_PIPE>;
+        clock-names = "refclk-usb3otg", "usb3phy-otg", "usb3phy-pipe";
+        interrupts = <GIC_SPI 75 IRQ_TYPE_LEVEL_HIGH>, <GIC_SPI 76 IRQ_TYPE_LEVEL_HIGH>,
+                     <GIC_SPI 77 IRQ_TYPE_LEVEL_HIGH>, <GIC_SPI 78 IRQ_TYPE_LEVEL_HIGH>;
+        interrupt-names = "bvalid", "id", "linestate", "rxdet";
+        resets = <&cru SRST_USB3PHY_U2>,
+                 <&cru SRST_USB3PHY_U3>,
+                 <&cru SRST_USB3PHY_PIPE>,
+                 <&cru SRST_USB3OTG_UTMI>,
+                 <&cru SRST_USB3PHY_OTG_P>,
+                 <&cru SRST_USB3PHY_PIPE_P>;
+        reset-names = "usb3phy-u2-por", "usb3phy-u3-por",
+                      "usb3phy-pipe-mac", "usb3phy-utmi-mac",
+                      "usb3phy-utmi-apb", "usb3phy-pipe-apb";
+        #address-cells = <2>;
+        #size-cells = <2>;
+        ranges;
+
+        usb3phy_utmi: utmi-port@ff470000 {
+          compatible = "rockchip,rk3328-usb3phy-utmi";
+          reg = <0x0 0xff470000 0x0 0x8000>;
+          #phy-cells = <0>;
+        };
+
+        usb3phy_pipe: pipe-port@ff478000 {
+          compatible = "rockchip,rk3328-usb3phy-pipe";
+          reg = <0x0 0xff478000 0x0 0x8000>;
+          #phy-cells = <0>;
+        };
+      };
+    };
diff --git a/arch/arm64/boot/dts/rockchip/rk3328-dram-default-timing.dtsi b/arch/arm64/boot/dts/rockchip/rk3328-dram-default-timing.dtsi
new file mode 100644
index 000000000000..a3f5ff4bdc47
--- /dev/null
+++ b/arch/arm64/boot/dts/rockchip/rk3328-dram-default-timing.dtsi
@@ -0,0 +1,311 @@
+/*
+ * Copyright (c) 2017 Fuzhou Rockchip Electronics Co., Ltd
+ *
+ * This file is dual-licensed: you can use it either under the terms
+ * of the GPL or the X11 license, at your option. Note that this dual
+ * licensing only applies to this file, and not this project as a
+ * whole.
+ *
+ *  a) This library is free software; you can redistribute it and/or
+ *     modify it under the terms of the GNU General Public License as
+ *     published by the Free Software Foundation; either version 2 of the
+ *     License, or (at your option) any later version.
+ *
+ *     This library is distributed in the hope that it will be useful,
+ *     but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *     GNU General Public License for more details.
+ *
+ * Or, alternatively,
+ *
+ *  b) Permission is hereby granted, free of charge, to any person
+ *     obtaining a copy of this software and associated documentation
+ *     files (the "Software"), to deal in the Software without
+ *     restriction, including without limitation the rights to use,
+ *     copy, modify, merge, publish, distribute, sublicense, and/or
+ *     sell copies of the Software, and to permit persons to whom the
+ *     Software is furnished to do so, subject to the following
+ *     conditions:
+ *
+ *     The above copyright notice and this permission notice shall be
+ *     included in all copies or substantial portions of the Software.
+ *
+ *     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ *     EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
+ *     OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ *     NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+ *     HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+ *     WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ *     FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ *     OTHER DEALINGS IN THE SOFTWARE.
+ */
+#include <dt-bindings/clock/rockchip-ddr.h>
+#include <dt-bindings/memory/rk3328-dram.h>
+
+/ {
+	ddr_timing: ddr_timing {
+		compatible = "rockchip,ddr-timing";
+		ddr3_speed_bin = <DDR3_DEFAULT>;
+		ddr4_speed_bin = <DDR4_DEFAULT>;
+		pd_idle = <0>;
+		sr_idle = <0>;
+		sr_mc_gate_idle = <0>;
+		srpd_lite_idle	= <0>;
+		standby_idle = <0>;
+
+		auto_pd_dis_freq = <1066>;
+		auto_sr_dis_freq = <800>;
+		ddr3_dll_dis_freq = <300>;
+		ddr4_dll_dis_freq = <625>;
+		phy_dll_dis_freq = <400>;
+
+		ddr3_odt_dis_freq = <100>;
+		phy_ddr3_odt_dis_freq = <100>;
+		ddr3_drv = <DDR3_DS_40ohm>;
+		ddr3_odt = <DDR3_ODT_120ohm>;
+		phy_ddr3_ca_drv = <PHY_DDR3_RON_RTT_34ohm>;
+		phy_ddr3_ck_drv = <PHY_DDR3_RON_RTT_45ohm>;
+		phy_ddr3_dq_drv = <PHY_DDR3_RON_RTT_34ohm>;
+		phy_ddr3_odt = <PHY_DDR3_RON_RTT_225ohm>;
+
+		lpddr3_odt_dis_freq = <666>;
+		phy_lpddr3_odt_dis_freq = <666>;
+		lpddr3_drv = <LP3_DS_40ohm>;
+		lpddr3_odt = <LP3_ODT_240ohm>;
+		phy_lpddr3_ca_drv = <PHY_DDR4_LPDDR3_RON_RTT_34ohm>;
+		phy_lpddr3_ck_drv = <PHY_DDR4_LPDDR3_RON_RTT_43ohm>;
+		phy_lpddr3_dq_drv = <PHY_DDR4_LPDDR3_RON_RTT_34ohm>;
+		phy_lpddr3_odt = <PHY_DDR4_LPDDR3_RON_RTT_240ohm>;
+
+		lpddr4_odt_dis_freq = <800>;
+		phy_lpddr4_odt_dis_freq = <800>;
+		lpddr4_drv = <LP4_PDDS_60ohm>;
+		lpddr4_dq_odt = <LP4_DQ_ODT_40ohm>;
+		lpddr4_ca_odt = <LP4_CA_ODT_40ohm>;
+		phy_lpddr4_ca_drv = <PHY_DDR4_LPDDR3_RON_RTT_40ohm>;
+		phy_lpddr4_ck_cs_drv = <PHY_DDR4_LPDDR3_RON_RTT_80ohm>;
+		phy_lpddr4_dq_drv = <PHY_DDR4_LPDDR3_RON_RTT_80ohm>;
+		phy_lpddr4_odt = <PHY_DDR4_LPDDR3_RON_RTT_60ohm>;
+
+		ddr4_odt_dis_freq = <666>;
+		phy_ddr4_odt_dis_freq = <666>;
+		ddr4_drv = <DDR4_DS_34ohm>;
+		ddr4_odt = <DDR4_RTT_NOM_240ohm>;
+		phy_ddr4_ca_drv = <PHY_DDR4_LPDDR3_RON_RTT_34ohm>;
+		phy_ddr4_ck_drv = <PHY_DDR4_LPDDR3_RON_RTT_43ohm>;
+		phy_ddr4_dq_drv = <PHY_DDR4_LPDDR3_RON_RTT_34ohm>;
+		phy_ddr4_odt = <PHY_DDR4_LPDDR3_RON_RTT_240ohm>;
+
+		/* CA de-skew, one step is 47.8ps, range 0-15 */
+		ddr3a1_ddr4a9_de-skew = <7>;
+		ddr3a0_ddr4a10_de-skew = <7>;
+		ddr3a3_ddr4a6_de-skew = <8>;
+		ddr3a2_ddr4a4_de-skew = <8>;
+		ddr3a5_ddr4a8_de-skew = <7>;
+		ddr3a4_ddr4a5_de-skew = <9>;
+		ddr3a7_ddr4a11_de-skew = <7>;
+		ddr3a6_ddr4a7_de-skew = <9>;
+		ddr3a9_ddr4a0_de-skew = <8>;
+		ddr3a8_ddr4a13_de-skew = <7>;
+		ddr3a11_ddr4a3_de-skew = <9>;
+		ddr3a10_ddr4cs0_de-skew = <7>;
+		ddr3a13_ddr4a2_de-skew = <8>;
+		ddr3a12_ddr4ba1_de-skew = <7>;
+		ddr3a15_ddr4odt0_de-skew = <7>;
+		ddr3a14_ddr4a1_de-skew = <8>;
+		ddr3ba1_ddr4a15_de-skew = <7>;
+		ddr3ba0_ddr4bg0_de-skew = <7>;
+		ddr3ras_ddr4cke_de-skew = <7>;
+		ddr3ba2_ddr4ba0_de-skew = <8>;
+		ddr3we_ddr4bg1_de-skew = <8>;
+		ddr3cas_ddr4a12_de-skew = <7>;
+		ddr3ckn_ddr4ckn_de-skew = <8>;
+		ddr3ckp_ddr4ckp_de-skew = <8>;
+		ddr3cke_ddr4a16_de-skew = <8>;
+		ddr3odt0_ddr4a14_de-skew = <7>;
+		ddr3cs0_ddr4act_de-skew = <8>;
+		ddr3reset_ddr4reset_de-skew = <7>;
+		ddr3cs1_ddr4cs1_de-skew = <7>;
+		ddr3odt1_ddr4odt1_de-skew = <7>;
+
+		/* DATA de-skew
+		 * RX one step is 25.1ps, range 0-15
+		 * TX one step is 47.8ps, range 0-15
+		 */
+		cs0_dm0_rx_de-skew = <7>;
+		cs0_dm0_tx_de-skew = <8>;
+		cs0_dq0_rx_de-skew = <7>;
+		cs0_dq0_tx_de-skew = <8>;
+		cs0_dq1_rx_de-skew = <7>;
+		cs0_dq1_tx_de-skew = <8>;
+		cs0_dq2_rx_de-skew = <7>;
+		cs0_dq2_tx_de-skew = <8>;
+		cs0_dq3_rx_de-skew = <7>;
+		cs0_dq3_tx_de-skew = <8>;
+		cs0_dq4_rx_de-skew = <7>;
+		cs0_dq4_tx_de-skew = <8>;
+		cs0_dq5_rx_de-skew = <7>;
+		cs0_dq5_tx_de-skew = <8>;
+		cs0_dq6_rx_de-skew = <7>;
+		cs0_dq6_tx_de-skew = <8>;
+		cs0_dq7_rx_de-skew = <7>;
+		cs0_dq7_tx_de-skew = <8>;
+		cs0_dqs0_rx_de-skew = <6>;
+		cs0_dqs0p_tx_de-skew = <9>;
+		cs0_dqs0n_tx_de-skew = <9>;
+
+		cs0_dm1_rx_de-skew = <7>;
+		cs0_dm1_tx_de-skew = <7>;
+		cs0_dq8_rx_de-skew = <7>;
+		cs0_dq8_tx_de-skew = <8>;
+		cs0_dq9_rx_de-skew = <7>;
+		cs0_dq9_tx_de-skew = <7>;
+		cs0_dq10_rx_de-skew = <7>;
+		cs0_dq10_tx_de-skew = <8>;
+		cs0_dq11_rx_de-skew = <7>;
+		cs0_dq11_tx_de-skew = <7>;
+		cs0_dq12_rx_de-skew = <7>;
+		cs0_dq12_tx_de-skew = <8>;
+		cs0_dq13_rx_de-skew = <7>;
+		cs0_dq13_tx_de-skew = <7>;
+		cs0_dq14_rx_de-skew = <7>;
+		cs0_dq14_tx_de-skew = <8>;
+		cs0_dq15_rx_de-skew = <7>;
+		cs0_dq15_tx_de-skew = <7>;
+		cs0_dqs1_rx_de-skew = <7>;
+		cs0_dqs1p_tx_de-skew = <9>;
+		cs0_dqs1n_tx_de-skew = <9>;
+
+		cs0_dm2_rx_de-skew = <7>;
+		cs0_dm2_tx_de-skew = <8>;
+		cs0_dq16_rx_de-skew = <7>;
+		cs0_dq16_tx_de-skew = <8>;
+		cs0_dq17_rx_de-skew = <7>;
+		cs0_dq17_tx_de-skew = <8>;
+		cs0_dq18_rx_de-skew = <7>;
+		cs0_dq18_tx_de-skew = <8>;
+		cs0_dq19_rx_de-skew = <7>;
+		cs0_dq19_tx_de-skew = <8>;
+		cs0_dq20_rx_de-skew = <7>;
+		cs0_dq20_tx_de-skew = <8>;
+		cs0_dq21_rx_de-skew = <7>;
+		cs0_dq21_tx_de-skew = <8>;
+		cs0_dq22_rx_de-skew = <7>;
+		cs0_dq22_tx_de-skew = <8>;
+		cs0_dq23_rx_de-skew = <7>;
+		cs0_dq23_tx_de-skew = <8>;
+		cs0_dqs2_rx_de-skew = <6>;
+		cs0_dqs2p_tx_de-skew = <9>;
+		cs0_dqs2n_tx_de-skew = <9>;
+
+		cs0_dm3_rx_de-skew = <7>;
+		cs0_dm3_tx_de-skew = <7>;
+		cs0_dq24_rx_de-skew = <7>;
+		cs0_dq24_tx_de-skew = <8>;
+		cs0_dq25_rx_de-skew = <7>;
+		cs0_dq25_tx_de-skew = <7>;
+		cs0_dq26_rx_de-skew = <7>;
+		cs0_dq26_tx_de-skew = <7>;
+		cs0_dq27_rx_de-skew = <7>;
+		cs0_dq27_tx_de-skew = <7>;
+		cs0_dq28_rx_de-skew = <7>;
+		cs0_dq28_tx_de-skew = <7>;
+		cs0_dq29_rx_de-skew = <7>;
+		cs0_dq29_tx_de-skew = <7>;
+		cs0_dq30_rx_de-skew = <7>;
+		cs0_dq30_tx_de-skew = <7>;
+		cs0_dq31_rx_de-skew = <7>;
+		cs0_dq31_tx_de-skew = <7>;
+		cs0_dqs3_rx_de-skew = <7>;
+		cs0_dqs3p_tx_de-skew = <9>;
+		cs0_dqs3n_tx_de-skew = <9>;
+
+		cs1_dm0_rx_de-skew = <7>;
+		cs1_dm0_tx_de-skew = <8>;
+		cs1_dq0_rx_de-skew = <7>;
+		cs1_dq0_tx_de-skew = <8>;
+		cs1_dq1_rx_de-skew = <7>;
+		cs1_dq1_tx_de-skew = <8>;
+		cs1_dq2_rx_de-skew = <7>;
+		cs1_dq2_tx_de-skew = <8>;
+		cs1_dq3_rx_de-skew = <7>;
+		cs1_dq3_tx_de-skew = <8>;
+		cs1_dq4_rx_de-skew = <7>;
+		cs1_dq4_tx_de-skew = <8>;
+		cs1_dq5_rx_de-skew = <7>;
+		cs1_dq5_tx_de-skew = <8>;
+		cs1_dq6_rx_de-skew = <7>;
+		cs1_dq6_tx_de-skew = <8>;
+		cs1_dq7_rx_de-skew = <7>;
+		cs1_dq7_tx_de-skew = <8>;
+		cs1_dqs0_rx_de-skew = <6>;
+		cs1_dqs0p_tx_de-skew = <9>;
+		cs1_dqs0n_tx_de-skew = <9>;
+
+		cs1_dm1_rx_de-skew = <7>;
+		cs1_dm1_tx_de-skew = <7>;
+		cs1_dq8_rx_de-skew = <7>;
+		cs1_dq8_tx_de-skew = <8>;
+		cs1_dq9_rx_de-skew = <7>;
+		cs1_dq9_tx_de-skew = <7>;
+		cs1_dq10_rx_de-skew = <7>;
+		cs1_dq10_tx_de-skew = <8>;
+		cs1_dq11_rx_de-skew = <7>;
+		cs1_dq11_tx_de-skew = <7>;
+		cs1_dq12_rx_de-skew = <7>;
+		cs1_dq12_tx_de-skew = <8>;
+		cs1_dq13_rx_de-skew = <7>;
+		cs1_dq13_tx_de-skew = <7>;
+		cs1_dq14_rx_de-skew = <7>;
+		cs1_dq14_tx_de-skew = <8>;
+		cs1_dq15_rx_de-skew = <7>;
+		cs1_dq15_tx_de-skew = <7>;
+		cs1_dqs1_rx_de-skew = <7>;
+		cs1_dqs1p_tx_de-skew = <9>;
+		cs1_dqs1n_tx_de-skew = <9>;
+
+		cs1_dm2_rx_de-skew = <7>;
+		cs1_dm2_tx_de-skew = <8>;
+		cs1_dq16_rx_de-skew = <7>;
+		cs1_dq16_tx_de-skew = <8>;
+		cs1_dq17_rx_de-skew = <7>;
+		cs1_dq17_tx_de-skew = <8>;
+		cs1_dq18_rx_de-skew = <7>;
+		cs1_dq18_tx_de-skew = <8>;
+		cs1_dq19_rx_de-skew = <7>;
+		cs1_dq19_tx_de-skew = <8>;
+		cs1_dq20_rx_de-skew = <7>;
+		cs1_dq20_tx_de-skew = <8>;
+		cs1_dq21_rx_de-skew = <7>;
+		cs1_dq21_tx_de-skew = <8>;
+		cs1_dq22_rx_de-skew = <7>;
+		cs1_dq22_tx_de-skew = <8>;
+		cs1_dq23_rx_de-skew = <7>;
+		cs1_dq23_tx_de-skew = <8>;
+		cs1_dqs2_rx_de-skew = <6>;
+		cs1_dqs2p_tx_de-skew = <9>;
+		cs1_dqs2n_tx_de-skew = <9>;
+
+		cs1_dm3_rx_de-skew = <7>;
+		cs1_dm3_tx_de-skew = <7>;
+		cs1_dq24_rx_de-skew = <7>;
+		cs1_dq24_tx_de-skew = <8>;
+		cs1_dq25_rx_de-skew = <7>;
+		cs1_dq25_tx_de-skew = <7>;
+		cs1_dq26_rx_de-skew = <7>;
+		cs1_dq26_tx_de-skew = <7>;
+		cs1_dq27_rx_de-skew = <7>;
+		cs1_dq27_tx_de-skew = <7>;
+		cs1_dq28_rx_de-skew = <7>;
+		cs1_dq28_tx_de-skew = <7>;
+		cs1_dq29_rx_de-skew = <7>;
+		cs1_dq29_tx_de-skew = <7>;
+		cs1_dq30_rx_de-skew = <7>;
+		cs1_dq30_tx_de-skew = <7>;
+		cs1_dq31_rx_de-skew = <7>;
+		cs1_dq31_tx_de-skew = <7>;
+		cs1_dqs3_rx_de-skew = <7>;
+		cs1_dqs3p_tx_de-skew = <9>;
+		cs1_dqs3n_tx_de-skew = <9>;
+	};
+};
diff --git a/arch/arm64/boot/dts/rockchip/rk3328-dram-renegade-timing.dtsi b/arch/arm64/boot/dts/rockchip/rk3328-dram-renegade-timing.dtsi
new file mode 100644
index 000000000000..303428153094
--- /dev/null
+++ b/arch/arm64/boot/dts/rockchip/rk3328-dram-renegade-timing.dtsi
@@ -0,0 +1,311 @@
+/*
+ * Copyright (c) 2017 Fuzhou Rockchip Electronics Co., Ltd
+ *
+ * This file is dual-licensed: you can use it either under the terms
+ * of the GPL or the X11 license, at your option. Note that this dual
+ * licensing only applies to this file, and not this project as a
+ * whole.
+ *
+ *  a) This library is free software; you can redistribute it and/or
+ *     modify it under the terms of the GNU General Public License as
+ *     published by the Free Software Foundation; either version 2 of the
+ *     License, or (at your option) any later version.
+ *
+ *     This library is distributed in the hope that it will be useful,
+ *     but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *     GNU General Public License for more details.
+ *
+ * Or, alternatively,
+ *
+ *  b) Permission is hereby granted, free of charge, to any person
+ *     obtaining a copy of this software and associated documentation
+ *     files (the "Software"), to deal in the Software without
+ *     restriction, including without limitation the rights to use,
+ *     copy, modify, merge, publish, distribute, sublicense, and/or
+ *     sell copies of the Software, and to permit persons to whom the
+ *     Software is furnished to do so, subject to the following
+ *     conditions:
+ *
+ *     The above copyright notice and this permission notice shall be
+ *     included in all copies or substantial portions of the Software.
+ *
+ *     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ *     EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
+ *     OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ *     NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+ *     HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+ *     WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ *     FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ *     OTHER DEALINGS IN THE SOFTWARE.
+ */
+#include <dt-bindings/clock/rockchip-ddr.h>
+#include <dt-bindings/memory/rk3328-dram.h>
+
+/ {
+	ddr_timing: ddr_timing {
+		compatible = "rockchip,ddr-timing";
+		ddr3_speed_bin = <DDR3_DEFAULT>;
+		ddr4_speed_bin = <DDR4_DEFAULT>;
+		pd_idle = <0>;
+		sr_idle = <0>;
+		sr_mc_gate_idle = <0>;
+		srpd_lite_idle	= <0>;
+		standby_idle = <0>;
+
+		auto_pd_dis_freq = <1066>;
+		auto_sr_dis_freq = <800>;
+		ddr3_dll_dis_freq = <300>;
+		ddr4_dll_dis_freq = <625>;
+		phy_dll_dis_freq = <400>;
+
+		ddr3_odt_dis_freq = <100>;
+		phy_ddr3_odt_dis_freq = <100>;
+		ddr3_drv = <DDR3_DS_40ohm>;
+		ddr3_odt = <DDR3_ODT_120ohm>;
+		phy_ddr3_ca_drv = <PHY_DDR3_RON_RTT_34ohm>;
+		phy_ddr3_ck_drv = <PHY_DDR3_RON_RTT_45ohm>;
+		phy_ddr3_dq_drv = <PHY_DDR3_RON_RTT_34ohm>;
+		phy_ddr3_odt = <PHY_DDR3_RON_RTT_225ohm>;
+
+		lpddr3_odt_dis_freq = <666>;
+		phy_lpddr3_odt_dis_freq = <666>;
+		lpddr3_drv = <LP3_DS_40ohm>;
+		lpddr3_odt = <LP3_ODT_240ohm>;
+		phy_lpddr3_ca_drv = <PHY_DDR4_LPDDR3_RON_RTT_34ohm>;
+		phy_lpddr3_ck_drv = <PHY_DDR4_LPDDR3_RON_RTT_43ohm>;
+		phy_lpddr3_dq_drv = <PHY_DDR4_LPDDR3_RON_RTT_34ohm>;
+		phy_lpddr3_odt = <PHY_DDR4_LPDDR3_RON_RTT_240ohm>;
+
+		lpddr4_odt_dis_freq = <800>;
+		phy_lpddr4_odt_dis_freq = <800>;
+		lpddr4_drv = <LP4_PDDS_60ohm>;
+		lpddr4_dq_odt = <LP4_DQ_ODT_40ohm>;
+		lpddr4_ca_odt = <LP4_CA_ODT_40ohm>;
+		phy_lpddr4_ca_drv = <PHY_DDR4_LPDDR3_RON_RTT_40ohm>;
+		phy_lpddr4_ck_cs_drv = <PHY_DDR4_LPDDR3_RON_RTT_80ohm>;
+		phy_lpddr4_dq_drv = <PHY_DDR4_LPDDR3_RON_RTT_80ohm>;
+		phy_lpddr4_odt = <PHY_DDR4_LPDDR3_RON_RTT_60ohm>;
+
+		ddr4_odt_dis_freq = <666>;
+		phy_ddr4_odt_dis_freq = <666>;
+		ddr4_drv = <DDR4_DS_34ohm>;
+		ddr4_odt = <DDR4_RTT_NOM_240ohm>;
+		phy_ddr4_ca_drv = <PHY_DDR4_LPDDR3_RON_RTT_34ohm>;
+		phy_ddr4_ck_drv = <PHY_DDR4_LPDDR3_RON_RTT_43ohm>;
+		phy_ddr4_dq_drv = <PHY_DDR4_LPDDR3_RON_RTT_34ohm>;
+		phy_ddr4_odt = <PHY_DDR4_LPDDR3_RON_RTT_240ohm>;
+
+		/* CA de-skew, one step is 47.8ps, range 0-15 */
+		ddr3a1_ddr4a9_de-skew = <0>;
+		ddr3a0_ddr4a10_de-skew = <0>;
+		ddr3a3_ddr4a6_de-skew = <1>;
+		ddr3a2_ddr4a4_de-skew = <1>;
+		ddr3a5_ddr4a8_de-skew = <0>;
+		ddr3a4_ddr4a5_de-skew = <2>;
+		ddr3a7_ddr4a11_de-skew = <0>;
+		ddr3a6_ddr4a7_de-skew = <2>;
+		ddr3a9_ddr4a0_de-skew = <1>;
+		ddr3a8_ddr4a13_de-skew = <0>;
+		ddr3a11_ddr4a3_de-skew = <2>;
+		ddr3a10_ddr4cs0_de-skew = <0>;
+		ddr3a13_ddr4a2_de-skew = <1>;
+		ddr3a12_ddr4ba1_de-skew = <0>;
+		ddr3a15_ddr4odt0_de-skew = <0>;
+		ddr3a14_ddr4a1_de-skew = <1>;
+		ddr3ba1_ddr4a15_de-skew = <0>;
+		ddr3ba0_ddr4bg0_de-skew = <0>;
+		ddr3ras_ddr4cke_de-skew = <0>;
+		ddr3ba2_ddr4ba0_de-skew = <1>;
+		ddr3we_ddr4bg1_de-skew = <1>;
+		ddr3cas_ddr4a12_de-skew = <0>;
+		ddr3ckn_ddr4ckn_de-skew = <5>;
+		ddr3ckp_ddr4ckp_de-skew = <5>;
+		ddr3cke_ddr4a16_de-skew = <1>;
+		ddr3odt0_ddr4a14_de-skew = <0>;
+		ddr3cs0_ddr4act_de-skew = <1>;
+		ddr3reset_ddr4reset_de-skew = <0>;
+		ddr3cs1_ddr4cs1_de-skew = <0>;
+		ddr3odt1_ddr4odt1_de-skew = <0>;
+
+		/* DATA de-skew
+		 * RX one step is 25.1ps, range 0-15
+		 * TX one step is 47.8ps, range 0-15
+		 */
+		cs0_dm0_rx_de-skew = <7>;
+		cs0_dm0_tx_de-skew = <8>;
+		cs0_dq0_rx_de-skew = <7>;
+		cs0_dq0_tx_de-skew = <8>;
+		cs0_dq1_rx_de-skew = <7>;
+		cs0_dq1_tx_de-skew = <8>;
+		cs0_dq2_rx_de-skew = <7>;
+		cs0_dq2_tx_de-skew = <8>;
+		cs0_dq3_rx_de-skew = <7>;
+		cs0_dq3_tx_de-skew = <8>;
+		cs0_dq4_rx_de-skew = <7>;
+		cs0_dq4_tx_de-skew = <8>;
+		cs0_dq5_rx_de-skew = <7>;
+		cs0_dq5_tx_de-skew = <8>;
+		cs0_dq6_rx_de-skew = <7>;
+		cs0_dq6_tx_de-skew = <8>;
+		cs0_dq7_rx_de-skew = <7>;
+		cs0_dq7_tx_de-skew = <8>;
+		cs0_dqs0_rx_de-skew = <6>;
+		cs0_dqs0p_tx_de-skew = <9>;
+		cs0_dqs0n_tx_de-skew = <9>;
+
+		cs0_dm1_rx_de-skew = <7>;
+		cs0_dm1_tx_de-skew = <7>;
+		cs0_dq8_rx_de-skew = <7>;
+		cs0_dq8_tx_de-skew = <8>;
+		cs0_dq9_rx_de-skew = <7>;
+		cs0_dq9_tx_de-skew = <7>;
+		cs0_dq10_rx_de-skew = <7>;
+		cs0_dq10_tx_de-skew = <8>;
+		cs0_dq11_rx_de-skew = <7>;
+		cs0_dq11_tx_de-skew = <7>;
+		cs0_dq12_rx_de-skew = <7>;
+		cs0_dq12_tx_de-skew = <8>;
+		cs0_dq13_rx_de-skew = <7>;
+		cs0_dq13_tx_de-skew = <7>;
+		cs0_dq14_rx_de-skew = <7>;
+		cs0_dq14_tx_de-skew = <8>;
+		cs0_dq15_rx_de-skew = <7>;
+		cs0_dq15_tx_de-skew = <7>;
+		cs0_dqs1_rx_de-skew = <7>;
+		cs0_dqs1p_tx_de-skew = <9>;
+		cs0_dqs1n_tx_de-skew = <9>;
+
+		cs0_dm2_rx_de-skew = <7>;
+		cs0_dm2_tx_de-skew = <8>;
+		cs0_dq16_rx_de-skew = <7>;
+		cs0_dq16_tx_de-skew = <8>;
+		cs0_dq17_rx_de-skew = <7>;
+		cs0_dq17_tx_de-skew = <8>;
+		cs0_dq18_rx_de-skew = <7>;
+		cs0_dq18_tx_de-skew = <8>;
+		cs0_dq19_rx_de-skew = <7>;
+		cs0_dq19_tx_de-skew = <8>;
+		cs0_dq20_rx_de-skew = <7>;
+		cs0_dq20_tx_de-skew = <8>;
+		cs0_dq21_rx_de-skew = <7>;
+		cs0_dq21_tx_de-skew = <8>;
+		cs0_dq22_rx_de-skew = <7>;
+		cs0_dq22_tx_de-skew = <8>;
+		cs0_dq23_rx_de-skew = <7>;
+		cs0_dq23_tx_de-skew = <8>;
+		cs0_dqs2_rx_de-skew = <6>;
+		cs0_dqs2p_tx_de-skew = <9>;
+		cs0_dqs2n_tx_de-skew = <9>;
+
+		cs0_dm3_rx_de-skew = <7>;
+		cs0_dm3_tx_de-skew = <7>;
+		cs0_dq24_rx_de-skew = <7>;
+		cs0_dq24_tx_de-skew = <8>;
+		cs0_dq25_rx_de-skew = <7>;
+		cs0_dq25_tx_de-skew = <7>;
+		cs0_dq26_rx_de-skew = <7>;
+		cs0_dq26_tx_de-skew = <7>;
+		cs0_dq27_rx_de-skew = <7>;
+		cs0_dq27_tx_de-skew = <7>;
+		cs0_dq28_rx_de-skew = <7>;
+		cs0_dq28_tx_de-skew = <7>;
+		cs0_dq29_rx_de-skew = <7>;
+		cs0_dq29_tx_de-skew = <7>;
+		cs0_dq30_rx_de-skew = <7>;
+		cs0_dq30_tx_de-skew = <7>;
+		cs0_dq31_rx_de-skew = <7>;
+		cs0_dq31_tx_de-skew = <7>;
+		cs0_dqs3_rx_de-skew = <7>;
+		cs0_dqs3p_tx_de-skew = <9>;
+		cs0_dqs3n_tx_de-skew = <9>;
+
+		cs1_dm0_rx_de-skew = <7>;
+		cs1_dm0_tx_de-skew = <8>;
+		cs1_dq0_rx_de-skew = <7>;
+		cs1_dq0_tx_de-skew = <8>;
+		cs1_dq1_rx_de-skew = <7>;
+		cs1_dq1_tx_de-skew = <8>;
+		cs1_dq2_rx_de-skew = <7>;
+		cs1_dq2_tx_de-skew = <8>;
+		cs1_dq3_rx_de-skew = <7>;
+		cs1_dq3_tx_de-skew = <8>;
+		cs1_dq4_rx_de-skew = <7>;
+		cs1_dq4_tx_de-skew = <8>;
+		cs1_dq5_rx_de-skew = <7>;
+		cs1_dq5_tx_de-skew = <8>;
+		cs1_dq6_rx_de-skew = <7>;
+		cs1_dq6_tx_de-skew = <8>;
+		cs1_dq7_rx_de-skew = <7>;
+		cs1_dq7_tx_de-skew = <8>;
+		cs1_dqs0_rx_de-skew = <6>;
+		cs1_dqs0p_tx_de-skew = <9>;
+		cs1_dqs0n_tx_de-skew = <9>;
+
+		cs1_dm1_rx_de-skew = <7>;
+		cs1_dm1_tx_de-skew = <7>;
+		cs1_dq8_rx_de-skew = <7>;
+		cs1_dq8_tx_de-skew = <8>;
+		cs1_dq9_rx_de-skew = <7>;
+		cs1_dq9_tx_de-skew = <7>;
+		cs1_dq10_rx_de-skew = <7>;
+		cs1_dq10_tx_de-skew = <8>;
+		cs1_dq11_rx_de-skew = <7>;
+		cs1_dq11_tx_de-skew = <7>;
+		cs1_dq12_rx_de-skew = <7>;
+		cs1_dq12_tx_de-skew = <8>;
+		cs1_dq13_rx_de-skew = <7>;
+		cs1_dq13_tx_de-skew = <7>;
+		cs1_dq14_rx_de-skew = <7>;
+		cs1_dq14_tx_de-skew = <8>;
+		cs1_dq15_rx_de-skew = <7>;
+		cs1_dq15_tx_de-skew = <7>;
+		cs1_dqs1_rx_de-skew = <7>;
+		cs1_dqs1p_tx_de-skew = <9>;
+		cs1_dqs1n_tx_de-skew = <9>;
+
+		cs1_dm2_rx_de-skew = <7>;
+		cs1_dm2_tx_de-skew = <8>;
+		cs1_dq16_rx_de-skew = <7>;
+		cs1_dq16_tx_de-skew = <8>;
+		cs1_dq17_rx_de-skew = <7>;
+		cs1_dq17_tx_de-skew = <8>;
+		cs1_dq18_rx_de-skew = <7>;
+		cs1_dq18_tx_de-skew = <8>;
+		cs1_dq19_rx_de-skew = <7>;
+		cs1_dq19_tx_de-skew = <8>;
+		cs1_dq20_rx_de-skew = <7>;
+		cs1_dq20_tx_de-skew = <8>;
+		cs1_dq21_rx_de-skew = <7>;
+		cs1_dq21_tx_de-skew = <8>;
+		cs1_dq22_rx_de-skew = <7>;
+		cs1_dq22_tx_de-skew = <8>;
+		cs1_dq23_rx_de-skew = <7>;
+		cs1_dq23_tx_de-skew = <8>;
+		cs1_dqs2_rx_de-skew = <6>;
+		cs1_dqs2p_tx_de-skew = <9>;
+		cs1_dqs2n_tx_de-skew = <9>;
+
+		cs1_dm3_rx_de-skew = <7>;
+		cs1_dm3_tx_de-skew = <7>;
+		cs1_dq24_rx_de-skew = <7>;
+		cs1_dq24_tx_de-skew = <8>;
+		cs1_dq25_rx_de-skew = <7>;
+		cs1_dq25_tx_de-skew = <7>;
+		cs1_dq26_rx_de-skew = <7>;
+		cs1_dq26_tx_de-skew = <7>;
+		cs1_dq27_rx_de-skew = <7>;
+		cs1_dq27_tx_de-skew = <7>;
+		cs1_dq28_rx_de-skew = <7>;
+		cs1_dq28_tx_de-skew = <7>;
+		cs1_dq29_rx_de-skew = <7>;
+		cs1_dq29_tx_de-skew = <7>;
+		cs1_dq30_rx_de-skew = <7>;
+		cs1_dq30_tx_de-skew = <7>;
+		cs1_dq31_rx_de-skew = <7>;
+		cs1_dq31_tx_de-skew = <7>;
+		cs1_dqs3_rx_de-skew = <7>;
+		cs1_dqs3p_tx_de-skew = <9>;
+		cs1_dqs3n_tx_de-skew = <9>;
+	};
+};
diff --git a/arch/arm64/boot/dts/rockchip/rk3328-roc.dtsi b/arch/arm64/boot/dts/rockchip/rk3328-roc.dtsi
old mode 100644
new mode 100755
index b5bd5e7d5748..4bfddbfe8428
--- a/arch/arm64/boot/dts/rockchip/rk3328-roc.dtsi
+++ b/arch/arm64/boot/dts/rockchip/rk3328-roc.dtsi
@@ -5,6 +5,7 @@
 
 /dts-v1/;
 
+#include "rk3328-dram-renegade-timing.dtsi"
 #include "rk3328.dtsi"
 
 / {
@@ -18,6 +19,32 @@ chosen {
 		stdout-path = "serial2:1500000n8";
 	};
 
+	/delete-node/ dmc-opp-table;
+	dmc_opp_table: dmc-opp-table {
+		compatible = "operating-points-v2";
+
+		opp-786000000 {
+			opp-hz = /bits/ 64 <786000000>;
+			opp-microvolt = <1075000 1075000 12000000>;
+		};
+		opp-798000000 {
+			opp-hz = /bits/ 64 <798000000>;
+			opp-microvolt = <1075000 1075000 12000000>;
+		};
+		opp-840000000 {
+			opp-hz = /bits/ 64 <840000000>;
+			opp-microvolt = <1075000 1075000 12000000>;
+		};
+		opp-924000000 {
+			opp-hz = /bits/ 64 <924000000>;
+			opp-microvolt = <1100000 1100000 12000000>;
+		};
+		opp-1068000000 {
+			opp-hz = /bits/ 64 <1068000000>;
+			opp-microvolt = <1175000 1175000 12000000>;
+		};
+	};
+
 	gmac_clkin: external-gmac-clock {
 		compatible = "fixed-clock";
 		clock-frequency = <125000000>;
@@ -111,6 +138,17 @@ &codec {
 	status = "okay";
 };
 
+&dfi {
+	status = "okay";
+};
+
+&dmc {
+	center-supply = <&vdd_logic>;
+	ddr_timing = <&ddr_timing>;
+	status = "okay";
+};
+
+
 &cpu0 {
 	cpu-supply = <&vdd_arm>;
 };
@@ -330,6 +368,19 @@ &sdmmc {
 	status = "okay";
 };
 
+&spdif {
+	pinctrl-0 = <&spdifm0_tx>;
+	status = "okay";
+};
+
+&spdif_out {
+	status = "okay";
+};
+
+&spdif_sound {
+ 	status = "okay";
+};
+
 &tsadc {
 	status = "okay";
 };
diff --git a/arch/arm64/boot/dts/rockchip/rk3328-roc.dtsi.orig b/arch/arm64/boot/dts/rockchip/rk3328-roc.dtsi.orig
new file mode 100644
index 000000000000..d1837d4d383a
--- /dev/null
+++ b/arch/arm64/boot/dts/rockchip/rk3328-roc.dtsi.orig
@@ -0,0 +1,415 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright (c) 2017 T-Chip Intelligent Technology Co., Ltd
+ */
+
+/dts-v1/;
+
+#include "rk3328-dram-renegade-timing.dtsi"
+#include "rk3328.dtsi"
+
+/ {
+	aliases {
+		ethernet0 = &gmac2io;
+		mmc0 = &sdmmc;
+		mmc1 = &emmc;
+	};
+
+	chosen {
+		stdout-path = "serial2:1500000n8";
+	};
+
+	/delete-node/ dmc-opp-table;
+	dmc_opp_table: dmc-opp-table {
+		compatible = "operating-points-v2";
+
+		opp-786000000 {
+			opp-hz = /bits/ 64 <786000000>;
+			opp-microvolt = <1075000 1075000 12000000>;
+		};
+		opp-798000000 {
+			opp-hz = /bits/ 64 <798000000>;
+			opp-microvolt = <1075000 1075000 12000000>;
+		};
+		opp-840000000 {
+			opp-hz = /bits/ 64 <840000000>;
+			opp-microvolt = <1075000 1075000 12000000>;
+		};
+		opp-924000000 {
+			opp-hz = /bits/ 64 <924000000>;
+			opp-microvolt = <1100000 1100000 12000000>;
+		};
+		opp-1068000000 {
+			opp-hz = /bits/ 64 <1068000000>;
+			opp-microvolt = <1175000 1175000 12000000>;
+		};
+	};
+
+	gmac_clkin: external-gmac-clock {
+		compatible = "fixed-clock";
+		clock-frequency = <125000000>;
+		clock-output-names = "gmac_clkin";
+		#clock-cells = <0>;
+	};
+
+	dc_12v: regulator-dc-12v {
+		compatible = "regulator-fixed";
+		regulator-name = "dc_12v";
+		regulator-always-on;
+		regulator-boot-on;
+		regulator-min-microvolt = <12000000>;
+		regulator-max-microvolt = <12000000>;
+	};
+
+	vcc_sd: regulator-sdmmc {
+		compatible = "regulator-fixed";
+		gpio = <&gpio0 RK_PD6 GPIO_ACTIVE_LOW>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&sdmmc0m1_pin>;
+		regulator-boot-on;
+		regulator-name = "vcc_sd";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+		vin-supply = <&vcc_io>;
+	};
+
+	vcc_sdio: regulator-sdmmcio {
+		compatible = "regulator-gpio";
+		states = <1800000 0x1>, <3300000 0x0>;
+		regulator-name = "vcc_sdio";
+		regulator-type = "voltage";
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <3300000>;
+		regulator-always-on;
+		vin-supply = <&vcc_sys>;
+	};
+
+	vcc_host1_5v: vcc_otg_5v: regulator-vcc-host1-5v {
+		compatible = "regulator-fixed";
+		enable-active-high;
+		pinctrl-names = "default";
+		pinctrl-0 = <&usb20_host_drv>;
+		regulator-name = "vcc_host1_5v";
+		regulator-always-on;
+		vin-supply = <&vcc_sys>;
+	};
+
+	vcc_sys: regulator-vcc-sys {
+		compatible = "regulator-fixed";
+		regulator-name = "vcc_sys";
+		regulator-always-on;
+		regulator-boot-on;
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+		vin-supply = <&dc_12v>;
+	};
+
+	vcc_phy: regulator-vcc-phy {
+		compatible = "regulator-fixed";
+		regulator-name = "vcc_phy";
+		regulator-always-on;
+		regulator-boot-on;
+	};
+
+	leds {
+		compatible = "gpio-leds";
+
+		power_led: led-0 {
+			label = "firefly:blue:power";
+			linux,default-trigger = "heartbeat";
+			gpios = <&rk805 1 GPIO_ACTIVE_LOW>;
+			default-state = "on";
+		};
+
+		user_led: led-1 {
+			label = "firefly:yellow:user";
+			linux,default-trigger = "mmc1";
+			gpios = <&rk805 0 GPIO_ACTIVE_LOW>;
+			default-state = "off";
+		};
+	};
+};
+
+&analog_sound {
+	status = "okay";
+};
+
+&codec {
+	status = "okay";
+};
+
+&dfi {
+	status = "okay";
+};
+
+&dmc {
+	center-supply = <&vdd_logic>;
+	ddr_timing = <&ddr_timing>;
+	status = "okay";
+};
+
+
+&cpu0 {
+	cpu-supply = <&vdd_arm>;
+};
+
+&cpu1 {
+	cpu-supply = <&vdd_arm>;
+};
+
+&cpu2 {
+	cpu-supply = <&vdd_arm>;
+};
+
+&cpu3 {
+	cpu-supply = <&vdd_arm>;
+};
+
+&emmc {
+	bus-width = <8>;
+	cap-mmc-highspeed;
+	max-frequency = <150000000>;
+	mmc-ddr-1_8v;
+	mmc-hs200-1_8v;
+	non-removable;
+	pinctrl-names = "default";
+	pinctrl-0 = <&emmc_clk &emmc_cmd &emmc_bus8>;
+	vmmc-supply = <&vcc_io>;
+	vqmmc-supply = <&vcc18_emmc>;
+	status = "okay";
+};
+
+&gmac2io {
+	assigned-clocks = <&cru SCLK_MAC2IO>, <&cru SCLK_MAC2IO_EXT>;
+	assigned-clock-parents = <&gmac_clkin>, <&gmac_clkin>;
+	clock_in_out = "input";
+	phy-supply = <&vcc_phy>;
+	phy-mode = "rgmii";
+	pinctrl-names = "default";
+	pinctrl-0 = <&rgmiim1_pins>;
+	snps,aal;
+	snps,reset-gpio = <&gpio1 RK_PC2 GPIO_ACTIVE_LOW>;
+	snps,reset-active-low;
+	snps,reset-delays-us = <0 10000 50000>;
+	snps,rxpbl = <0x4>;
+	snps,txpbl = <0x4>;
+	tx_delay = <0x24>;
+	rx_delay = <0x18>;
+	status = "okay";
+};
+
+&hdmi {
+	status = "okay";
+};
+
+&hdmiphy {
+	status = "okay";
+};
+
+&hdmi_sound {
+	status = "okay";
+};
+
+&i2c1 {
+	status = "okay";
+
+	rk805: pmic@18 {
+		compatible = "rockchip,rk805";
+		reg = <0x18>;
+		#clock-cells = <1>;
+		clock-output-names = "xin32k", "rk805-clkout2";
+		gpio-controller;
+		#gpio-cells = <2>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&pmic_int_l>;
+		system-power-controller;
+		wakeup-source;
+
+		vcc1-supply = <&vcc_sys>;
+		vcc2-supply = <&vcc_sys>;
+		vcc3-supply = <&vcc_sys>;
+		vcc4-supply = <&vcc_sys>;
+		vcc5-supply = <&vcc_io>;
+		vcc6-supply = <&vcc_io>;
+
+		regulators {
+			vdd_logic: DCDC_REG1 {
+				regulator-name = "vdd_logic";
+				regulator-min-microvolt = <712500>;
+				regulator-max-microvolt = <1450000>;
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-state-mem {
+					regulator-on-in-suspend;
+					regulator-suspend-microvolt = <1000000>;
+				};
+			};
+
+			vdd_arm: DCDC_REG2 {
+				regulator-name = "vdd_arm";
+				regulator-min-microvolt = <712500>;
+				regulator-max-microvolt = <1450000>;
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-state-mem {
+					regulator-on-in-suspend;
+					regulator-suspend-microvolt = <950000>;
+				};
+			};
+
+			vcc_ddr: DCDC_REG3 {
+				regulator-name = "vcc_ddr";
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-state-mem {
+					regulator-on-in-suspend;
+				};
+			};
+
+			vcc_io: DCDC_REG4 {
+				regulator-name = "vcc_io";
+				regulator-min-microvolt = <3300000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-state-mem {
+					regulator-on-in-suspend;
+					regulator-suspend-microvolt = <3300000>;
+				};
+			};
+
+			vcc_18: LDO_REG1 {
+				regulator-name = "vcc_18";
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <1800000>;
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-state-mem {
+					regulator-on-in-suspend;
+					regulator-suspend-microvolt = <1800000>;
+				};
+			};
+
+			vcc18_emmc: LDO_REG2 {
+				regulator-name = "vcc18_emmc";
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <1800000>;
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-state-mem {
+					regulator-on-in-suspend;
+					regulator-suspend-microvolt = <1800000>;
+				};
+			};
+
+			vdd_10: LDO_REG3 {
+				regulator-name = "vdd_10";
+				regulator-min-microvolt = <1000000>;
+				regulator-max-microvolt = <1000000>;
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-state-mem {
+					regulator-on-in-suspend;
+					regulator-suspend-microvolt = <1000000>;
+				};
+			};
+		};
+	};
+};
+
+&i2s0 {
+	status = "okay";
+};
+
+&i2s1 {
+	status = "okay";
+};
+
+&io_domains {
+	status = "okay";
+
+	vccio1-supply = <&vcc_io>;
+	vccio2-supply = <&vcc18_emmc>;
+	vccio3-supply = <&vcc_sdio>;
+	vccio4-supply = <&vcc_18>;
+	vccio5-supply = <&vcc_io>;
+	vccio6-supply = <&vcc_io>;
+	pmuio-supply = <&vcc_io>;
+};
+
+&pinctrl {
+	pmic {
+		pmic_int_l: pmic-int-l {
+			rockchip,pins = <1 RK_PD0 RK_FUNC_GPIO &pcfg_pull_up>;
+		};
+	};
+
+	usb2 {
+		usb20_host_drv: usb20-host-drv {
+			rockchip,pins = <1 RK_PD2 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+	};
+};
+
+&sdmmc {
+	bus-width = <4>;
+	cap-mmc-highspeed;
+	cap-sd-highspeed;
+	disable-wp;
+	max-frequency = <150000000>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&sdmmc0_clk &sdmmc0_cmd &sdmmc0_dectn &sdmmc0_bus4>;
+	sd-uhs-sdr12;
+	sd-uhs-sdr25;
+	sd-uhs-sdr50;
+	sd-uhs-sdr104;
+	vmmc-supply = <&vcc_sd>;
+	vqmmc-supply = <&vcc_sdio>;
+	status = "okay";
+};
+
+&tsadc {
+	status = "okay";
+};
+
+&u2phy {
+	status = "okay";
+};
+
+&u2phy_host {
+	status = "okay";
+};
+
+&u2phy_otg {
+	status = "okay";
+};
+
+&uart2 {
+	status = "okay";
+};
+
+&usb20_otg {
+	dr_mode = "host";
+	status = "okay";
+};
+
+&usbdrd3 {
+	dr_mode = "host";
+	status = "okay";
+};
+
+&usb_host0_ehci {
+	status = "okay";
+};
+
+&usb_host0_ohci {
+	status = "okay";
+};
+
+&vop {
+	status = "okay";
+};
+
+&vop_mmu {
+	status = "okay";
+};
diff --git a/arch/arm64/boot/dts/rockchip/rk3328.dtsi b/arch/arm64/boot/dts/rockchip/rk3328.dtsi
index 6438c969f9d7..350078cddb90 100644
--- a/arch/arm64/boot/dts/rockchip/rk3328.dtsi
+++ b/arch/arm64/boot/dts/rockchip/rk3328.dtsi
@@ -224,6 +224,26 @@ psci {
 		method = "smc";
 	};
 
+	spdif_out: spdif-out {
+		compatible = "linux,spdif-dit";
+		#sound-dai-cells = <0>;
+		status = "disabled";
+	};
+
+	spdif_sound: spdif-sound {
+		compatible = "simple-audio-card";
+		simple-audio-card,name = "SPDIF";
+		status = "disabled";
+
+		simple-audio-card,cpu {
+			sound-dai = <&spdif>;
+		};
+
+		simple-audio-card,codec {
+			sound-dai = <&spdif_out>;
+		};
+	};
+
 	timer {
 		compatible = "arm,armv8-timer";
 		interrupts = <GIC_PPI 13 (GIC_CPU_MASK_SIMPLE(4) | IRQ_TYPE_LEVEL_LOW)>,
@@ -595,6 +615,67 @@ tsadc: tsadc@ff250000 {
 		status = "disabled";
 	};
 
+	dfi: dfi@ff790000 {
+		reg = <0x00 0xff790000 0x00 0x400>;
+		compatible = "rockchip,rk3328-dfi";
+		rockchip,grf = <&grf>;
+		status = "okay";
+	};
+
+	dmc: dmc@ff780000 {
+		reg = <0x00 0xff780000 0x00 0x400>;
+		compatible = "rockchip,rk3328-dmc";
+		devfreq-events = <&dfi>;
+		clocks = <&cru SCLK_DDRCLK>;
+		clock-names = "dmc_clk";
+		operating-points-v2 = <&dmc_opp_table>;
+		#cooling-cells = <2>;
+		status = "disabled";
+	};
+
+	dmc_opp_table: dmc-opp-table {
+		compatible = "operating-points-v2";
+
+		opp-600000000 {
+			opp-hz = /bits/ 64 <600000000>;
+			opp-microvolt = <1000000 1000000 1200000>;
+		};
+
+		opp-666000000 {
+			opp-hz = /bits/ 64 <666000000>;
+			opp-microvolt = <1025000 1025000 1200000>;
+		};
+
+		opp-786000000 {
+			opp-hz = /bits/ 64 <786000000>;
+			opp-microvolt = <1050000 1050000 1200000>;
+		};
+
+		opp-800000000 {
+			opp-hz = /bits/ 64 <800000000>;
+			opp-microvolt = <1050000 1050000 1200000>;
+			status = "disabled";
+		};
+
+		opp-850000000 {
+			opp-hz = /bits/ 64 <850000000>;
+			opp-microvolt = <1050000 1050000 1200000>; // Untested
+			status = "disabled";
+		};
+
+		opp-933000000 {
+			opp-hz = /bits/ 64 <933000000>;
+			opp-microvolt = <1100000 1100000 1200000>; // Untested
+			status = "disabled";
+		};
+
+		opp-1066000000 {
+			opp-hz = /bits/ 64 <1066000000>;
+			opp-microvolt = <1150000 1150000 1200000>; // Untested
+			status = "disabled";
+		};
+	};
+
 	efuse: efuse@ff260000 {
 		compatible = "rockchip,rk3328-efuse";
 		reg = <0x0 0xff260000 0x0 0x50>;
@@ -695,6 +776,20 @@ vpu_mmu: iommu@ff350800 {
 		power-domains = <&power RK3328_PD_VPU>;
 	};
 
+       rga: rga@ff390000 {
+               compatible = "rockchip,rk3328-rga", "rockchip,rk3399-rga";
+               reg = <0x0 0xff390000 0x0 0x1000>;
+               interrupts = <GIC_SPI 33 IRQ_TYPE_LEVEL_HIGH>;
+               clocks = <&cru ACLK_RGA>,
+                       <&cru HCLK_RGA>,
+                       <&cru SCLK_RGA>;
+               clock-names = "aclk", "hclk", "sclk";
+               resets = <&cru SRST_RGA>,
+                       <&cru SRST_RGA_A>,
+                       <&cru SRST_RGA_H>;
+               reset-names = "core", "axi", "ahb";
+       };
+
 	vdec: video-codec@ff360000 {
 		compatible = "rockchip,rk3328-vdec", "rockchip,rk3399-vdec";
 		reg = <0x0 0xff360000 0x0 0x480>;
@@ -838,6 +933,7 @@ cru: clock-controller@ff440000 {
 			<&cru ACLK_BUS_PRE>, <&cru HCLK_BUS_PRE>,
 			<&cru PCLK_BUS_PRE>, <&cru ACLK_PERI_PRE>,
 			<&cru HCLK_PERI>, <&cru PCLK_PERI>,
+			<&cru ACLK_GPU>,
 			<&cru SCLK_RTC32K>;
 		assigned-clock-parents =
 			<&cru HDMIPHY>, <&cru PLL_APLL>,
@@ -859,6 +955,7 @@ cru: clock-controller@ff440000 {
 			<150000000>, <75000000>,
 			<75000000>, <150000000>,
 			<75000000>, <75000000>,
+			<500000000>,
 			<32768>;
 	};
 
@@ -899,6 +996,43 @@ u2phy_host: host-port {
 		};
 	};
 
+	usb3phy: usb3-phy@ff460000 {
+		compatible = "rockchip,rk3328-usb3phy";
+		reg = <0x0 0xff460000 0x0 0x10000>;
+		clocks = <&cru SCLK_REF_USB3OTG>, <&cru PCLK_USB3PHY_OTG>, <&cru PCLK_USB3PHY_PIPE>;
+		clock-names = "refclk-usb3otg", "usb3phy-otg", "usb3phy-pipe";
+		interrupts = <GIC_SPI 75 IRQ_TYPE_LEVEL_HIGH>, <GIC_SPI 76 IRQ_TYPE_LEVEL_HIGH>,
+			     <GIC_SPI 77 IRQ_TYPE_LEVEL_HIGH>, <GIC_SPI 78 IRQ_TYPE_LEVEL_HIGH>;
+		interrupt-names = "bvalid", "id", "linestate", "rxdet";
+		resets = <&cru SRST_USB3PHY_U2>,
+			 <&cru SRST_USB3PHY_U3>,
+			 <&cru SRST_USB3PHY_PIPE>,
+			 <&cru SRST_USB3OTG_UTMI>,
+			 <&cru SRST_USB3PHY_OTG_P>,
+			 <&cru SRST_USB3PHY_PIPE_P>;
+		reset-names = "usb3phy-u2-por", "usb3phy-u3-por",
+			      "usb3phy-pipe-mac", "usb3phy-utmi-mac",
+			      "usb3phy-utmi-apb", "usb3phy-pipe-apb";
+		#address-cells = <2>;
+		#size-cells = <2>;
+		ranges;
+		status = "okay";
+
+		usb3phy_utmi: utmi-port@ff470000 {
+			compatible = "rockchip,rk3328-usb3phy-utmi";
+			reg = <0x0 0xff470000 0x0 0x8000>;
+			#phy-cells = <0>;
+			status = "okay";
+		};
+
+		usb3phy_pipe: pipe-port@ff478000 {
+			compatible = "rockchip,rk3328-usb3phy-pipe";
+			reg = <0x0 0xff478000 0x0 0x8000>;
+			#phy-cells = <0>;
+			status = "okay";
+		};
+	};
+
 	sdmmc: mmc@ff500000 {
 		compatible = "rockchip,rk3328-dw-mshc", "rockchip,rk3288-dw-mshc";
 		reg = <0x0 0xff500000 0x0 0x4000>;
@@ -1062,7 +1196,11 @@ usbdrd3: usb@ff600000 {
 			 <&cru ACLK_USB3OTG>;
 		clock-names = "ref_clk", "suspend_clk",
 			      "bus_clk";
+		resets = <&cru SRST_USB3OTG>;
+		reset-names = "usb3-otg";
 		dr_mode = "otg";
+		phys = <&usb3phy_utmi>, <&usb3phy_pipe>;
+		phy-names = "usb2-phy", "usb3-phy";
 		phy_type = "utmi_wide";
 		snps,dis-del-phy-power-chg-quirk;
 		snps,dis_enblslpm_quirk;
diff --git a/arch/arm64/boot/dts/rockchip/rk3328.dtsi.orig b/arch/arm64/boot/dts/rockchip/rk3328.dtsi.orig
new file mode 100644
index 000000000000..6438c969f9d7
--- /dev/null
+++ b/arch/arm64/boot/dts/rockchip/rk3328.dtsi.orig
@@ -0,0 +1,1997 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright (c) 2017 Fuzhou Rockchip Electronics Co., Ltd
+ */
+
+#include <dt-bindings/clock/rk3328-cru.h>
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/interrupt-controller/arm-gic.h>
+#include <dt-bindings/interrupt-controller/irq.h>
+#include <dt-bindings/pinctrl/rockchip.h>
+#include <dt-bindings/power/rk3328-power.h>
+#include <dt-bindings/soc/rockchip,boot-mode.h>
+#include <dt-bindings/thermal/thermal.h>
+
+/ {
+	compatible = "rockchip,rk3328";
+
+	interrupt-parent = <&gic>;
+	#address-cells = <2>;
+	#size-cells = <2>;
+
+	aliases {
+		gpio0 = &gpio0;
+		gpio1 = &gpio1;
+		gpio2 = &gpio2;
+		gpio3 = &gpio3;
+		serial0 = &uart0;
+		serial1 = &uart1;
+		serial2 = &uart2;
+		i2c0 = &i2c0;
+		i2c1 = &i2c1;
+		i2c2 = &i2c2;
+		i2c3 = &i2c3;
+	};
+
+	cpus {
+		#address-cells = <2>;
+		#size-cells = <0>;
+
+		cpu0: cpu@0 {
+			device_type = "cpu";
+			compatible = "arm,cortex-a53";
+			reg = <0x0 0x0>;
+			clocks = <&cru ARMCLK>;
+			#cooling-cells = <2>;
+			cpu-idle-states = <&CPU_SLEEP>;
+			dynamic-power-coefficient = <120>;
+			enable-method = "psci";
+			operating-points-v2 = <&cpu0_opp_table>;
+			i-cache-size = <0x8000>;
+			i-cache-line-size = <64>;
+			i-cache-sets = <256>;
+			d-cache-size = <0x8000>;
+			d-cache-line-size = <64>;
+			d-cache-sets = <128>;
+			next-level-cache = <&l2_cache>;
+		};
+
+		cpu1: cpu@1 {
+			device_type = "cpu";
+			compatible = "arm,cortex-a53";
+			reg = <0x0 0x1>;
+			clocks = <&cru ARMCLK>;
+			#cooling-cells = <2>;
+			cpu-idle-states = <&CPU_SLEEP>;
+			dynamic-power-coefficient = <120>;
+			enable-method = "psci";
+			operating-points-v2 = <&cpu0_opp_table>;
+			i-cache-size = <0x8000>;
+			i-cache-line-size = <64>;
+			i-cache-sets = <256>;
+			d-cache-size = <0x8000>;
+			d-cache-line-size = <64>;
+			d-cache-sets = <128>;
+			next-level-cache = <&l2_cache>;
+		};
+
+		cpu2: cpu@2 {
+			device_type = "cpu";
+			compatible = "arm,cortex-a53";
+			reg = <0x0 0x2>;
+			clocks = <&cru ARMCLK>;
+			#cooling-cells = <2>;
+			cpu-idle-states = <&CPU_SLEEP>;
+			dynamic-power-coefficient = <120>;
+			enable-method = "psci";
+			operating-points-v2 = <&cpu0_opp_table>;
+			i-cache-size = <0x8000>;
+			i-cache-line-size = <64>;
+			i-cache-sets = <256>;
+			d-cache-size = <0x8000>;
+			d-cache-line-size = <64>;
+			d-cache-sets = <128>;
+			next-level-cache = <&l2_cache>;
+		};
+
+		cpu3: cpu@3 {
+			device_type = "cpu";
+			compatible = "arm,cortex-a53";
+			reg = <0x0 0x3>;
+			clocks = <&cru ARMCLK>;
+			#cooling-cells = <2>;
+			cpu-idle-states = <&CPU_SLEEP>;
+			dynamic-power-coefficient = <120>;
+			enable-method = "psci";
+			operating-points-v2 = <&cpu0_opp_table>;
+			i-cache-size = <0x8000>;
+			i-cache-line-size = <64>;
+			i-cache-sets = <256>;
+			d-cache-size = <0x8000>;
+			d-cache-line-size = <64>;
+			d-cache-sets = <128>;
+			next-level-cache = <&l2_cache>;
+		};
+
+		idle-states {
+			entry-method = "psci";
+
+			CPU_SLEEP: cpu-sleep {
+				compatible = "arm,idle-state";
+				local-timer-stop;
+				arm,psci-suspend-param = <0x0010000>;
+				entry-latency-us = <120>;
+				exit-latency-us = <250>;
+				min-residency-us = <900>;
+			};
+		};
+
+		l2_cache: l2-cache {
+			compatible = "cache";
+			cache-level = <2>;
+			cache-unified;
+			cache-size = <0x40000>;
+			cache-line-size = <64>;
+			cache-sets = <256>;
+		};
+	};
+
+	cpu0_opp_table: opp-table-0 {
+		compatible = "operating-points-v2";
+		opp-shared;
+
+		opp-408000000 {
+			opp-hz = /bits/ 64 <408000000>;
+			opp-microvolt = <950000>;
+			clock-latency-ns = <40000>;
+			opp-suspend;
+		};
+		opp-600000000 {
+			opp-hz = /bits/ 64 <600000000>;
+			opp-microvolt = <950000>;
+			clock-latency-ns = <40000>;
+		};
+		opp-816000000 {
+			opp-hz = /bits/ 64 <816000000>;
+			opp-microvolt = <1000000>;
+			clock-latency-ns = <40000>;
+		};
+		opp-1008000000 {
+			opp-hz = /bits/ 64 <1008000000>;
+			opp-microvolt = <1100000>;
+			clock-latency-ns = <40000>;
+		};
+		opp-1200000000 {
+			opp-hz = /bits/ 64 <1200000000>;
+			opp-microvolt = <1225000>;
+			clock-latency-ns = <40000>;
+		};
+		opp-1296000000 {
+			opp-hz = /bits/ 64 <1296000000>;
+			opp-microvolt = <1300000>;
+			clock-latency-ns = <40000>;
+		};
+	};
+
+	analog_sound: analog-sound {
+		compatible = "simple-audio-card";
+		simple-audio-card,format = "i2s";
+		simple-audio-card,mclk-fs = <256>;
+		simple-audio-card,name = "Analog";
+		status = "disabled";
+
+		simple-audio-card,cpu {
+			sound-dai = <&i2s1>;
+		};
+
+		simple-audio-card,codec {
+			sound-dai = <&codec>;
+		};
+	};
+
+	arm-pmu {
+		compatible = "arm,cortex-a53-pmu";
+		interrupts = <GIC_SPI 100 IRQ_TYPE_LEVEL_HIGH>,
+			     <GIC_SPI 101 IRQ_TYPE_LEVEL_HIGH>,
+			     <GIC_SPI 102 IRQ_TYPE_LEVEL_HIGH>,
+			     <GIC_SPI 103 IRQ_TYPE_LEVEL_HIGH>;
+		interrupt-affinity = <&cpu0>, <&cpu1>, <&cpu2>, <&cpu3>;
+	};
+
+	display_subsystem: display-subsystem {
+		compatible = "rockchip,display-subsystem";
+		ports = <&vop_out>;
+	};
+
+	hdmi_sound: hdmi-sound {
+		compatible = "simple-audio-card";
+		simple-audio-card,format = "i2s";
+		simple-audio-card,mclk-fs = <128>;
+		simple-audio-card,name = "HDMI";
+		status = "disabled";
+
+		simple-audio-card,cpu {
+			sound-dai = <&i2s0>;
+		};
+
+		simple-audio-card,codec {
+			sound-dai = <&hdmi>;
+		};
+	};
+
+	psci {
+		compatible = "arm,psci-1.0", "arm,psci-0.2";
+		method = "smc";
+	};
+
+	timer {
+		compatible = "arm,armv8-timer";
+		interrupts = <GIC_PPI 13 (GIC_CPU_MASK_SIMPLE(4) | IRQ_TYPE_LEVEL_LOW)>,
+			     <GIC_PPI 14 (GIC_CPU_MASK_SIMPLE(4) | IRQ_TYPE_LEVEL_LOW)>,
+			     <GIC_PPI 11 (GIC_CPU_MASK_SIMPLE(4) | IRQ_TYPE_LEVEL_LOW)>,
+			     <GIC_PPI 10 (GIC_CPU_MASK_SIMPLE(4) | IRQ_TYPE_LEVEL_LOW)>;
+	};
+
+	xin24m: xin24m {
+		compatible = "fixed-clock";
+		#clock-cells = <0>;
+		clock-frequency = <24000000>;
+		clock-output-names = "xin24m";
+	};
+
+	i2s0: i2s@ff000000 {
+		compatible = "rockchip,rk3328-i2s", "rockchip,rk3066-i2s";
+		reg = <0x0 0xff000000 0x0 0x1000>;
+		interrupts = <GIC_SPI 26 IRQ_TYPE_LEVEL_HIGH>;
+		clocks = <&cru SCLK_I2S0>, <&cru HCLK_I2S0_8CH>;
+		clock-names = "i2s_clk", "i2s_hclk";
+		dmas = <&dmac 11>, <&dmac 12>;
+		dma-names = "tx", "rx";
+		#sound-dai-cells = <0>;
+		status = "disabled";
+	};
+
+	i2s1: i2s@ff010000 {
+		compatible = "rockchip,rk3328-i2s", "rockchip,rk3066-i2s";
+		reg = <0x0 0xff010000 0x0 0x1000>;
+		interrupts = <GIC_SPI 27 IRQ_TYPE_LEVEL_HIGH>;
+		clocks = <&cru SCLK_I2S1>, <&cru HCLK_I2S1_8CH>;
+		clock-names = "i2s_clk", "i2s_hclk";
+		dmas = <&dmac 14>, <&dmac 15>;
+		dma-names = "tx", "rx";
+		#sound-dai-cells = <0>;
+		status = "disabled";
+	};
+
+	i2s2: i2s@ff020000 {
+		compatible = "rockchip,rk3328-i2s", "rockchip,rk3066-i2s";
+		reg = <0x0 0xff020000 0x0 0x1000>;
+		interrupts = <GIC_SPI 28 IRQ_TYPE_LEVEL_HIGH>;
+		clocks = <&cru SCLK_I2S2>, <&cru HCLK_I2S2_2CH>;
+		clock-names = "i2s_clk", "i2s_hclk";
+		dmas = <&dmac 0>, <&dmac 1>;
+		dma-names = "tx", "rx";
+		#sound-dai-cells = <0>;
+		status = "disabled";
+	};
+
+	spdif: spdif@ff030000 {
+		compatible = "rockchip,rk3328-spdif";
+		reg = <0x0 0xff030000 0x0 0x1000>;
+		interrupts = <GIC_SPI 29 IRQ_TYPE_LEVEL_HIGH>;
+		clocks = <&cru SCLK_SPDIF>, <&cru HCLK_SPDIF_8CH>;
+		clock-names = "mclk", "hclk";
+		dmas = <&dmac 10>;
+		dma-names = "tx";
+		pinctrl-names = "default";
+		pinctrl-0 = <&spdifm2_tx>;
+		#sound-dai-cells = <0>;
+		status = "disabled";
+	};
+
+	pdm: pdm@ff040000 {
+		compatible = "rockchip,pdm";
+		reg = <0x0 0xff040000 0x0 0x1000>;
+		clocks = <&cru SCLK_PDM>, <&cru HCLK_PDM>;
+		clock-names = "pdm_clk", "pdm_hclk";
+		dmas = <&dmac 16>;
+		dma-names = "rx";
+		pinctrl-names = "default", "sleep";
+		pinctrl-0 = <&pdmm0_clk
+			     &pdmm0_sdi0
+			     &pdmm0_sdi1
+			     &pdmm0_sdi2
+			     &pdmm0_sdi3>;
+		pinctrl-1 = <&pdmm0_clk_sleep
+			     &pdmm0_sdi0_sleep
+			     &pdmm0_sdi1_sleep
+			     &pdmm0_sdi2_sleep
+			     &pdmm0_sdi3_sleep>;
+		status = "disabled";
+	};
+
+	grf: syscon@ff100000 {
+		compatible = "rockchip,rk3328-grf", "syscon", "simple-mfd";
+		reg = <0x0 0xff100000 0x0 0x1000>;
+
+		io_domains: io-domains {
+			compatible = "rockchip,rk3328-io-voltage-domain";
+			status = "disabled";
+		};
+
+		grf_gpio: gpio {
+			compatible = "rockchip,rk3328-grf-gpio";
+			gpio-controller;
+			#gpio-cells = <2>;
+		};
+
+		power: power-controller {
+			compatible = "rockchip,rk3328-power-controller";
+			#power-domain-cells = <1>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			power-domain@RK3328_PD_HEVC {
+				reg = <RK3328_PD_HEVC>;
+				clocks = <&cru SCLK_VENC_CORE>;
+				#power-domain-cells = <0>;
+			};
+			power-domain@RK3328_PD_VIDEO {
+				reg = <RK3328_PD_VIDEO>;
+				clocks = <&cru ACLK_RKVDEC>,
+					 <&cru HCLK_RKVDEC>,
+					 <&cru SCLK_VDEC_CABAC>,
+					 <&cru SCLK_VDEC_CORE>;
+				#power-domain-cells = <0>;
+			};
+			power-domain@RK3328_PD_VPU {
+				reg = <RK3328_PD_VPU>;
+				clocks = <&cru ACLK_VPU>, <&cru HCLK_VPU>;
+				#power-domain-cells = <0>;
+			};
+		};
+
+		reboot-mode {
+			compatible = "syscon-reboot-mode";
+			offset = <0x5c8>;
+			mode-normal = <BOOT_NORMAL>;
+			mode-recovery = <BOOT_RECOVERY>;
+			mode-bootloader = <BOOT_FASTBOOT>;
+			mode-loader = <BOOT_BL_DOWNLOAD>;
+		};
+	};
+
+	uart0: serial@ff110000 {
+		compatible = "rockchip,rk3328-uart", "snps,dw-apb-uart";
+		reg = <0x0 0xff110000 0x0 0x100>;
+		interrupts = <GIC_SPI 55 IRQ_TYPE_LEVEL_HIGH>;
+		clocks = <&cru SCLK_UART0>, <&cru PCLK_UART0>;
+		clock-names = "baudclk", "apb_pclk";
+		dmas = <&dmac 2>, <&dmac 3>;
+		dma-names = "tx", "rx";
+		pinctrl-names = "default";
+		pinctrl-0 = <&uart0_xfer &uart0_cts &uart0_rts>;
+		reg-io-width = <4>;
+		reg-shift = <2>;
+		status = "disabled";
+	};
+
+	uart1: serial@ff120000 {
+		compatible = "rockchip,rk3328-uart", "snps,dw-apb-uart";
+		reg = <0x0 0xff120000 0x0 0x100>;
+		interrupts = <GIC_SPI 56 IRQ_TYPE_LEVEL_HIGH>;
+		clocks = <&cru SCLK_UART1>, <&cru PCLK_UART1>;
+		clock-names = "baudclk", "apb_pclk";
+		dmas = <&dmac 4>, <&dmac 5>;
+		dma-names = "tx", "rx";
+		pinctrl-names = "default";
+		pinctrl-0 = <&uart1_xfer &uart1_cts &uart1_rts>;
+		reg-io-width = <4>;
+		reg-shift = <2>;
+		status = "disabled";
+	};
+
+	uart2: serial@ff130000 {
+		compatible = "rockchip,rk3328-uart", "snps,dw-apb-uart";
+		reg = <0x0 0xff130000 0x0 0x100>;
+		interrupts = <GIC_SPI 57 IRQ_TYPE_LEVEL_HIGH>;
+		clocks = <&cru SCLK_UART2>, <&cru PCLK_UART2>;
+		clock-names = "baudclk", "apb_pclk";
+		dmas = <&dmac 6>, <&dmac 7>;
+		dma-names = "tx", "rx";
+		pinctrl-names = "default";
+		pinctrl-0 = <&uart2m1_xfer>;
+		reg-io-width = <4>;
+		reg-shift = <2>;
+		status = "disabled";
+	};
+
+	i2c0: i2c@ff150000 {
+		compatible = "rockchip,rk3328-i2c", "rockchip,rk3399-i2c";
+		reg = <0x0 0xff150000 0x0 0x1000>;
+		interrupts = <GIC_SPI 36 IRQ_TYPE_LEVEL_HIGH>;
+		#address-cells = <1>;
+		#size-cells = <0>;
+		clocks = <&cru SCLK_I2C0>, <&cru PCLK_I2C0>;
+		clock-names = "i2c", "pclk";
+		pinctrl-names = "default";
+		pinctrl-0 = <&i2c0_xfer>;
+		status = "disabled";
+	};
+
+	i2c1: i2c@ff160000 {
+		compatible = "rockchip,rk3328-i2c", "rockchip,rk3399-i2c";
+		reg = <0x0 0xff160000 0x0 0x1000>;
+		interrupts = <GIC_SPI 37 IRQ_TYPE_LEVEL_HIGH>;
+		#address-cells = <1>;
+		#size-cells = <0>;
+		clocks = <&cru SCLK_I2C1>, <&cru PCLK_I2C1>;
+		clock-names = "i2c", "pclk";
+		pinctrl-names = "default";
+		pinctrl-0 = <&i2c1_xfer>;
+		status = "disabled";
+	};
+
+	i2c2: i2c@ff170000 {
+		compatible = "rockchip,rk3328-i2c", "rockchip,rk3399-i2c";
+		reg = <0x0 0xff170000 0x0 0x1000>;
+		interrupts = <GIC_SPI 38 IRQ_TYPE_LEVEL_HIGH>;
+		#address-cells = <1>;
+		#size-cells = <0>;
+		clocks = <&cru SCLK_I2C2>, <&cru PCLK_I2C2>;
+		clock-names = "i2c", "pclk";
+		pinctrl-names = "default";
+		pinctrl-0 = <&i2c2_xfer>;
+		status = "disabled";
+	};
+
+	i2c3: i2c@ff180000 {
+		compatible = "rockchip,rk3328-i2c", "rockchip,rk3399-i2c";
+		reg = <0x0 0xff180000 0x0 0x1000>;
+		interrupts = <GIC_SPI 39 IRQ_TYPE_LEVEL_HIGH>;
+		#address-cells = <1>;
+		#size-cells = <0>;
+		clocks = <&cru SCLK_I2C3>, <&cru PCLK_I2C3>;
+		clock-names = "i2c", "pclk";
+		pinctrl-names = "default";
+		pinctrl-0 = <&i2c3_xfer>;
+		status = "disabled";
+	};
+
+	spi0: spi@ff190000 {
+		compatible = "rockchip,rk3328-spi", "rockchip,rk3066-spi";
+		reg = <0x0 0xff190000 0x0 0x1000>;
+		interrupts = <GIC_SPI 49 IRQ_TYPE_LEVEL_HIGH>;
+		#address-cells = <1>;
+		#size-cells = <0>;
+		clocks = <&cru SCLK_SPI>, <&cru PCLK_SPI>;
+		clock-names = "spiclk", "apb_pclk";
+		dmas = <&dmac 8>, <&dmac 9>;
+		dma-names = "tx", "rx";
+		pinctrl-names = "default";
+		pinctrl-0 = <&spi0m2_clk &spi0m2_tx &spi0m2_rx &spi0m2_cs0>;
+		status = "disabled";
+	};
+
+	wdt: watchdog@ff1a0000 {
+		compatible = "rockchip,rk3328-wdt", "snps,dw-wdt";
+		reg = <0x0 0xff1a0000 0x0 0x100>;
+		interrupts = <GIC_SPI 40 IRQ_TYPE_LEVEL_HIGH>;
+		clocks = <&cru PCLK_WDT>;
+	};
+
+	pwm0: pwm@ff1b0000 {
+		compatible = "rockchip,rk3328-pwm";
+		reg = <0x0 0xff1b0000 0x0 0x10>;
+		clocks = <&cru SCLK_PWM>, <&cru PCLK_PWM>;
+		clock-names = "pwm", "pclk";
+		pinctrl-names = "default";
+		pinctrl-0 = <&pwm0_pin>;
+		#pwm-cells = <3>;
+		status = "disabled";
+	};
+
+	pwm1: pwm@ff1b0010 {
+		compatible = "rockchip,rk3328-pwm";
+		reg = <0x0 0xff1b0010 0x0 0x10>;
+		clocks = <&cru SCLK_PWM>, <&cru PCLK_PWM>;
+		clock-names = "pwm", "pclk";
+		pinctrl-names = "default";
+		pinctrl-0 = <&pwm1_pin>;
+		#pwm-cells = <3>;
+		status = "disabled";
+	};
+
+	pwm2: pwm@ff1b0020 {
+		compatible = "rockchip,rk3328-pwm";
+		reg = <0x0 0xff1b0020 0x0 0x10>;
+		clocks = <&cru SCLK_PWM>, <&cru PCLK_PWM>;
+		clock-names = "pwm", "pclk";
+		pinctrl-names = "default";
+		pinctrl-0 = <&pwm2_pin>;
+		#pwm-cells = <3>;
+		status = "disabled";
+	};
+
+	pwm3: pwm@ff1b0030 {
+		compatible = "rockchip,rk3328-pwm";
+		reg = <0x0 0xff1b0030 0x0 0x10>;
+		clocks = <&cru SCLK_PWM>, <&cru PCLK_PWM>;
+		clock-names = "pwm", "pclk";
+		pinctrl-names = "default";
+		pinctrl-0 = <&pwmir_pin>;
+		#pwm-cells = <3>;
+		status = "disabled";
+	};
+
+	dmac: dma-controller@ff1f0000 {
+		compatible = "arm,pl330", "arm,primecell";
+		reg = <0x0 0xff1f0000 0x0 0x4000>;
+		interrupts = <GIC_SPI 0 IRQ_TYPE_LEVEL_HIGH>,
+			     <GIC_SPI 1 IRQ_TYPE_LEVEL_HIGH>;
+		arm,pl330-periph-burst;
+		clocks = <&cru ACLK_DMAC>;
+		clock-names = "apb_pclk";
+		#dma-cells = <1>;
+	};
+
+	thermal-zones {
+		soc_thermal: soc-thermal {
+			polling-delay-passive = <20>;
+			polling-delay = <1000>;
+			sustainable-power = <1000>;
+
+			thermal-sensors = <&tsadc 0>;
+
+			trips {
+				threshold: trip-point0 {
+					temperature = <70000>;
+					hysteresis = <2000>;
+					type = "passive";
+				};
+				target: trip-point1 {
+					temperature = <85000>;
+					hysteresis = <2000>;
+					type = "passive";
+				};
+				soc_crit: soc-crit {
+					temperature = <95000>;
+					hysteresis = <2000>;
+					type = "critical";
+				};
+			};
+
+			cooling-maps {
+				map0 {
+					trip = <&target>;
+					cooling-device = <&cpu0 THERMAL_NO_LIMIT THERMAL_NO_LIMIT>,
+							 <&cpu1 THERMAL_NO_LIMIT THERMAL_NO_LIMIT>,
+							 <&cpu2 THERMAL_NO_LIMIT THERMAL_NO_LIMIT>,
+							 <&cpu3 THERMAL_NO_LIMIT THERMAL_NO_LIMIT>;
+					contribution = <4096>;
+				};
+			};
+		};
+
+	};
+
+	tsadc: tsadc@ff250000 {
+		compatible = "rockchip,rk3328-tsadc";
+		reg = <0x0 0xff250000 0x0 0x100>;
+		interrupts = <GIC_SPI 58 IRQ_TYPE_LEVEL_HIGH>;
+		assigned-clocks = <&cru SCLK_TSADC>;
+		assigned-clock-rates = <50000>;
+		clocks = <&cru SCLK_TSADC>, <&cru PCLK_TSADC>;
+		clock-names = "tsadc", "apb_pclk";
+		pinctrl-names = "init", "default", "sleep";
+		pinctrl-0 = <&otp_pin>;
+		pinctrl-1 = <&otp_out>;
+		pinctrl-2 = <&otp_pin>;
+		resets = <&cru SRST_TSADC>;
+		reset-names = "tsadc-apb";
+		rockchip,grf = <&grf>;
+		rockchip,hw-tshut-temp = <100000>;
+		#thermal-sensor-cells = <1>;
+		status = "disabled";
+	};
+
+	efuse: efuse@ff260000 {
+		compatible = "rockchip,rk3328-efuse";
+		reg = <0x0 0xff260000 0x0 0x50>;
+		#address-cells = <1>;
+		#size-cells = <1>;
+		clocks = <&cru SCLK_EFUSE>;
+		clock-names = "pclk_efuse";
+		rockchip,efuse-size = <0x20>;
+
+		/* Data cells */
+		efuse_id: id@7 {
+			reg = <0x07 0x10>;
+		};
+		cpu_leakage: cpu-leakage@17 {
+			reg = <0x17 0x1>;
+		};
+		logic_leakage: logic-leakage@19 {
+			reg = <0x19 0x1>;
+		};
+		efuse_cpu_version: cpu-version@1a {
+			reg = <0x1a 0x1>;
+			bits = <3 3>;
+		};
+	};
+
+	saradc: adc@ff280000 {
+		compatible = "rockchip,rk3328-saradc", "rockchip,rk3399-saradc";
+		reg = <0x0 0xff280000 0x0 0x100>;
+		interrupts = <GIC_SPI 80 IRQ_TYPE_LEVEL_HIGH>;
+		#io-channel-cells = <1>;
+		clocks = <&cru SCLK_SARADC>, <&cru PCLK_SARADC>;
+		clock-names = "saradc", "apb_pclk";
+		resets = <&cru SRST_SARADC_P>;
+		reset-names = "saradc-apb";
+		status = "disabled";
+	};
+
+	gpu: gpu@ff300000 {
+		compatible = "rockchip,rk3328-mali", "arm,mali-450";
+		reg = <0x0 0xff300000 0x0 0x30000>;
+		interrupts = <GIC_SPI 90 IRQ_TYPE_LEVEL_HIGH>,
+			     <GIC_SPI 87 IRQ_TYPE_LEVEL_HIGH>,
+			     <GIC_SPI 93 IRQ_TYPE_LEVEL_HIGH>,
+			     <GIC_SPI 88 IRQ_TYPE_LEVEL_HIGH>,
+			     <GIC_SPI 89 IRQ_TYPE_LEVEL_HIGH>,
+			     <GIC_SPI 91 IRQ_TYPE_LEVEL_HIGH>,
+			     <GIC_SPI 92 IRQ_TYPE_LEVEL_HIGH>;
+		interrupt-names = "gp",
+				  "gpmmu",
+				  "pp",
+				  "pp0",
+				  "ppmmu0",
+				  "pp1",
+				  "ppmmu1";
+		clocks = <&cru ACLK_GPU>, <&cru ACLK_GPU>;
+		clock-names = "bus", "core";
+		resets = <&cru SRST_GPU_A>;
+	};
+
+	h265e_mmu: iommu@ff330200 {
+		compatible = "rockchip,iommu";
+		reg = <0x0 0xff330200 0 0x100>;
+		interrupts = <GIC_SPI 96 IRQ_TYPE_LEVEL_HIGH>;
+		clocks = <&cru ACLK_H265>, <&cru PCLK_H265>;
+		clock-names = "aclk", "iface";
+		#iommu-cells = <0>;
+		status = "disabled";
+	};
+
+	vepu_mmu: iommu@ff340800 {
+		compatible = "rockchip,iommu";
+		reg = <0x0 0xff340800 0x0 0x40>;
+		interrupts = <GIC_SPI 98 IRQ_TYPE_LEVEL_HIGH>;
+		clocks = <&cru ACLK_VPU>, <&cru HCLK_VPU>;
+		clock-names = "aclk", "iface";
+		#iommu-cells = <0>;
+		status = "disabled";
+	};
+
+	vpu: video-codec@ff350000 {
+		compatible = "rockchip,rk3328-vpu";
+		reg = <0x0 0xff350000 0x0 0x800>;
+		interrupts = <GIC_SPI 9 IRQ_TYPE_LEVEL_HIGH>;
+		interrupt-names = "vdpu";
+		clocks = <&cru ACLK_VPU>, <&cru HCLK_VPU>;
+		clock-names = "aclk", "hclk";
+		iommus = <&vpu_mmu>;
+		power-domains = <&power RK3328_PD_VPU>;
+	};
+
+	vpu_mmu: iommu@ff350800 {
+		compatible = "rockchip,iommu";
+		reg = <0x0 0xff350800 0x0 0x40>;
+		interrupts = <GIC_SPI 11 IRQ_TYPE_LEVEL_HIGH>;
+		clocks = <&cru ACLK_VPU>, <&cru HCLK_VPU>;
+		clock-names = "aclk", "iface";
+		#iommu-cells = <0>;
+		power-domains = <&power RK3328_PD_VPU>;
+	};
+
+	vdec: video-codec@ff360000 {
+		compatible = "rockchip,rk3328-vdec", "rockchip,rk3399-vdec";
+		reg = <0x0 0xff360000 0x0 0x480>;
+		interrupts = <GIC_SPI 7 IRQ_TYPE_LEVEL_HIGH>;
+		clocks = <&cru ACLK_RKVDEC>, <&cru HCLK_RKVDEC>,
+			 <&cru SCLK_VDEC_CABAC>, <&cru SCLK_VDEC_CORE>;
+		clock-names = "axi", "ahb", "cabac", "core";
+		assigned-clocks = <&cru ACLK_RKVDEC>, <&cru SCLK_VDEC_CABAC>,
+				  <&cru SCLK_VDEC_CORE>;
+		assigned-clock-rates = <400000000>, <400000000>, <300000000>;
+		iommus = <&vdec_mmu>;
+		power-domains = <&power RK3328_PD_VIDEO>;
+	};
+
+	vdec_mmu: iommu@ff360480 {
+		compatible = "rockchip,iommu";
+		reg = <0x0 0xff360480 0x0 0x40>, <0x0 0xff3604c0 0x0 0x40>;
+		interrupts = <GIC_SPI 74 IRQ_TYPE_LEVEL_HIGH>;
+		clocks = <&cru ACLK_RKVDEC>, <&cru HCLK_RKVDEC>;
+		clock-names = "aclk", "iface";
+		#iommu-cells = <0>;
+		power-domains = <&power RK3328_PD_VIDEO>;
+	};
+
+	vop: vop@ff370000 {
+		compatible = "rockchip,rk3328-vop";
+		reg = <0x0 0xff370000 0x0 0x3efc>;
+		interrupts = <GIC_SPI 32 IRQ_TYPE_LEVEL_HIGH>;
+		clocks = <&cru ACLK_VOP>, <&cru DCLK_LCDC>, <&cru HCLK_VOP>;
+		clock-names = "aclk_vop", "dclk_vop", "hclk_vop";
+		resets = <&cru SRST_VOP_A>, <&cru SRST_VOP_H>, <&cru SRST_VOP_D>;
+		reset-names = "axi", "ahb", "dclk";
+		iommus = <&vop_mmu>;
+		status = "disabled";
+
+		vop_out: port {
+			vop_out_hdmi: endpoint {
+				remote-endpoint = <&hdmi_in_vop>;
+			};
+		};
+	};
+
+	vop_mmu: iommu@ff373f00 {
+		compatible = "rockchip,iommu";
+		reg = <0x0 0xff373f00 0x0 0x100>;
+		interrupts = <GIC_SPI 32 IRQ_TYPE_LEVEL_HIGH>;
+		clocks = <&cru ACLK_VOP>, <&cru HCLK_VOP>;
+		clock-names = "aclk", "iface";
+		#iommu-cells = <0>;
+		status = "disabled";
+	};
+
+	hdmi: hdmi@ff3c0000 {
+		compatible = "rockchip,rk3328-dw-hdmi";
+		reg = <0x0 0xff3c0000 0x0 0x20000>;
+		reg-io-width = <4>;
+		interrupts = <GIC_SPI 35 IRQ_TYPE_LEVEL_HIGH>;
+		clocks = <&cru PCLK_HDMI>,
+			 <&cru SCLK_HDMI_SFC>,
+			 <&cru SCLK_RTC32K>;
+		clock-names = "iahb",
+			      "isfr",
+			      "cec";
+		phys = <&hdmiphy>;
+		phy-names = "hdmi";
+		pinctrl-names = "default";
+		pinctrl-0 = <&hdmi_cec &hdmii2c_xfer &hdmi_hpd>;
+		rockchip,grf = <&grf>;
+		#sound-dai-cells = <0>;
+		status = "disabled";
+
+		ports {
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			hdmi_in: port@0 {
+				reg = <0>;
+
+				hdmi_in_vop: endpoint {
+					remote-endpoint = <&vop_out_hdmi>;
+				};
+			};
+
+			hdmi_out: port@1 {
+				reg = <1>;
+			};
+		};
+	};
+
+	codec: codec@ff410000 {
+		compatible = "rockchip,rk3328-codec";
+		reg = <0x0 0xff410000 0x0 0x1000>;
+		clocks = <&cru PCLK_ACODECPHY>, <&cru SCLK_I2S1>;
+		clock-names = "pclk", "mclk";
+		rockchip,grf = <&grf>;
+		#sound-dai-cells = <0>;
+		status = "disabled";
+	};
+
+	hdmiphy: phy@ff430000 {
+		compatible = "rockchip,rk3328-hdmi-phy";
+		reg = <0x0 0xff430000 0x0 0x10000>;
+		interrupts = <GIC_SPI 83 IRQ_TYPE_LEVEL_HIGH>;
+		clocks = <&cru PCLK_HDMIPHY>, <&xin24m>, <&cru DCLK_HDMIPHY>;
+		clock-names = "sysclk", "refoclk", "refpclk";
+		clock-output-names = "hdmi_phy";
+		#clock-cells = <0>;
+		nvmem-cells = <&efuse_cpu_version>;
+		nvmem-cell-names = "cpu-version";
+		#phy-cells = <0>;
+		status = "disabled";
+	};
+
+	cru: clock-controller@ff440000 {
+		compatible = "rockchip,rk3328-cru";
+		reg = <0x0 0xff440000 0x0 0x1000>;
+		clocks = <&xin24m>;
+		clock-names = "xin24m";
+		rockchip,grf = <&grf>;
+		#clock-cells = <1>;
+		#reset-cells = <1>;
+		assigned-clocks =
+			/*
+			 * CPLL should run at 1200, but that is to high for
+			 * the initial dividers of most of its children.
+			 * We need set cpll child clk div first,
+			 * and then set the cpll frequency.
+			 */
+			<&cru DCLK_LCDC>, <&cru SCLK_PDM>,
+			<&cru SCLK_RTC32K>, <&cru SCLK_UART0>,
+			<&cru SCLK_UART1>, <&cru SCLK_UART2>,
+			<&cru ACLK_BUS_PRE>, <&cru ACLK_PERI_PRE>,
+			<&cru ACLK_VIO_PRE>, <&cru ACLK_RGA_PRE>,
+			<&cru ACLK_VOP_PRE>, <&cru ACLK_RKVDEC_PRE>,
+			<&cru ACLK_RKVENC>, <&cru ACLK_VPU_PRE>,
+			<&cru SCLK_VDEC_CABAC>, <&cru SCLK_VDEC_CORE>,
+			<&cru SCLK_VENC_CORE>, <&cru SCLK_VENC_DSP>,
+			<&cru SCLK_SDIO>, <&cru SCLK_TSP>,
+			<&cru SCLK_WIFI>, <&cru ARMCLK>,
+			<&cru PLL_GPLL>, <&cru PLL_CPLL>,
+			<&cru ACLK_BUS_PRE>, <&cru HCLK_BUS_PRE>,
+			<&cru PCLK_BUS_PRE>, <&cru ACLK_PERI_PRE>,
+			<&cru HCLK_PERI>, <&cru PCLK_PERI>,
+			<&cru SCLK_RTC32K>;
+		assigned-clock-parents =
+			<&cru HDMIPHY>, <&cru PLL_APLL>,
+			<&cru PLL_GPLL>, <&xin24m>,
+			<&xin24m>, <&xin24m>;
+		assigned-clock-rates =
+			<0>, <61440000>,
+			<0>, <24000000>,
+			<24000000>, <24000000>,
+			<15000000>, <15000000>,
+			<300000000>, <100000000>,
+			<400000000>, <100000000>,
+			<50000000>, <100000000>,
+			<100000000>, <100000000>,
+			<50000000>, <50000000>,
+			<50000000>, <50000000>,
+			<24000000>, <600000000>,
+			<491520000>, <1200000000>,
+			<150000000>, <75000000>,
+			<75000000>, <150000000>,
+			<75000000>, <75000000>,
+			<32768>;
+	};
+
+	usb2phy_grf: syscon@ff450000 {
+		compatible = "rockchip,rk3328-usb2phy-grf", "syscon",
+			     "simple-mfd";
+		reg = <0x0 0xff450000 0x0 0x10000>;
+		#address-cells = <1>;
+		#size-cells = <1>;
+
+		u2phy: usb2phy@100 {
+			compatible = "rockchip,rk3328-usb2phy";
+			reg = <0x100 0x10>;
+			clocks = <&xin24m>;
+			clock-names = "phyclk";
+			clock-output-names = "usb480m_phy";
+			#clock-cells = <0>;
+			assigned-clocks = <&cru USB480M>;
+			assigned-clock-parents = <&u2phy>;
+			status = "disabled";
+
+			u2phy_otg: otg-port {
+				#phy-cells = <0>;
+				interrupts = <GIC_SPI 59 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 60 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 61 IRQ_TYPE_LEVEL_HIGH>;
+				interrupt-names = "otg-bvalid", "otg-id",
+						  "linestate";
+				status = "disabled";
+			};
+
+			u2phy_host: host-port {
+				#phy-cells = <0>;
+				interrupts = <GIC_SPI 62 IRQ_TYPE_LEVEL_HIGH>;
+				interrupt-names = "linestate";
+				status = "disabled";
+			};
+		};
+	};
+
+	sdmmc: mmc@ff500000 {
+		compatible = "rockchip,rk3328-dw-mshc", "rockchip,rk3288-dw-mshc";
+		reg = <0x0 0xff500000 0x0 0x4000>;
+		interrupts = <GIC_SPI 12 IRQ_TYPE_LEVEL_HIGH>;
+		clocks = <&cru HCLK_SDMMC>, <&cru SCLK_SDMMC>,
+			 <&cru SCLK_SDMMC_DRV>, <&cru SCLK_SDMMC_SAMPLE>;
+		clock-names = "biu", "ciu", "ciu-drive", "ciu-sample";
+		fifo-depth = <0x100>;
+		max-frequency = <150000000>;
+		resets = <&cru SRST_MMC0>;
+		reset-names = "reset";
+		status = "disabled";
+	};
+
+	sdio: mmc@ff510000 {
+		compatible = "rockchip,rk3328-dw-mshc", "rockchip,rk3288-dw-mshc";
+		reg = <0x0 0xff510000 0x0 0x4000>;
+		interrupts = <GIC_SPI 13 IRQ_TYPE_LEVEL_HIGH>;
+		clocks = <&cru HCLK_SDIO>, <&cru SCLK_SDIO>,
+			 <&cru SCLK_SDIO_DRV>, <&cru SCLK_SDIO_SAMPLE>;
+		clock-names = "biu", "ciu", "ciu-drive", "ciu-sample";
+		fifo-depth = <0x100>;
+		max-frequency = <150000000>;
+		resets = <&cru SRST_SDIO>;
+		reset-names = "reset";
+		status = "disabled";
+	};
+
+	emmc: mmc@ff520000 {
+		compatible = "rockchip,rk3328-dw-mshc", "rockchip,rk3288-dw-mshc";
+		reg = <0x0 0xff520000 0x0 0x4000>;
+		interrupts = <GIC_SPI 14 IRQ_TYPE_LEVEL_HIGH>;
+		clocks = <&cru HCLK_EMMC>, <&cru SCLK_EMMC>,
+			 <&cru SCLK_EMMC_DRV>, <&cru SCLK_EMMC_SAMPLE>;
+		clock-names = "biu", "ciu", "ciu-drive", "ciu-sample";
+		fifo-depth = <0x100>;
+		max-frequency = <150000000>;
+		resets = <&cru SRST_EMMC>;
+		reset-names = "reset";
+		status = "disabled";
+	};
+
+	gmac2io: ethernet@ff540000 {
+		compatible = "rockchip,rk3328-gmac";
+		reg = <0x0 0xff540000 0x0 0x10000>;
+		interrupts = <GIC_SPI 24 IRQ_TYPE_LEVEL_HIGH>;
+		interrupt-names = "macirq";
+		clocks = <&cru SCLK_MAC2IO>, <&cru SCLK_MAC2IO_RX>,
+			 <&cru SCLK_MAC2IO_TX>, <&cru SCLK_MAC2IO_REF>,
+			 <&cru SCLK_MAC2IO_REFOUT>, <&cru ACLK_MAC2IO>,
+			 <&cru PCLK_MAC2IO>;
+		clock-names = "stmmaceth", "mac_clk_rx",
+			      "mac_clk_tx", "clk_mac_ref",
+			      "clk_mac_refout", "aclk_mac",
+			      "pclk_mac";
+		resets = <&cru SRST_GMAC2IO_A>;
+		reset-names = "stmmaceth";
+		rockchip,grf = <&grf>;
+		tx-fifo-depth = <2048>;
+		rx-fifo-depth = <4096>;
+		snps,txpbl = <0x4>;
+		status = "disabled";
+	};
+
+	gmac2phy: ethernet@ff550000 {
+		compatible = "rockchip,rk3328-gmac";
+		reg = <0x0 0xff550000 0x0 0x10000>;
+		rockchip,grf = <&grf>;
+		interrupts = <GIC_SPI 21 IRQ_TYPE_LEVEL_HIGH>;
+		interrupt-names = "macirq";
+		clocks = <&cru SCLK_MAC2PHY_SRC>, <&cru SCLK_MAC2PHY_RXTX>,
+			 <&cru SCLK_MAC2PHY_RXTX>, <&cru SCLK_MAC2PHY_REF>,
+			 <&cru ACLK_MAC2PHY>, <&cru PCLK_MAC2PHY>,
+			 <&cru SCLK_MAC2PHY_OUT>;
+		clock-names = "stmmaceth", "mac_clk_rx",
+			      "mac_clk_tx", "clk_mac_ref",
+			      "aclk_mac", "pclk_mac",
+			      "clk_macphy";
+		resets = <&cru SRST_GMAC2PHY_A>;
+		reset-names = "stmmaceth";
+		phy-mode = "rmii";
+		phy-handle = <&phy>;
+		tx-fifo-depth = <2048>;
+		rx-fifo-depth = <4096>;
+		snps,txpbl = <0x4>;
+		clock_in_out = "output";
+		status = "disabled";
+
+		mdio {
+			compatible = "snps,dwmac-mdio";
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			phy: ethernet-phy@0 {
+				compatible = "ethernet-phy-id1234.d400", "ethernet-phy-ieee802.3-c22";
+				reg = <0>;
+				clocks = <&cru SCLK_MAC2PHY_OUT>;
+				resets = <&cru SRST_MACPHY>;
+				pinctrl-names = "default";
+				pinctrl-0 = <&fephyled_rxm1 &fephyled_linkm1>;
+				phy-is-integrated;
+			};
+		};
+	};
+
+	usb20_otg: usb@ff580000 {
+		compatible = "rockchip,rk3328-usb", "rockchip,rk3066-usb",
+			     "snps,dwc2";
+		reg = <0x0 0xff580000 0x0 0x40000>;
+		interrupts = <GIC_SPI 23 IRQ_TYPE_LEVEL_HIGH>;
+		clocks = <&cru HCLK_OTG>;
+		clock-names = "otg";
+		dr_mode = "otg";
+		g-np-tx-fifo-size = <16>;
+		g-rx-fifo-size = <280>;
+		g-tx-fifo-size = <256 128 128 64 32 16>;
+		phys = <&u2phy_otg>;
+		phy-names = "usb2-phy";
+		status = "disabled";
+	};
+
+	usb_host0_ehci: usb@ff5c0000 {
+		compatible = "generic-ehci";
+		reg = <0x0 0xff5c0000 0x0 0x10000>;
+		interrupts = <GIC_SPI 16 IRQ_TYPE_LEVEL_HIGH>;
+		clocks = <&cru HCLK_HOST0>, <&u2phy>;
+		phys = <&u2phy_host>;
+		phy-names = "usb";
+		status = "disabled";
+	};
+
+	usb_host0_ohci: usb@ff5d0000 {
+		compatible = "generic-ohci";
+		reg = <0x0 0xff5d0000 0x0 0x10000>;
+		interrupts = <GIC_SPI 17 IRQ_TYPE_LEVEL_HIGH>;
+		clocks = <&cru HCLK_HOST0>, <&u2phy>;
+		phys = <&u2phy_host>;
+		phy-names = "usb";
+		status = "disabled";
+	};
+
+	sdmmc_ext: mmc@ff5f0000 {
+		compatible = "rockchip,rk3328-dw-mshc", "rockchip,rk3288-dw-mshc";
+		reg = <0x0 0xff5f0000 0x0 0x4000>;
+		interrupts = <GIC_SPI 4 IRQ_TYPE_LEVEL_HIGH>;
+		clocks = <&cru HCLK_SDMMC_EXT>, <&cru SCLK_SDMMC_EXT>,
+			 <&cru SCLK_SDMMC_EXT_DRV>, <&cru SCLK_SDMMC_EXT_SAMPLE>;
+		clock-names = "biu", "ciu", "ciu-drive", "ciu-sample";
+		fifo-depth = <0x100>;
+		max-frequency = <150000000>;
+		resets = <&cru SRST_SDMMCEXT>;
+		reset-names = "reset";
+		status = "disabled";
+	};
+
+	usbdrd3: usb@ff600000 {
+		compatible = "rockchip,rk3328-dwc3", "snps,dwc3";
+		reg = <0x0 0xff600000 0x0 0x100000>;
+		interrupts = <GIC_SPI 67 IRQ_TYPE_LEVEL_HIGH>;
+		clocks = <&cru SCLK_USB3OTG_REF>, <&cru SCLK_USB3OTG_SUSPEND>,
+			 <&cru ACLK_USB3OTG>;
+		clock-names = "ref_clk", "suspend_clk",
+			      "bus_clk";
+		dr_mode = "otg";
+		phy_type = "utmi_wide";
+		snps,dis-del-phy-power-chg-quirk;
+		snps,dis_enblslpm_quirk;
+		snps,dis-tx-ipgap-linecheck-quirk;
+		snps,dis-u2-freeclk-exists-quirk;
+		snps,dis_u2_susphy_quirk;
+		snps,dis_u3_susphy_quirk;
+		status = "disabled";
+	};
+
+	gic: interrupt-controller@ff811000 {
+		compatible = "arm,gic-400";
+		#interrupt-cells = <3>;
+		#address-cells = <0>;
+		interrupt-controller;
+		reg = <0x0 0xff811000 0 0x1000>,
+		      <0x0 0xff812000 0 0x2000>,
+		      <0x0 0xff814000 0 0x2000>,
+		      <0x0 0xff816000 0 0x2000>;
+		interrupts = <GIC_PPI 9
+		      (GIC_CPU_MASK_SIMPLE(4) | IRQ_TYPE_LEVEL_HIGH)>;
+	};
+
+	crypto: crypto@ff060000 {
+		compatible = "rockchip,rk3328-crypto";
+		reg = <0x0 0xff060000 0x0 0x4000>;
+		interrupts = <GIC_SPI 30 IRQ_TYPE_LEVEL_HIGH>;
+		clocks = <&cru HCLK_CRYPTO_MST>, <&cru HCLK_CRYPTO_SLV>,
+			 <&cru SCLK_CRYPTO>;
+		clock-names = "hclk_master", "hclk_slave", "sclk";
+		resets = <&cru SRST_CRYPTO>;
+		reset-names = "crypto-rst";
+	};
+
+	pinctrl: pinctrl {
+		compatible = "rockchip,rk3328-pinctrl";
+		rockchip,grf = <&grf>;
+		#address-cells = <2>;
+		#size-cells = <2>;
+		ranges;
+
+		gpio0: gpio@ff210000 {
+			compatible = "rockchip,gpio-bank";
+			reg = <0x0 0xff210000 0x0 0x100>;
+			interrupts = <GIC_SPI 51 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&cru PCLK_GPIO0>;
+
+			gpio-controller;
+			#gpio-cells = <2>;
+
+			interrupt-controller;
+			#interrupt-cells = <2>;
+		};
+
+		gpio1: gpio@ff220000 {
+			compatible = "rockchip,gpio-bank";
+			reg = <0x0 0xff220000 0x0 0x100>;
+			interrupts = <GIC_SPI 52 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&cru PCLK_GPIO1>;
+
+			gpio-controller;
+			#gpio-cells = <2>;
+
+			interrupt-controller;
+			#interrupt-cells = <2>;
+		};
+
+		gpio2: gpio@ff230000 {
+			compatible = "rockchip,gpio-bank";
+			reg = <0x0 0xff230000 0x0 0x100>;
+			interrupts = <GIC_SPI 53 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&cru PCLK_GPIO2>;
+
+			gpio-controller;
+			#gpio-cells = <2>;
+
+			interrupt-controller;
+			#interrupt-cells = <2>;
+		};
+
+		gpio3: gpio@ff240000 {
+			compatible = "rockchip,gpio-bank";
+			reg = <0x0 0xff240000 0x0 0x100>;
+			interrupts = <GIC_SPI 54 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&cru PCLK_GPIO3>;
+
+			gpio-controller;
+			#gpio-cells = <2>;
+
+			interrupt-controller;
+			#interrupt-cells = <2>;
+		};
+
+		pcfg_pull_up: pcfg-pull-up {
+			bias-pull-up;
+		};
+
+		pcfg_pull_down: pcfg-pull-down {
+			bias-pull-down;
+		};
+
+		pcfg_pull_none: pcfg-pull-none {
+			bias-disable;
+		};
+
+		pcfg_pull_none_2ma: pcfg-pull-none-2ma {
+			bias-disable;
+			drive-strength = <2>;
+		};
+
+		pcfg_pull_up_2ma: pcfg-pull-up-2ma {
+			bias-pull-up;
+			drive-strength = <2>;
+		};
+
+		pcfg_pull_up_4ma: pcfg-pull-up-4ma {
+			bias-pull-up;
+			drive-strength = <4>;
+		};
+
+		pcfg_pull_none_4ma: pcfg-pull-none-4ma {
+			bias-disable;
+			drive-strength = <4>;
+		};
+
+		pcfg_pull_down_4ma: pcfg-pull-down-4ma {
+			bias-pull-down;
+			drive-strength = <4>;
+		};
+
+		pcfg_pull_none_8ma: pcfg-pull-none-8ma {
+			bias-disable;
+			drive-strength = <8>;
+		};
+
+		pcfg_pull_up_8ma: pcfg-pull-up-8ma {
+			bias-pull-up;
+			drive-strength = <8>;
+		};
+
+		pcfg_pull_none_12ma: pcfg-pull-none-12ma {
+			bias-disable;
+			drive-strength = <12>;
+		};
+
+		pcfg_pull_up_12ma: pcfg-pull-up-12ma {
+			bias-pull-up;
+			drive-strength = <12>;
+		};
+
+		pcfg_output_high: pcfg-output-high {
+			output-high;
+		};
+
+		pcfg_output_low: pcfg-output-low {
+			output-low;
+		};
+
+		pcfg_input_high: pcfg-input-high {
+			bias-pull-up;
+			input-enable;
+		};
+
+		pcfg_input: pcfg-input {
+			input-enable;
+		};
+
+		i2c0 {
+			i2c0_xfer: i2c0-xfer {
+				rockchip,pins = <2 RK_PD0 1 &pcfg_pull_none>,
+						<2 RK_PD1 1 &pcfg_pull_none>;
+			};
+		};
+
+		i2c1 {
+			i2c1_xfer: i2c1-xfer {
+				rockchip,pins = <2 RK_PA4 2 &pcfg_pull_none>,
+						<2 RK_PA5 2 &pcfg_pull_none>;
+			};
+		};
+
+		i2c2 {
+			i2c2_xfer: i2c2-xfer {
+				rockchip,pins = <2 RK_PB5 1 &pcfg_pull_none>,
+						<2 RK_PB6 1 &pcfg_pull_none>;
+			};
+		};
+
+		i2c3 {
+			i2c3_xfer: i2c3-xfer {
+				rockchip,pins = <0 RK_PA5 2 &pcfg_pull_none>,
+						<0 RK_PA6 2 &pcfg_pull_none>;
+			};
+			i2c3_pins: i2c3-pins {
+				rockchip,pins =
+					<0 RK_PA5 RK_FUNC_GPIO &pcfg_pull_none>,
+					<0 RK_PA6 RK_FUNC_GPIO &pcfg_pull_none>;
+			};
+		};
+
+		hdmi_i2c {
+			hdmii2c_xfer: hdmii2c-xfer {
+				rockchip,pins = <0 RK_PA5 1 &pcfg_pull_none>,
+						<0 RK_PA6 1 &pcfg_pull_none>;
+			};
+		};
+
+		pdm-0 {
+			pdmm0_clk: pdmm0-clk {
+				rockchip,pins = <2 RK_PC2 2 &pcfg_pull_none>;
+			};
+
+			pdmm0_fsync: pdmm0-fsync {
+				rockchip,pins = <2 RK_PC7 2 &pcfg_pull_none>;
+			};
+
+			pdmm0_sdi0: pdmm0-sdi0 {
+				rockchip,pins = <2 RK_PC3 2 &pcfg_pull_none>;
+			};
+
+			pdmm0_sdi1: pdmm0-sdi1 {
+				rockchip,pins = <2 RK_PC4 2 &pcfg_pull_none>;
+			};
+
+			pdmm0_sdi2: pdmm0-sdi2 {
+				rockchip,pins = <2 RK_PC5 2 &pcfg_pull_none>;
+			};
+
+			pdmm0_sdi3: pdmm0-sdi3 {
+				rockchip,pins = <2 RK_PC6 2 &pcfg_pull_none>;
+			};
+
+			pdmm0_clk_sleep: pdmm0-clk-sleep {
+				rockchip,pins =
+					<2 RK_PC2 RK_FUNC_GPIO &pcfg_input_high>;
+			};
+
+			pdmm0_sdi0_sleep: pdmm0-sdi0-sleep {
+				rockchip,pins =
+					<2 RK_PC3 RK_FUNC_GPIO &pcfg_input_high>;
+			};
+
+			pdmm0_sdi1_sleep: pdmm0-sdi1-sleep {
+				rockchip,pins =
+					<2 RK_PC4 RK_FUNC_GPIO &pcfg_input_high>;
+			};
+
+			pdmm0_sdi2_sleep: pdmm0-sdi2-sleep {
+				rockchip,pins =
+					<2 RK_PC5 RK_FUNC_GPIO &pcfg_input_high>;
+			};
+
+			pdmm0_sdi3_sleep: pdmm0-sdi3-sleep {
+				rockchip,pins =
+					<2 RK_PC6 RK_FUNC_GPIO &pcfg_input_high>;
+			};
+
+			pdmm0_fsync_sleep: pdmm0-fsync-sleep {
+				rockchip,pins =
+					<2 RK_PC7 RK_FUNC_GPIO &pcfg_input_high>;
+			};
+		};
+
+		tsadc {
+			otp_pin: otp-pin {
+				rockchip,pins = <2 RK_PB5 RK_FUNC_GPIO &pcfg_pull_none>;
+			};
+
+			otp_out: otp-out {
+				rockchip,pins = <2 RK_PB5 1 &pcfg_pull_none>;
+			};
+		};
+
+		uart0 {
+			uart0_xfer: uart0-xfer {
+				rockchip,pins = <1 RK_PB1 1 &pcfg_pull_none>,
+						<1 RK_PB0 1 &pcfg_pull_up>;
+			};
+
+			uart0_cts: uart0-cts {
+				rockchip,pins = <1 RK_PB3 1 &pcfg_pull_none>;
+			};
+
+			uart0_rts: uart0-rts {
+				rockchip,pins = <1 RK_PB2 1 &pcfg_pull_none>;
+			};
+
+			uart0_rts_pin: uart0-rts-pin {
+				rockchip,pins = <1 RK_PB2 RK_FUNC_GPIO &pcfg_pull_none>;
+			};
+		};
+
+		uart1 {
+			uart1_xfer: uart1-xfer {
+				rockchip,pins = <3 RK_PA4 4 &pcfg_pull_none>,
+						<3 RK_PA6 4 &pcfg_pull_up>;
+			};
+
+			uart1_cts: uart1-cts {
+				rockchip,pins = <3 RK_PA7 4 &pcfg_pull_none>;
+			};
+
+			uart1_rts: uart1-rts {
+				rockchip,pins = <3 RK_PA5 4 &pcfg_pull_none>;
+			};
+
+			uart1_rts_pin: uart1-rts-pin {
+				rockchip,pins = <3 RK_PA5 RK_FUNC_GPIO &pcfg_pull_none>;
+			};
+		};
+
+		uart2-0 {
+			uart2m0_xfer: uart2m0-xfer {
+				rockchip,pins = <1 RK_PA0 2 &pcfg_pull_none>,
+						<1 RK_PA1 2 &pcfg_pull_up>;
+			};
+		};
+
+		uart2-1 {
+			uart2m1_xfer: uart2m1-xfer {
+				rockchip,pins = <2 RK_PA0 1 &pcfg_pull_none>,
+						<2 RK_PA1 1 &pcfg_pull_up>;
+			};
+		};
+
+		spi0-0 {
+			spi0m0_clk: spi0m0-clk {
+				rockchip,pins = <2 RK_PB0 1 &pcfg_pull_up>;
+			};
+
+			spi0m0_cs0: spi0m0-cs0 {
+				rockchip,pins = <2 RK_PB3 1 &pcfg_pull_up>;
+			};
+
+			spi0m0_tx: spi0m0-tx {
+				rockchip,pins = <2 RK_PB1 1 &pcfg_pull_up>;
+			};
+
+			spi0m0_rx: spi0m0-rx {
+				rockchip,pins = <2 RK_PB2 1 &pcfg_pull_up>;
+			};
+
+			spi0m0_cs1: spi0m0-cs1 {
+				rockchip,pins = <2 RK_PB4 1 &pcfg_pull_up>;
+			};
+		};
+
+		spi0-1 {
+			spi0m1_clk: spi0m1-clk {
+				rockchip,pins = <3 RK_PC7 2 &pcfg_pull_up>;
+			};
+
+			spi0m1_cs0: spi0m1-cs0 {
+				rockchip,pins = <3 RK_PD2 2 &pcfg_pull_up>;
+			};
+
+			spi0m1_tx: spi0m1-tx {
+				rockchip,pins = <3 RK_PD1 2 &pcfg_pull_up>;
+			};
+
+			spi0m1_rx: spi0m1-rx {
+				rockchip,pins = <3 RK_PD0 2 &pcfg_pull_up>;
+			};
+
+			spi0m1_cs1: spi0m1-cs1 {
+				rockchip,pins = <3 RK_PD3 2 &pcfg_pull_up>;
+			};
+		};
+
+		spi0-2 {
+			spi0m2_clk: spi0m2-clk {
+				rockchip,pins = <3 RK_PA0 4 &pcfg_pull_up>;
+			};
+
+			spi0m2_cs0: spi0m2-cs0 {
+				rockchip,pins = <3 RK_PB0 3 &pcfg_pull_up>;
+			};
+
+			spi0m2_tx: spi0m2-tx {
+				rockchip,pins = <3 RK_PA1 4 &pcfg_pull_up>;
+			};
+
+			spi0m2_rx: spi0m2-rx {
+				rockchip,pins = <3 RK_PA2 4 &pcfg_pull_up>;
+			};
+		};
+
+		i2s1 {
+			i2s1_mclk: i2s1-mclk {
+				rockchip,pins = <2 RK_PB7 1 &pcfg_pull_none>;
+			};
+
+			i2s1_sclk: i2s1-sclk {
+				rockchip,pins = <2 RK_PC2 1 &pcfg_pull_none>;
+			};
+
+			i2s1_lrckrx: i2s1-lrckrx {
+				rockchip,pins = <2 RK_PC0 1 &pcfg_pull_none>;
+			};
+
+			i2s1_lrcktx: i2s1-lrcktx {
+				rockchip,pins = <2 RK_PC1 1 &pcfg_pull_none>;
+			};
+
+			i2s1_sdi: i2s1-sdi {
+				rockchip,pins = <2 RK_PC3 1 &pcfg_pull_none>;
+			};
+
+			i2s1_sdo: i2s1-sdo {
+				rockchip,pins = <2 RK_PC7 1 &pcfg_pull_none>;
+			};
+
+			i2s1_sdio1: i2s1-sdio1 {
+				rockchip,pins = <2 RK_PC4 1 &pcfg_pull_none>;
+			};
+
+			i2s1_sdio2: i2s1-sdio2 {
+				rockchip,pins = <2 RK_PC5 1 &pcfg_pull_none>;
+			};
+
+			i2s1_sdio3: i2s1-sdio3 {
+				rockchip,pins = <2 RK_PC6 1 &pcfg_pull_none>;
+			};
+
+			i2s1_sleep: i2s1-sleep {
+				rockchip,pins =
+					<2 RK_PB7 RK_FUNC_GPIO &pcfg_input_high>,
+					<2 RK_PC0 RK_FUNC_GPIO &pcfg_input_high>,
+					<2 RK_PC1 RK_FUNC_GPIO &pcfg_input_high>,
+					<2 RK_PC2 RK_FUNC_GPIO &pcfg_input_high>,
+					<2 RK_PC3 RK_FUNC_GPIO &pcfg_input_high>,
+					<2 RK_PC4 RK_FUNC_GPIO &pcfg_input_high>,
+					<2 RK_PC5 RK_FUNC_GPIO &pcfg_input_high>,
+					<2 RK_PC6 RK_FUNC_GPIO &pcfg_input_high>,
+					<2 RK_PC7 RK_FUNC_GPIO &pcfg_input_high>;
+			};
+		};
+
+		i2s2-0 {
+			i2s2m0_mclk: i2s2m0-mclk {
+				rockchip,pins = <1 RK_PC5 1 &pcfg_pull_none>;
+			};
+
+			i2s2m0_sclk: i2s2m0-sclk {
+				rockchip,pins = <1 RK_PC6 1 &pcfg_pull_none>;
+			};
+
+			i2s2m0_lrckrx: i2s2m0-lrckrx {
+				rockchip,pins = <1 RK_PD2 1 &pcfg_pull_none>;
+			};
+
+			i2s2m0_lrcktx: i2s2m0-lrcktx {
+				rockchip,pins = <1 RK_PC7 1 &pcfg_pull_none>;
+			};
+
+			i2s2m0_sdi: i2s2m0-sdi {
+				rockchip,pins = <1 RK_PD0 1 &pcfg_pull_none>;
+			};
+
+			i2s2m0_sdo: i2s2m0-sdo {
+				rockchip,pins = <1 RK_PD1 1 &pcfg_pull_none>;
+			};
+
+			i2s2m0_sleep: i2s2m0-sleep {
+				rockchip,pins =
+					<1 RK_PC5 RK_FUNC_GPIO &pcfg_input_high>,
+					<1 RK_PC6 RK_FUNC_GPIO &pcfg_input_high>,
+					<1 RK_PD2 RK_FUNC_GPIO &pcfg_input_high>,
+					<1 RK_PC7 RK_FUNC_GPIO &pcfg_input_high>,
+					<1 RK_PD0 RK_FUNC_GPIO &pcfg_input_high>,
+					<1 RK_PD1 RK_FUNC_GPIO &pcfg_input_high>;
+			};
+		};
+
+		i2s2-1 {
+			i2s2m1_mclk: i2s2m1-mclk {
+				rockchip,pins = <1 RK_PC5 1 &pcfg_pull_none>;
+			};
+
+			i2s2m1_sclk: i2s2m1-sclk {
+				rockchip,pins = <3 RK_PA0 6 &pcfg_pull_none>;
+			};
+
+			i2s2m1_lrckrx: i2sm1-lrckrx {
+				rockchip,pins = <3 RK_PB0 6 &pcfg_pull_none>;
+			};
+
+			i2s2m1_lrcktx: i2s2m1-lrcktx {
+				rockchip,pins = <3 RK_PB0 4 &pcfg_pull_none>;
+			};
+
+			i2s2m1_sdi: i2s2m1-sdi {
+				rockchip,pins = <3 RK_PA2 6 &pcfg_pull_none>;
+			};
+
+			i2s2m1_sdo: i2s2m1-sdo {
+				rockchip,pins = <3 RK_PA1 6 &pcfg_pull_none>;
+			};
+
+			i2s2m1_sleep: i2s2m1-sleep {
+				rockchip,pins =
+					<1 RK_PC5 RK_FUNC_GPIO &pcfg_input_high>,
+					<3 RK_PA0 RK_FUNC_GPIO &pcfg_input_high>,
+					<3 RK_PB0 RK_FUNC_GPIO &pcfg_input_high>,
+					<3 RK_PA2 RK_FUNC_GPIO &pcfg_input_high>,
+					<3 RK_PA1 RK_FUNC_GPIO &pcfg_input_high>;
+			};
+		};
+
+		spdif-0 {
+			spdifm0_tx: spdifm0-tx {
+				rockchip,pins = <0 RK_PD3 1 &pcfg_pull_none>;
+			};
+		};
+
+		spdif-1 {
+			spdifm1_tx: spdifm1-tx {
+				rockchip,pins = <2 RK_PC1 2 &pcfg_pull_none>;
+			};
+		};
+
+		spdif-2 {
+			spdifm2_tx: spdifm2-tx {
+				rockchip,pins = <0 RK_PA2 2 &pcfg_pull_none>;
+			};
+		};
+
+		sdmmc0-0 {
+			sdmmc0m0_pwren: sdmmc0m0-pwren {
+				rockchip,pins = <2 RK_PA7 1 &pcfg_pull_up_4ma>;
+			};
+
+			sdmmc0m0_pin: sdmmc0m0-pin {
+				rockchip,pins = <2 RK_PA7 RK_FUNC_GPIO &pcfg_pull_up_4ma>;
+			};
+		};
+
+		sdmmc0-1 {
+			sdmmc0m1_pwren: sdmmc0m1-pwren {
+				rockchip,pins = <0 RK_PD6 3 &pcfg_pull_up_4ma>;
+			};
+
+			sdmmc0m1_pin: sdmmc0m1-pin {
+				rockchip,pins = <0 RK_PD6 RK_FUNC_GPIO &pcfg_pull_up_4ma>;
+			};
+		};
+
+		sdmmc0 {
+			sdmmc0_clk: sdmmc0-clk {
+				rockchip,pins = <1 RK_PA6 1 &pcfg_pull_none_8ma>;
+			};
+
+			sdmmc0_cmd: sdmmc0-cmd {
+				rockchip,pins = <1 RK_PA4 1 &pcfg_pull_up_8ma>;
+			};
+
+			sdmmc0_dectn: sdmmc0-dectn {
+				rockchip,pins = <1 RK_PA5 1 &pcfg_pull_up_4ma>;
+			};
+
+			sdmmc0_wrprt: sdmmc0-wrprt {
+				rockchip,pins = <1 RK_PA7 1 &pcfg_pull_up_4ma>;
+			};
+
+			sdmmc0_bus1: sdmmc0-bus1 {
+				rockchip,pins = <1 RK_PA0 1 &pcfg_pull_up_8ma>;
+			};
+
+			sdmmc0_bus4: sdmmc0-bus4 {
+				rockchip,pins = <1 RK_PA0 1 &pcfg_pull_up_8ma>,
+						<1 RK_PA1 1 &pcfg_pull_up_8ma>,
+						<1 RK_PA2 1 &pcfg_pull_up_8ma>,
+						<1 RK_PA3 1 &pcfg_pull_up_8ma>;
+			};
+
+			sdmmc0_pins: sdmmc0-pins {
+				rockchip,pins =
+					<1 RK_PA6 RK_FUNC_GPIO &pcfg_pull_up_4ma>,
+					<1 RK_PA4 RK_FUNC_GPIO &pcfg_pull_up_4ma>,
+					<1 RK_PA5 RK_FUNC_GPIO &pcfg_pull_up_4ma>,
+					<1 RK_PA7 RK_FUNC_GPIO &pcfg_pull_up_4ma>,
+					<1 RK_PA3 RK_FUNC_GPIO &pcfg_pull_up_4ma>,
+					<1 RK_PA2 RK_FUNC_GPIO &pcfg_pull_up_4ma>,
+					<1 RK_PA1 RK_FUNC_GPIO &pcfg_pull_up_4ma>,
+					<1 RK_PA0 RK_FUNC_GPIO &pcfg_pull_up_4ma>;
+			};
+		};
+
+		sdmmc0ext {
+			sdmmc0ext_clk: sdmmc0ext-clk {
+				rockchip,pins = <3 RK_PA2 3 &pcfg_pull_none_4ma>;
+			};
+
+			sdmmc0ext_cmd: sdmmc0ext-cmd {
+				rockchip,pins = <3 RK_PA0 3 &pcfg_pull_up_4ma>;
+			};
+
+			sdmmc0ext_wrprt: sdmmc0ext-wrprt {
+				rockchip,pins = <3 RK_PA3 3 &pcfg_pull_up_4ma>;
+			};
+
+			sdmmc0ext_dectn: sdmmc0ext-dectn {
+				rockchip,pins = <3 RK_PA1 3 &pcfg_pull_up_4ma>;
+			};
+
+			sdmmc0ext_bus1: sdmmc0ext-bus1 {
+				rockchip,pins = <3 RK_PA4 3 &pcfg_pull_up_4ma>;
+			};
+
+			sdmmc0ext_bus4: sdmmc0ext-bus4 {
+				rockchip,pins =
+					<3 RK_PA4 3 &pcfg_pull_up_4ma>,
+					<3 RK_PA5 3 &pcfg_pull_up_4ma>,
+					<3 RK_PA6 3 &pcfg_pull_up_4ma>,
+					<3 RK_PA7 3 &pcfg_pull_up_4ma>;
+			};
+
+			sdmmc0ext_pins: sdmmc0ext-pins {
+				rockchip,pins =
+					<3 RK_PA0 RK_FUNC_GPIO &pcfg_pull_up_4ma>,
+					<3 RK_PA1 RK_FUNC_GPIO &pcfg_pull_up_4ma>,
+					<3 RK_PA2 RK_FUNC_GPIO &pcfg_pull_up_4ma>,
+					<3 RK_PA3 RK_FUNC_GPIO &pcfg_pull_up_4ma>,
+					<3 RK_PA4 RK_FUNC_GPIO &pcfg_pull_up_4ma>,
+					<3 RK_PA5 RK_FUNC_GPIO &pcfg_pull_up_4ma>,
+					<3 RK_PA6 RK_FUNC_GPIO &pcfg_pull_up_4ma>,
+					<3 RK_PA7 RK_FUNC_GPIO &pcfg_pull_up_4ma>;
+			};
+		};
+
+		sdmmc1 {
+			sdmmc1_clk: sdmmc1-clk {
+				rockchip,pins = <1 RK_PB4 1 &pcfg_pull_none_8ma>;
+			};
+
+			sdmmc1_cmd: sdmmc1-cmd {
+				rockchip,pins = <1 RK_PB5 1 &pcfg_pull_up_8ma>;
+			};
+
+			sdmmc1_pwren: sdmmc1-pwren {
+				rockchip,pins = <1 RK_PC2 1 &pcfg_pull_up_8ma>;
+			};
+
+			sdmmc1_wrprt: sdmmc1-wrprt {
+				rockchip,pins = <1 RK_PC4 1 &pcfg_pull_up_8ma>;
+			};
+
+			sdmmc1_dectn: sdmmc1-dectn {
+				rockchip,pins = <1 RK_PC3 1 &pcfg_pull_up_8ma>;
+			};
+
+			sdmmc1_bus1: sdmmc1-bus1 {
+				rockchip,pins = <1 RK_PB6 1 &pcfg_pull_up_8ma>;
+			};
+
+			sdmmc1_bus4: sdmmc1-bus4 {
+				rockchip,pins = <1 RK_PB6 1 &pcfg_pull_up_8ma>,
+						<1 RK_PB7 1 &pcfg_pull_up_8ma>,
+						<1 RK_PC0 1 &pcfg_pull_up_8ma>,
+						<1 RK_PC1 1 &pcfg_pull_up_8ma>;
+			};
+
+			sdmmc1_pins: sdmmc1-pins {
+				rockchip,pins =
+					<1 RK_PB4 RK_FUNC_GPIO &pcfg_pull_up_4ma>,
+					<1 RK_PB5 RK_FUNC_GPIO &pcfg_pull_up_4ma>,
+					<1 RK_PB6 RK_FUNC_GPIO &pcfg_pull_up_4ma>,
+					<1 RK_PB7 RK_FUNC_GPIO &pcfg_pull_up_4ma>,
+					<1 RK_PC0 RK_FUNC_GPIO &pcfg_pull_up_4ma>,
+					<1 RK_PC1 RK_FUNC_GPIO &pcfg_pull_up_4ma>,
+					<1 RK_PC2 RK_FUNC_GPIO &pcfg_pull_up_4ma>,
+					<1 RK_PC3 RK_FUNC_GPIO &pcfg_pull_up_4ma>,
+					<1 RK_PC4 RK_FUNC_GPIO &pcfg_pull_up_4ma>;
+			};
+		};
+
+		emmc {
+			emmc_clk: emmc-clk {
+				rockchip,pins = <3 RK_PC5 2 &pcfg_pull_none_12ma>;
+			};
+
+			emmc_cmd: emmc-cmd {
+				rockchip,pins = <3 RK_PC3 2 &pcfg_pull_up_12ma>;
+			};
+
+			emmc_pwren: emmc-pwren {
+				rockchip,pins = <3 RK_PC6 2 &pcfg_pull_none>;
+			};
+
+			emmc_rstnout: emmc-rstnout {
+				rockchip,pins = <3 RK_PC4 2 &pcfg_pull_none>;
+			};
+
+			emmc_bus1: emmc-bus1 {
+				rockchip,pins = <0 RK_PA7 2 &pcfg_pull_up_12ma>;
+			};
+
+			emmc_bus4: emmc-bus4 {
+				rockchip,pins =
+					<0 RK_PA7 2 &pcfg_pull_up_12ma>,
+					<2 RK_PD4 2 &pcfg_pull_up_12ma>,
+					<2 RK_PD5 2 &pcfg_pull_up_12ma>,
+					<2 RK_PD6 2 &pcfg_pull_up_12ma>;
+			};
+
+			emmc_bus8: emmc-bus8 {
+				rockchip,pins =
+					<0 RK_PA7 2 &pcfg_pull_up_12ma>,
+					<2 RK_PD4 2 &pcfg_pull_up_12ma>,
+					<2 RK_PD5 2 &pcfg_pull_up_12ma>,
+					<2 RK_PD6 2 &pcfg_pull_up_12ma>,
+					<2 RK_PD7 2 &pcfg_pull_up_12ma>,
+					<3 RK_PC0 2 &pcfg_pull_up_12ma>,
+					<3 RK_PC1 2 &pcfg_pull_up_12ma>,
+					<3 RK_PC2 2 &pcfg_pull_up_12ma>;
+			};
+		};
+
+		pwm0 {
+			pwm0_pin: pwm0-pin {
+				rockchip,pins = <2 RK_PA4 1 &pcfg_pull_none>;
+			};
+		};
+
+		pwm1 {
+			pwm1_pin: pwm1-pin {
+				rockchip,pins = <2 RK_PA5 1 &pcfg_pull_none>;
+			};
+		};
+
+		pwm2 {
+			pwm2_pin: pwm2-pin {
+				rockchip,pins = <2 RK_PA6 1 &pcfg_pull_none>;
+			};
+		};
+
+		pwmir {
+			pwmir_pin: pwmir-pin {
+				rockchip,pins = <2 RK_PA2 1 &pcfg_pull_none>;
+			};
+		};
+
+		gmac-1 {
+			rgmiim1_pins: rgmiim1-pins {
+				rockchip,pins =
+					/* mac_txclk */
+					<1 RK_PB4 2 &pcfg_pull_none_8ma>,
+					/* mac_rxclk */
+					<1 RK_PB5 2 &pcfg_pull_none_4ma>,
+					/* mac_mdio */
+					<1 RK_PC3 2 &pcfg_pull_none_4ma>,
+					/* mac_txen */
+					<1 RK_PD1 2 &pcfg_pull_none_8ma>,
+					/* mac_clk */
+					<1 RK_PC5 2 &pcfg_pull_none_4ma>,
+					/* mac_rxdv */
+					<1 RK_PC6 2 &pcfg_pull_none_4ma>,
+					/* mac_mdc */
+					<1 RK_PC7 2 &pcfg_pull_none_4ma>,
+					/* mac_rxd1 */
+					<1 RK_PB2 2 &pcfg_pull_none_4ma>,
+					/* mac_rxd0 */
+					<1 RK_PB3 2 &pcfg_pull_none_4ma>,
+					/* mac_txd1 */
+					<1 RK_PB0 2 &pcfg_pull_none_8ma>,
+					/* mac_txd0 */
+					<1 RK_PB1 2 &pcfg_pull_none_8ma>,
+					/* mac_rxd3 */
+					<1 RK_PB6 2 &pcfg_pull_none_4ma>,
+					/* mac_rxd2 */
+					<1 RK_PB7 2 &pcfg_pull_none_4ma>,
+					/* mac_txd3 */
+					<1 RK_PC0 2 &pcfg_pull_none_8ma>,
+					/* mac_txd2 */
+					<1 RK_PC1 2 &pcfg_pull_none_8ma>,
+
+					/* mac_txclk */
+					<0 RK_PB0 1 &pcfg_pull_none_8ma>,
+					/* mac_txen */
+					<0 RK_PB4 1 &pcfg_pull_none_8ma>,
+					/* mac_clk */
+					<0 RK_PD0 1 &pcfg_pull_none_4ma>,
+					/* mac_txd1 */
+					<0 RK_PC0 1 &pcfg_pull_none_8ma>,
+					/* mac_txd0 */
+					<0 RK_PC1 1 &pcfg_pull_none_8ma>,
+					/* mac_txd3 */
+					<0 RK_PC7 1 &pcfg_pull_none_8ma>,
+					/* mac_txd2 */
+					<0 RK_PC6 1 &pcfg_pull_none_8ma>;
+			};
+
+			rmiim1_pins: rmiim1-pins {
+				rockchip,pins =
+					/* mac_mdio */
+					<1 RK_PC3 2 &pcfg_pull_none_2ma>,
+					/* mac_txen */
+					<1 RK_PD1 2 &pcfg_pull_none_12ma>,
+					/* mac_clk */
+					<1 RK_PC5 2 &pcfg_pull_none_2ma>,
+					/* mac_rxer */
+					<1 RK_PD0 2 &pcfg_pull_none_2ma>,
+					/* mac_rxdv */
+					<1 RK_PC6 2 &pcfg_pull_none_2ma>,
+					/* mac_mdc */
+					<1 RK_PC7 2 &pcfg_pull_none_2ma>,
+					/* mac_rxd1 */
+					<1 RK_PB2 2 &pcfg_pull_none_2ma>,
+					/* mac_rxd0 */
+					<1 RK_PB3 2 &pcfg_pull_none_2ma>,
+					/* mac_txd1 */
+					<1 RK_PB0 2 &pcfg_pull_none_12ma>,
+					/* mac_txd0 */
+					<1 RK_PB1 2 &pcfg_pull_none_12ma>,
+
+					/* mac_mdio */
+					<0 RK_PB3 1 &pcfg_pull_none>,
+					/* mac_txen */
+					<0 RK_PB4 1 &pcfg_pull_none>,
+					/* mac_clk */
+					<0 RK_PD0 1 &pcfg_pull_none>,
+					/* mac_mdc */
+					<0 RK_PC3 1 &pcfg_pull_none>,
+					/* mac_txd1 */
+					<0 RK_PC0 1 &pcfg_pull_none>,
+					/* mac_txd0 */
+					<0 RK_PC1 1 &pcfg_pull_none>;
+			};
+		};
+
+		gmac2phy {
+			fephyled_speed10: fephyled-speed10 {
+				rockchip,pins = <0 RK_PD6 1 &pcfg_pull_none>;
+			};
+
+			fephyled_duplex: fephyled-duplex {
+				rockchip,pins = <0 RK_PD6 2 &pcfg_pull_none>;
+			};
+
+			fephyled_rxm1: fephyled-rxm1 {
+				rockchip,pins = <2 RK_PD1 2 &pcfg_pull_none>;
+			};
+
+			fephyled_txm1: fephyled-txm1 {
+				rockchip,pins = <2 RK_PD1 3 &pcfg_pull_none>;
+			};
+
+			fephyled_linkm1: fephyled-linkm1 {
+				rockchip,pins = <2 RK_PD0 2 &pcfg_pull_none>;
+			};
+		};
+
+		tsadc_pin {
+			tsadc_int: tsadc-int {
+				rockchip,pins = <2 RK_PB5 2 &pcfg_pull_none>;
+			};
+			tsadc_pin: tsadc-pin {
+				rockchip,pins = <2 RK_PB5 RK_FUNC_GPIO &pcfg_pull_none>;
+			};
+		};
+
+		hdmi_pin {
+			hdmi_cec: hdmi-cec {
+				rockchip,pins = <0 RK_PA3 1 &pcfg_pull_none>;
+			};
+
+			hdmi_hpd: hdmi-hpd {
+				rockchip,pins = <0 RK_PA4 1 &pcfg_pull_down>;
+			};
+		};
+
+		cif-0 {
+			dvp_d2d9_m0:dvp-d2d9-m0 {
+				rockchip,pins =
+					/* cif_d0 */
+					<3 RK_PA4 2 &pcfg_pull_none>,
+					/* cif_d1 */
+					<3 RK_PA5 2 &pcfg_pull_none>,
+					/* cif_d2 */
+					<3 RK_PA6 2 &pcfg_pull_none>,
+					/* cif_d3 */
+					<3 RK_PA7 2 &pcfg_pull_none>,
+					/* cif_d4 */
+					<3 RK_PB0 2 &pcfg_pull_none>,
+					/* cif_d5m0 */
+					<3 RK_PB1 2 &pcfg_pull_none>,
+					/* cif_d6m0 */
+					<3 RK_PB2 2 &pcfg_pull_none>,
+					/* cif_d7m0 */
+					<3 RK_PB3 2 &pcfg_pull_none>,
+					/* cif_href */
+					<3 RK_PA1 2 &pcfg_pull_none>,
+					/* cif_vsync */
+					<3 RK_PA0 2 &pcfg_pull_none>,
+					/* cif_clkoutm0 */
+					<3 RK_PA3 2 &pcfg_pull_none>,
+					/* cif_clkin */
+					<3 RK_PA2 2 &pcfg_pull_none>;
+			};
+		};
+
+		cif-1 {
+			dvp_d2d9_m1:dvp-d2d9-m1 {
+				rockchip,pins =
+					/* cif_d0 */
+					<3 RK_PA4 2 &pcfg_pull_none>,
+					/* cif_d1 */
+					<3 RK_PA5 2 &pcfg_pull_none>,
+					/* cif_d2 */
+					<3 RK_PA6 2 &pcfg_pull_none>,
+					/* cif_d3 */
+					<3 RK_PA7 2 &pcfg_pull_none>,
+					/* cif_d4 */
+					<3 RK_PB0 2 &pcfg_pull_none>,
+					/* cif_d5m1 */
+					<2 RK_PC0 4 &pcfg_pull_none>,
+					/* cif_d6m1 */
+					<2 RK_PC1 4 &pcfg_pull_none>,
+					/* cif_d7m1 */
+					<2 RK_PC2 4 &pcfg_pull_none>,
+					/* cif_href */
+					<3 RK_PA1 2 &pcfg_pull_none>,
+					/* cif_vsync */
+					<3 RK_PA0 2 &pcfg_pull_none>,
+					/* cif_clkoutm1 */
+					<2 RK_PB7 4 &pcfg_pull_none>,
+					/* cif_clkin */
+					<3 RK_PA2 2 &pcfg_pull_none>;
+			};
+		};
+	};
+};
diff --git a/arch/arm64/boot/dts/rockchip/rk3328.dtsi.rej b/arch/arm64/boot/dts/rockchip/rk3328.dtsi.rej
new file mode 100644
index 000000000000..cf73bf833ba5
--- /dev/null
+++ b/arch/arm64/boot/dts/rockchip/rk3328.dtsi.rej
@@ -0,0 +1,23 @@
+--- arch/arm64/boot/dts/rockchip/rk3328.dtsi
++++ arch/arm64/boot/dts/rockchip/rk3328.dtsi
+@@ -846,6 +846,20 @@ vop_mmu: iommu@ff373f00 {
+ 		status = "disabled";
+ 	};
+ 
++	rga: rga@ff390000 {
++		compatible = "rockchip,rk3328-rga", "rockchip,rk3399-rga";
++		reg = <0x0 0xff390000 0x0 0x1000>;
++		interrupts = <GIC_SPI 33 IRQ_TYPE_LEVEL_HIGH>;
++		clocks = <&cru ACLK_RGA>,
++			<&cru HCLK_RGA>,
++			<&cru SCLK_RGA>;
++		clock-names = "aclk", "hclk", "sclk";
++		resets = <&cru SRST_RGA>,
++			<&cru SRST_RGA_A>,
++			<&cru SRST_RGA_H>;
++		reset-names = "core", "axi", "ahb";
++	};
++
+ 	iep: iep@ff3a0000 {
+ 		compatible = "rockchip,rk3328-iep", "rockchip,rk3228-iep";
+ 		reg = <0x0 0xff3a0000 0x0 0x800>;
diff --git a/drivers/clk/rockchip/clk-ddr.c b/drivers/clk/rockchip/clk-ddr.c
index 86718c54e56b..08b313495e8c 100644
--- a/drivers/clk/rockchip/clk-ddr.c
+++ b/drivers/clk/rockchip/clk-ddr.c
@@ -87,6 +87,134 @@ static const struct clk_ops rockchip_ddrclk_sip_ops = {
 	.get_parent = rockchip_ddrclk_get_parent,
 };
 
+/* See v4.4/include/dt-bindings/display/rk_fb.h */
+#define SCREEN_NULL			0
+#define SCREEN_HDMI			6
+
+static inline int rk_drm_get_lcdc_type(void)
+{
+	return SCREEN_NULL;
+}
+
+struct share_params {
+	u32 hz;
+	u32 lcdc_type;
+	u32 vop;
+	u32 vop_dclk_mode;
+	u32 sr_idle_en;
+	u32 addr_mcu_el3;
+	/*
+	 * 1: need to wait flag1
+	 * 0: never wait flag1
+	 */
+	u32 wait_flag1;
+	/*
+	 * 1: need to wait flag1
+	 * 0: never wait flag1
+	 */
+	u32 wait_flag0;
+	u32 complt_hwirq;
+	 /* if need, add parameter after */
+};
+
+struct rockchip_ddrclk_data {
+	u32 inited_flag;
+	void __iomem *share_memory;
+};
+
+static struct rockchip_ddrclk_data ddr_data;
+
+static void rockchip_ddrclk_data_init(void)
+{
+	struct arm_smccc_res res;
+
+	arm_smccc_smc(ROCKCHIP_SIP_SHARE_MEM,
+		      1, SHARE_PAGE_TYPE_DDR, 0,
+		      0, 0, 0, 0, &res);
+
+	if (!res.a0) {
+		ddr_data.share_memory = (void __iomem *)ioremap(res.a1, 1<<12);
+		ddr_data.inited_flag = 1;
+	}
+}
+
+static int rockchip_ddrclk_sip_set_rate_v2(struct clk_hw *hw,
+					   unsigned long drate,
+					   unsigned long prate)
+{
+	struct share_params *p;
+	struct arm_smccc_res res;
+
+	if (!ddr_data.inited_flag)
+		rockchip_ddrclk_data_init();
+
+	p = (struct share_params *)ddr_data.share_memory;
+
+	p->hz = drate;
+	p->lcdc_type = rk_drm_get_lcdc_type();
+	p->wait_flag1 = 1;
+	p->wait_flag0 = 1;
+
+	arm_smccc_smc(ROCKCHIP_SIP_DRAM_FREQ,
+		      SHARE_PAGE_TYPE_DDR, 0,
+		      ROCKCHIP_SIP_CONFIG_DRAM_SET_RATE,
+		      0, 0, 0, 0, &res);
+
+	if ((int)res.a1 == -6) {
+		pr_err("%s: timeout, drate = %lumhz\n", __func__, drate/1000000);
+		/* TODO: rockchip_dmcfreq_wait_complete(); */
+	}
+
+	return res.a0;
+}
+
+static unsigned long rockchip_ddrclk_sip_recalc_rate_v2
+			(struct clk_hw *hw, unsigned long parent_rate)
+{
+	struct arm_smccc_res res;
+
+	arm_smccc_smc(ROCKCHIP_SIP_DRAM_FREQ,
+		      SHARE_PAGE_TYPE_DDR, 0,
+		      ROCKCHIP_SIP_CONFIG_DRAM_GET_RATE,
+		      0, 0, 0, 0, &res);
+	if (!res.a0)
+		return res.a1;
+	else
+		return 0;
+}
+
+static long rockchip_ddrclk_sip_round_rate_v2(struct clk_hw *hw,
+					      unsigned long rate,
+					      unsigned long *prate)
+{
+	struct share_params *p;
+	struct arm_smccc_res res;
+
+	if (!ddr_data.inited_flag)
+		rockchip_ddrclk_data_init();
+
+	p = (struct share_params *)ddr_data.share_memory;
+
+	p->hz = rate;
+
+	arm_smccc_smc(ROCKCHIP_SIP_DRAM_FREQ,
+		      SHARE_PAGE_TYPE_DDR, 0,
+		      ROCKCHIP_SIP_CONFIG_DRAM_ROUND_RATE,
+		      0, 0, 0, 0, &res);
+
+	if (!res.a0)
+		return res.a1;
+	else
+		return 0;
+}
+
+static const struct clk_ops rockchip_ddrclk_sip_ops_v2 = {
+	.recalc_rate = rockchip_ddrclk_sip_recalc_rate_v2,
+	.set_rate = rockchip_ddrclk_sip_set_rate_v2,
+	.round_rate = rockchip_ddrclk_sip_round_rate_v2,
+	.get_parent = rockchip_ddrclk_get_parent,
+};
+
 struct clk *rockchip_clk_register_ddrclk(const char *name, int flags,
 					 const char *const *parent_names,
 					 u8 num_parents, int mux_offset,
@@ -114,6 +242,9 @@ struct clk *rockchip_clk_register_ddrclk(const char *name, int flags,
 	case ROCKCHIP_DDRCLK_SIP:
 		init.ops = &rockchip_ddrclk_sip_ops;
 		break;
+	case ROCKCHIP_DDRCLK_SIP_V2:
+		init.ops = &rockchip_ddrclk_sip_ops_v2;
+		break;
 	default:
 		pr_err("%s: unsupported ddrclk type %d\n", __func__, ddr_flag);
 		kfree(ddrclk);
diff --git a/drivers/clk/rockchip/clk-ddr.c.orig b/drivers/clk/rockchip/clk-ddr.c.orig
new file mode 100644
index 000000000000..86718c54e56b
--- /dev/null
+++ b/drivers/clk/rockchip/clk-ddr.c.orig
@@ -0,0 +1,139 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (c) 2016 Rockchip Electronics Co. Ltd.
+ * Author: Lin Huang <hl@rock-chips.com>
+ */
+
+#include <linux/arm-smccc.h>
+#include <linux/clk.h>
+#include <linux/clk-provider.h>
+#include <linux/io.h>
+#include <linux/slab.h>
+#include <soc/rockchip/rockchip_sip.h>
+#include "clk.h"
+
+struct rockchip_ddrclk {
+	struct clk_hw	hw;
+	void __iomem	*reg_base;
+	int		mux_offset;
+	int		mux_shift;
+	int		mux_width;
+	int		div_shift;
+	int		div_width;
+	int		ddr_flag;
+	spinlock_t	*lock;
+};
+
+#define to_rockchip_ddrclk_hw(hw) container_of(hw, struct rockchip_ddrclk, hw)
+
+static int rockchip_ddrclk_sip_set_rate(struct clk_hw *hw, unsigned long drate,
+					unsigned long prate)
+{
+	struct rockchip_ddrclk *ddrclk = to_rockchip_ddrclk_hw(hw);
+	unsigned long flags;
+	struct arm_smccc_res res;
+
+	spin_lock_irqsave(ddrclk->lock, flags);
+	arm_smccc_smc(ROCKCHIP_SIP_DRAM_FREQ, drate, 0,
+		      ROCKCHIP_SIP_CONFIG_DRAM_SET_RATE,
+		      0, 0, 0, 0, &res);
+	spin_unlock_irqrestore(ddrclk->lock, flags);
+
+	return res.a0;
+}
+
+static unsigned long
+rockchip_ddrclk_sip_recalc_rate(struct clk_hw *hw,
+				unsigned long parent_rate)
+{
+	struct arm_smccc_res res;
+
+	arm_smccc_smc(ROCKCHIP_SIP_DRAM_FREQ, 0, 0,
+		      ROCKCHIP_SIP_CONFIG_DRAM_GET_RATE,
+		      0, 0, 0, 0, &res);
+
+	return res.a0;
+}
+
+static long rockchip_ddrclk_sip_round_rate(struct clk_hw *hw,
+					   unsigned long rate,
+					   unsigned long *prate)
+{
+	struct arm_smccc_res res;
+
+	arm_smccc_smc(ROCKCHIP_SIP_DRAM_FREQ, rate, 0,
+		      ROCKCHIP_SIP_CONFIG_DRAM_ROUND_RATE,
+		      0, 0, 0, 0, &res);
+
+	return res.a0;
+}
+
+static u8 rockchip_ddrclk_get_parent(struct clk_hw *hw)
+{
+	struct rockchip_ddrclk *ddrclk = to_rockchip_ddrclk_hw(hw);
+	u32 val;
+
+	val = readl(ddrclk->reg_base +
+			ddrclk->mux_offset) >> ddrclk->mux_shift;
+	val &= GENMASK(ddrclk->mux_width - 1, 0);
+
+	return val;
+}
+
+static const struct clk_ops rockchip_ddrclk_sip_ops = {
+	.recalc_rate = rockchip_ddrclk_sip_recalc_rate,
+	.set_rate = rockchip_ddrclk_sip_set_rate,
+	.round_rate = rockchip_ddrclk_sip_round_rate,
+	.get_parent = rockchip_ddrclk_get_parent,
+};
+
+struct clk *rockchip_clk_register_ddrclk(const char *name, int flags,
+					 const char *const *parent_names,
+					 u8 num_parents, int mux_offset,
+					 int mux_shift, int mux_width,
+					 int div_shift, int div_width,
+					 int ddr_flag, void __iomem *reg_base,
+					 spinlock_t *lock)
+{
+	struct rockchip_ddrclk *ddrclk;
+	struct clk_init_data init;
+	struct clk *clk;
+
+	ddrclk = kzalloc(sizeof(*ddrclk), GFP_KERNEL);
+	if (!ddrclk)
+		return ERR_PTR(-ENOMEM);
+
+	init.name = name;
+	init.parent_names = parent_names;
+	init.num_parents = num_parents;
+
+	init.flags = flags;
+	init.flags |= CLK_SET_RATE_NO_REPARENT;
+
+	switch (ddr_flag) {
+	case ROCKCHIP_DDRCLK_SIP:
+		init.ops = &rockchip_ddrclk_sip_ops;
+		break;
+	default:
+		pr_err("%s: unsupported ddrclk type %d\n", __func__, ddr_flag);
+		kfree(ddrclk);
+		return ERR_PTR(-EINVAL);
+	}
+
+	ddrclk->reg_base = reg_base;
+	ddrclk->lock = lock;
+	ddrclk->hw.init = &init;
+	ddrclk->mux_offset = mux_offset;
+	ddrclk->mux_shift = mux_shift;
+	ddrclk->mux_width = mux_width;
+	ddrclk->div_shift = div_shift;
+	ddrclk->div_width = div_width;
+	ddrclk->ddr_flag = ddr_flag;
+
+	clk = clk_register(NULL, &ddrclk->hw);
+	if (IS_ERR(clk))
+		kfree(ddrclk);
+
+	return clk;
+}
+EXPORT_SYMBOL_GPL(rockchip_clk_register_ddrclk);
diff --git a/drivers/clk/rockchip/clk-rk3328.c b/drivers/clk/rockchip/clk-rk3328.c
index cd5f65b6cdf5..d748dc50fc2e 100644
--- a/drivers/clk/rockchip/clk-rk3328.c
+++ b/drivers/clk/rockchip/clk-rk3328.c
@@ -315,14 +315,15 @@ static struct rockchip_clk_branch rk3328_clk_branches[] __initdata = {
 			RK3328_CLKGATE_CON(14), 1, GFLAGS),
 
 	/* PD_DDR */
-	COMPOSITE(0, "clk_ddr", mux_ddrphy_p, CLK_IGNORE_UNUSED,
-			RK3328_CLKSEL_CON(3), 8, 2, MFLAGS, 0, 3, DFLAGS | CLK_DIVIDER_POWER_OF_TWO,
-			RK3328_CLKGATE_CON(0), 4, GFLAGS),
-	GATE(0, "clk_ddrmsch", "clk_ddr", CLK_IGNORE_UNUSED,
+	COMPOSITE_DDRCLK(SCLK_DDRCLK, "sclk_ddrc", mux_ddrphy_p, 0,
+			RK3328_CLKSEL_CON(3), 8, 2, 0, 3,
+			ROCKCHIP_DDRCLK_SIP_V2),
+
+	GATE(0, "clk_ddrmsch", "sclk_ddrc", CLK_IGNORE_UNUSED,
 			RK3328_CLKGATE_CON(18), 6, GFLAGS),
-	GATE(0, "clk_ddrupctl", "clk_ddr", CLK_IGNORE_UNUSED,
+	GATE(0, "clk_ddrupctl", "sclk_ddrc", CLK_IGNORE_UNUSED,
 			RK3328_CLKGATE_CON(18), 5, GFLAGS),
-	GATE(0, "aclk_ddrupctl", "clk_ddr", CLK_IGNORE_UNUSED,
+	GATE(0, "aclk_ddrupctl", "sclk_ddrc", CLK_IGNORE_UNUSED,
 			RK3328_CLKGATE_CON(18), 4, GFLAGS),
 	GATE(0, "clk_ddrmon", "xin24m", CLK_IGNORE_UNUSED,
 			RK3328_CLKGATE_CON(0), 6, GFLAGS),
diff --git a/drivers/clk/rockchip/clk.h b/drivers/clk/rockchip/clk.h
index 7c5e74c7a2e2..1a95b3a4f7ad 100644
--- a/drivers/clk/rockchip/clk.h
+++ b/drivers/clk/rockchip/clk.h
@@ -632,7 +632,8 @@ struct clk *rockchip_clk_register_mmc(const char *name,
  * DDRCLK flags, including method of setting the rate
  * ROCKCHIP_DDRCLK_SIP: use SIP call to bl31 to change ddrclk rate.
  */
-#define ROCKCHIP_DDRCLK_SIP		BIT(0)
+#define ROCKCHIP_DDRCLK_SIP		0x01
+#define ROCKCHIP_DDRCLK_SIP_V2		0x03
 
 struct clk *rockchip_clk_register_ddrclk(const char *name, int flags,
 					 const char *const *parent_names,
diff --git a/drivers/devfreq/Kconfig b/drivers/devfreq/Kconfig
index c999c4a1e567..f460506fb1a5 100644
--- a/drivers/devfreq/Kconfig
+++ b/drivers/devfreq/Kconfig
@@ -140,6 +140,18 @@ config ARM_MEDIATEK_CCI_DEVFREQ
 	  buck voltages and update a proper CCI frequency. Use the notification
 	  to get the regulator status.
 
+config ARM_RK3328_DMC_DEVFREQ
+	tristate "ARM RK3328 DMC DEVFREQ Driver"
+	depends on ARCH_ROCKCHIP
+	select DEVFREQ_EVENT_ROCKCHIP_DFI
+	select DEVFREQ_GOV_SIMPLE_ONDEMAND
+	select PM_DEVFREQ_EVENT
+	select PM_OPP
+	help
+	  This adds the DEVFREQ driver for the RK3328 DMC(Dynamic Memory Controller).
+	  It sets the frequency for the memory controller and reads the usage counts
+	  from hardware.
+
 config ARM_RK3399_DMC_DEVFREQ
 	tristate "ARM RK3399 DMC DEVFREQ Driver"
 	depends on (ARCH_ROCKCHIP && HAVE_ARM_SMCCC) || \
diff --git a/drivers/devfreq/Makefile b/drivers/devfreq/Makefile
index 404179d79a9d..efb685ade2bb 100644
--- a/drivers/devfreq/Makefile
+++ b/drivers/devfreq/Makefile
@@ -14,6 +14,7 @@ obj-$(CONFIG_ARM_IMX_BUS_DEVFREQ)	+= imx-bus.o
 obj-$(CONFIG_ARM_IMX8M_DDRC_DEVFREQ)	+= imx8m-ddrc.o
 obj-$(CONFIG_ARM_MEDIATEK_CCI_DEVFREQ)	+= mtk-cci-devfreq.o
 obj-$(CONFIG_ARM_RK3399_DMC_DEVFREQ)	+= rk3399_dmc.o
+obj-$(CONFIG_ARM_RK3328_DMC_DEVFREQ)	+= rk3328_dmc.o
 obj-$(CONFIG_ARM_SUN8I_A33_MBUS_DEVFREQ)	+= sun8i-a33-mbus.o
 obj-$(CONFIG_ARM_TEGRA_DEVFREQ)		+= tegra30-devfreq.o
 
diff --git a/drivers/devfreq/event/rockchip-dfi.c b/drivers/devfreq/event/rockchip-dfi.c
index 0470d7c175f4..f1a031078ce3 100644
--- a/drivers/devfreq/event/rockchip-dfi.c
+++ b/drivers/devfreq/event/rockchip-dfi.c
@@ -24,6 +24,8 @@
 #include <linux/perf_event.h>
 
 #include <soc/rockchip/rockchip_grf.h>
+#include <soc/rockchip/rk3228_grf.h>
+#include <soc/rockchip/rk3328_grf.h>
 #include <soc/rockchip/rk3399_grf.h>
 #include <soc/rockchip/rk3568_grf.h>
 #include <soc/rockchip/rk3588_grf.h>
@@ -99,6 +101,7 @@ struct rockchip_dfi {
 
 	struct device *dev;
 	void __iomem *regs;
+	struct regmap *regmap_grf;
 	struct regmap *regmap_pmu;
 	struct clk *clk;
 	int usecount;
@@ -668,6 +671,46 @@ static int rockchip_ddr_perf_init(struct rockchip_dfi *dfi)
 }
 #endif
 
+static int rk3228_dfi_init(struct rockchip_dfi *dfi)
+{
+	u32 val;
+
+	regmap_read(dfi->regmap_grf, RK3228_GRF_OS_REG2, &val);
+	dfi->ddr_type = FIELD_GET(RK3228_GRF_OS_REG2_DDRTYPE, val);
+
+	dfi->channel_mask = GENMASK(0, 0);
+	dfi->max_channels = 1;
+
+	dfi->buswidth[0] = 2;  // 16 bit bus width
+
+	dfi->ddrmon_stride = 0x0;  // single channel controller
+	dfi->ddrmon_ctrl_single = true;
+
+	dfi->clk = NULL;
+
+	return 0;
+}
+
+static int rk3328_dfi_init(struct rockchip_dfi *dfi)
+{
+	u32 val;
+
+	regmap_read(dfi->regmap_grf, RK3328_GRF_OS_REG2, &val);
+	dfi->ddr_type = FIELD_GET(RK3328_GRF_OS_REG2_DDRTYPE, val);
+
+	dfi->channel_mask = GENMASK(0, 0);
+	dfi->max_channels = 1;
+
+	dfi->buswidth[0] = 2;  // 16 bit bus width
+
+	dfi->ddrmon_stride = 0x0;  // single channel controller
+	dfi->ddrmon_ctrl_single = true;
+
+	dfi->clk = NULL;
+
+	return 0;
+}
+
 static int rk3399_dfi_init(struct rockchip_dfi *dfi)
 {
 	struct regmap *regmap_pmu = dfi->regmap_pmu;
@@ -756,6 +799,8 @@ static int rk3588_dfi_init(struct rockchip_dfi *dfi)
 };
 
 static const struct of_device_id rockchip_dfi_id_match[] = {
+	{ .compatible = "rockchip,rk3228-dfi", .data = rk3228_dfi_init },
+	{ .compatible = "rockchip,rk3328-dfi", .data = rk3328_dfi_init },
 	{ .compatible = "rockchip,rk3399-dfi", .data = rk3399_dfi_init },
 	{ .compatible = "rockchip,rk3568-dfi", .data = rk3568_dfi_init },
 	{ .compatible = "rockchip,rk3588-dfi", .data = rk3588_dfi_init },
@@ -785,14 +830,30 @@ static int rockchip_dfi_probe(struct platform_device *pdev)
 	if (IS_ERR(dfi->regs))
 		return PTR_ERR(dfi->regs);
 
-	node = of_parse_phandle(np, "rockchip,pmu", 0);
-	if (!node)
-		return dev_err_probe(&pdev->dev, -ENODEV, "Can't find pmu_grf registers\n");
+	if (soc_init == rk3228_dfi_init ||
+	    soc_init == rk3328_dfi_init) {
+		node = of_parse_phandle(np, "rockchip,grf", 0);
+		if (!node)
+			return dev_err_probe(&pdev->dev, -ENODEV, "Can't find grf registers");
 
-	dfi->regmap_pmu = syscon_node_to_regmap(node);
-	of_node_put(node);
-	if (IS_ERR(dfi->regmap_pmu))
-		return PTR_ERR(dfi->regmap_pmu);
+		dfi->regmap_grf = syscon_node_to_regmap(node);
+		of_node_put(node);
+		if (IS_ERR(dfi->regmap_grf))
+			return PTR_ERR(dfi->regmap_grf);
+	}
+
+	if (soc_init == rk3399_dfi_init ||
+	    soc_init == rk3568_dfi_init ||
+	    soc_init == rk3588_dfi_init) {
+		node = of_parse_phandle(np, "rockchip,pmu", 0);
+		if (!node)
+			return dev_err_probe(&pdev->dev, -ENODEV, "Can't find pmu_grf registers\n");
+
+		dfi->regmap_pmu = syscon_node_to_regmap(node);
+		of_node_put(node);
+		if (IS_ERR(dfi->regmap_pmu))
+			return PTR_ERR(dfi->regmap_pmu);
+	}
 
 	dfi->dev = dev;
 	mutex_init(&dfi->mutex);
@@ -817,6 +878,8 @@ static int rockchip_dfi_probe(struct platform_device *pdev)
 	if (ret)
 		return ret;
 
+	dev_notice(dfi->dev, "dfi initialized, dram type: 0x%x, channels: %d\n", dfi->ddr_type, dfi->max_channels);
+
 	platform_set_drvdata(pdev, dfi);
 
 	return 0;
diff --git a/drivers/devfreq/event/rockchip-dfi.c.orig b/drivers/devfreq/event/rockchip-dfi.c.orig
new file mode 100644
index 000000000000..0470d7c175f4
--- /dev/null
+++ b/drivers/devfreq/event/rockchip-dfi.c.orig
@@ -0,0 +1,837 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * Copyright (c) 2016, Fuzhou Rockchip Electronics Co., Ltd
+ * Author: Lin Huang <hl@rock-chips.com>
+ */
+
+#include <linux/clk.h>
+#include <linux/devfreq-event.h>
+#include <linux/kernel.h>
+#include <linux/err.h>
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/mfd/syscon.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/regmap.h>
+#include <linux/slab.h>
+#include <linux/list.h>
+#include <linux/seqlock.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/bitfield.h>
+#include <linux/bits.h>
+#include <linux/perf_event.h>
+
+#include <soc/rockchip/rockchip_grf.h>
+#include <soc/rockchip/rk3399_grf.h>
+#include <soc/rockchip/rk3568_grf.h>
+#include <soc/rockchip/rk3588_grf.h>
+
+#define DMC_MAX_CHANNELS	4
+
+#define HIWORD_UPDATE(val, mask)	((val) | (mask) << 16)
+
+/* DDRMON_CTRL */
+#define DDRMON_CTRL	0x04
+#define DDRMON_CTRL_DDR4		BIT(5)
+#define DDRMON_CTRL_LPDDR4		BIT(4)
+#define DDRMON_CTRL_HARDWARE_EN		BIT(3)
+#define DDRMON_CTRL_LPDDR23		BIT(2)
+#define DDRMON_CTRL_SOFTWARE_EN		BIT(1)
+#define DDRMON_CTRL_TIMER_CNT_EN	BIT(0)
+#define DDRMON_CTRL_DDR_TYPE_MASK	(DDRMON_CTRL_DDR4 | \
+					 DDRMON_CTRL_LPDDR4 | \
+					 DDRMON_CTRL_LPDDR23)
+
+#define DDRMON_CH0_WR_NUM		0x20
+#define DDRMON_CH0_RD_NUM		0x24
+#define DDRMON_CH0_COUNT_NUM		0x28
+#define DDRMON_CH0_DFI_ACCESS_NUM	0x2c
+#define DDRMON_CH1_COUNT_NUM		0x3c
+#define DDRMON_CH1_DFI_ACCESS_NUM	0x40
+
+#define PERF_EVENT_CYCLES		0x0
+#define PERF_EVENT_READ_BYTES		0x1
+#define PERF_EVENT_WRITE_BYTES		0x2
+#define PERF_EVENT_READ_BYTES0		0x3
+#define PERF_EVENT_WRITE_BYTES0		0x4
+#define PERF_EVENT_READ_BYTES1		0x5
+#define PERF_EVENT_WRITE_BYTES1		0x6
+#define PERF_EVENT_READ_BYTES2		0x7
+#define PERF_EVENT_WRITE_BYTES2		0x8
+#define PERF_EVENT_READ_BYTES3		0x9
+#define PERF_EVENT_WRITE_BYTES3		0xa
+#define PERF_EVENT_BYTES		0xb
+#define PERF_ACCESS_TYPE_MAX		0xc
+
+/**
+ * struct dmc_count_channel - structure to hold counter values from the DDR controller
+ * @access:       Number of read and write accesses
+ * @clock_cycles: DDR clock cycles
+ * @read_access:  number of read accesses
+ * @write_access: number of write accesses
+ */
+struct dmc_count_channel {
+	u64 access;
+	u64 clock_cycles;
+	u64 read_access;
+	u64 write_access;
+};
+
+struct dmc_count {
+	struct dmc_count_channel c[DMC_MAX_CHANNELS];
+};
+
+/*
+ * The dfi controller can monitor DDR load. It has an upper and lower threshold
+ * for the operating points. Whenever the usage leaves these bounds an event is
+ * generated to indicate the DDR frequency should be changed.
+ */
+struct rockchip_dfi {
+	struct devfreq_event_dev *edev;
+	struct devfreq_event_desc desc;
+	struct dmc_count last_event_count;
+
+	struct dmc_count last_perf_count;
+	struct dmc_count total_count;
+	seqlock_t count_seqlock; /* protects last_perf_count and total_count */
+
+	struct device *dev;
+	void __iomem *regs;
+	struct regmap *regmap_pmu;
+	struct clk *clk;
+	int usecount;
+	struct mutex mutex;
+	u32 ddr_type;
+	unsigned int channel_mask;
+	unsigned int max_channels;
+	enum cpuhp_state cpuhp_state;
+	struct hlist_node node;
+	struct pmu pmu;
+	struct hrtimer timer;
+	unsigned int cpu;
+	int active_events;
+	int burst_len;
+	int buswidth[DMC_MAX_CHANNELS];
+	int ddrmon_stride;
+	bool ddrmon_ctrl_single;
+};
+
+static int rockchip_dfi_enable(struct rockchip_dfi *dfi)
+{
+	void __iomem *dfi_regs = dfi->regs;
+	int i, ret = 0;
+
+	mutex_lock(&dfi->mutex);
+
+	dfi->usecount++;
+	if (dfi->usecount > 1)
+		goto out;
+
+	ret = clk_prepare_enable(dfi->clk);
+	if (ret) {
+		dev_err(&dfi->edev->dev, "failed to enable dfi clk: %d\n", ret);
+		goto out;
+	}
+
+	for (i = 0; i < dfi->max_channels; i++) {
+		u32 ctrl = 0;
+
+		if (!(dfi->channel_mask & BIT(i)))
+			continue;
+
+		/* clear DDRMON_CTRL setting */
+		writel_relaxed(HIWORD_UPDATE(0, DDRMON_CTRL_TIMER_CNT_EN |
+			       DDRMON_CTRL_SOFTWARE_EN | DDRMON_CTRL_HARDWARE_EN),
+			       dfi_regs + i * dfi->ddrmon_stride + DDRMON_CTRL);
+
+		/* set ddr type to dfi */
+		switch (dfi->ddr_type) {
+		case ROCKCHIP_DDRTYPE_LPDDR2:
+		case ROCKCHIP_DDRTYPE_LPDDR3:
+			ctrl = DDRMON_CTRL_LPDDR23;
+			break;
+		case ROCKCHIP_DDRTYPE_LPDDR4:
+		case ROCKCHIP_DDRTYPE_LPDDR4X:
+			ctrl = DDRMON_CTRL_LPDDR4;
+			break;
+		default:
+			break;
+		}
+
+		writel_relaxed(HIWORD_UPDATE(ctrl, DDRMON_CTRL_DDR_TYPE_MASK),
+			       dfi_regs + i * dfi->ddrmon_stride + DDRMON_CTRL);
+
+		/* enable count, use software mode */
+		writel_relaxed(HIWORD_UPDATE(DDRMON_CTRL_SOFTWARE_EN, DDRMON_CTRL_SOFTWARE_EN),
+			       dfi_regs + i * dfi->ddrmon_stride + DDRMON_CTRL);
+
+		if (dfi->ddrmon_ctrl_single)
+			break;
+	}
+out:
+	mutex_unlock(&dfi->mutex);
+
+	return ret;
+}
+
+static void rockchip_dfi_disable(struct rockchip_dfi *dfi)
+{
+	void __iomem *dfi_regs = dfi->regs;
+	int i;
+
+	mutex_lock(&dfi->mutex);
+
+	dfi->usecount--;
+
+	WARN_ON_ONCE(dfi->usecount < 0);
+
+	if (dfi->usecount > 0)
+		goto out;
+
+	for (i = 0; i < dfi->max_channels; i++) {
+		if (!(dfi->channel_mask & BIT(i)))
+			continue;
+
+		writel_relaxed(HIWORD_UPDATE(0, DDRMON_CTRL_SOFTWARE_EN),
+			      dfi_regs + i * dfi->ddrmon_stride + DDRMON_CTRL);
+
+		if (dfi->ddrmon_ctrl_single)
+			break;
+	}
+
+	clk_disable_unprepare(dfi->clk);
+out:
+	mutex_unlock(&dfi->mutex);
+}
+
+static void rockchip_dfi_read_counters(struct rockchip_dfi *dfi, struct dmc_count *res)
+{
+	u32 i;
+	void __iomem *dfi_regs = dfi->regs;
+
+	for (i = 0; i < dfi->max_channels; i++) {
+		if (!(dfi->channel_mask & BIT(i)))
+			continue;
+		res->c[i].read_access = readl_relaxed(dfi_regs +
+				DDRMON_CH0_RD_NUM + i * dfi->ddrmon_stride);
+		res->c[i].write_access = readl_relaxed(dfi_regs +
+				DDRMON_CH0_WR_NUM + i * dfi->ddrmon_stride);
+		res->c[i].access = readl_relaxed(dfi_regs +
+				DDRMON_CH0_DFI_ACCESS_NUM + i * dfi->ddrmon_stride);
+		res->c[i].clock_cycles = readl_relaxed(dfi_regs +
+				DDRMON_CH0_COUNT_NUM + i * dfi->ddrmon_stride);
+	}
+}
+
+static int rockchip_dfi_event_disable(struct devfreq_event_dev *edev)
+{
+	struct rockchip_dfi *dfi = devfreq_event_get_drvdata(edev);
+
+	rockchip_dfi_disable(dfi);
+
+	return 0;
+}
+
+static int rockchip_dfi_event_enable(struct devfreq_event_dev *edev)
+{
+	struct rockchip_dfi *dfi = devfreq_event_get_drvdata(edev);
+
+	return rockchip_dfi_enable(dfi);
+}
+
+static int rockchip_dfi_set_event(struct devfreq_event_dev *edev)
+{
+	return 0;
+}
+
+static int rockchip_dfi_get_event(struct devfreq_event_dev *edev,
+				  struct devfreq_event_data *edata)
+{
+	struct rockchip_dfi *dfi = devfreq_event_get_drvdata(edev);
+	struct dmc_count count;
+	struct dmc_count *last = &dfi->last_event_count;
+	u32 access = 0, clock_cycles = 0;
+	int i;
+
+	rockchip_dfi_read_counters(dfi, &count);
+
+	/* We can only report one channel, so find the busiest one */
+	for (i = 0; i < dfi->max_channels; i++) {
+		u32 a, c;
+
+		if (!(dfi->channel_mask & BIT(i)))
+			continue;
+
+		a = count.c[i].access - last->c[i].access;
+		c = count.c[i].clock_cycles - last->c[i].clock_cycles;
+
+		if (a > access) {
+			access = a;
+			clock_cycles = c;
+		}
+	}
+
+	edata->load_count = access * 4;
+	edata->total_count = clock_cycles;
+
+	dfi->last_event_count = count;
+
+	return 0;
+}
+
+static const struct devfreq_event_ops rockchip_dfi_ops = {
+	.disable = rockchip_dfi_event_disable,
+	.enable = rockchip_dfi_event_enable,
+	.get_event = rockchip_dfi_get_event,
+	.set_event = rockchip_dfi_set_event,
+};
+
+#ifdef CONFIG_PERF_EVENTS
+
+static void rockchip_ddr_perf_counters_add(struct rockchip_dfi *dfi,
+					   const struct dmc_count *now,
+					   struct dmc_count *res)
+{
+	const struct dmc_count *last = &dfi->last_perf_count;
+	int i;
+
+	for (i = 0; i < dfi->max_channels; i++) {
+		res->c[i].read_access = dfi->total_count.c[i].read_access +
+			(u32)(now->c[i].read_access - last->c[i].read_access);
+		res->c[i].write_access = dfi->total_count.c[i].write_access +
+			(u32)(now->c[i].write_access - last->c[i].write_access);
+		res->c[i].access = dfi->total_count.c[i].access +
+			(u32)(now->c[i].access - last->c[i].access);
+		res->c[i].clock_cycles = dfi->total_count.c[i].clock_cycles +
+			(u32)(now->c[i].clock_cycles - last->c[i].clock_cycles);
+	}
+}
+
+static ssize_t ddr_perf_cpumask_show(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	struct pmu *pmu = dev_get_drvdata(dev);
+	struct rockchip_dfi *dfi = container_of(pmu, struct rockchip_dfi, pmu);
+
+	return cpumap_print_to_pagebuf(true, buf, cpumask_of(dfi->cpu));
+}
+
+static struct device_attribute ddr_perf_cpumask_attr =
+	__ATTR(cpumask, 0444, ddr_perf_cpumask_show, NULL);
+
+static struct attribute *ddr_perf_cpumask_attrs[] = {
+	&ddr_perf_cpumask_attr.attr,
+	NULL,
+};
+
+static const struct attribute_group ddr_perf_cpumask_attr_group = {
+	.attrs = ddr_perf_cpumask_attrs,
+};
+
+PMU_EVENT_ATTR_STRING(cycles, ddr_pmu_cycles, "event="__stringify(PERF_EVENT_CYCLES))
+
+#define DFI_PMU_EVENT_ATTR(_name, _var, _str) \
+	PMU_EVENT_ATTR_STRING(_name, _var, _str); \
+	PMU_EVENT_ATTR_STRING(_name.unit, _var##_unit, "MB"); \
+	PMU_EVENT_ATTR_STRING(_name.scale, _var##_scale, "9.536743164e-07")
+
+DFI_PMU_EVENT_ATTR(read-bytes0, ddr_pmu_read_bytes0, "event="__stringify(PERF_EVENT_READ_BYTES0));
+DFI_PMU_EVENT_ATTR(write-bytes0, ddr_pmu_write_bytes0, "event="__stringify(PERF_EVENT_WRITE_BYTES0));
+
+DFI_PMU_EVENT_ATTR(read-bytes1, ddr_pmu_read_bytes1, "event="__stringify(PERF_EVENT_READ_BYTES1));
+DFI_PMU_EVENT_ATTR(write-bytes1, ddr_pmu_write_bytes1, "event="__stringify(PERF_EVENT_WRITE_BYTES1));
+
+DFI_PMU_EVENT_ATTR(read-bytes2, ddr_pmu_read_bytes2, "event="__stringify(PERF_EVENT_READ_BYTES2));
+DFI_PMU_EVENT_ATTR(write-bytes2, ddr_pmu_write_bytes2, "event="__stringify(PERF_EVENT_WRITE_BYTES2));
+
+DFI_PMU_EVENT_ATTR(read-bytes3, ddr_pmu_read_bytes3, "event="__stringify(PERF_EVENT_READ_BYTES3));
+DFI_PMU_EVENT_ATTR(write-bytes3, ddr_pmu_write_bytes3, "event="__stringify(PERF_EVENT_WRITE_BYTES3));
+
+DFI_PMU_EVENT_ATTR(read-bytes, ddr_pmu_read_bytes, "event="__stringify(PERF_EVENT_READ_BYTES));
+DFI_PMU_EVENT_ATTR(write-bytes, ddr_pmu_write_bytes, "event="__stringify(PERF_EVENT_WRITE_BYTES));
+
+DFI_PMU_EVENT_ATTR(bytes, ddr_pmu_bytes, "event="__stringify(PERF_EVENT_BYTES));
+
+#define DFI_ATTR_MB(_name) 		\
+	&_name.attr.attr,		\
+	&_name##_unit.attr.attr,	\
+	&_name##_scale.attr.attr
+
+static struct attribute *ddr_perf_events_attrs[] = {
+	&ddr_pmu_cycles.attr.attr,
+	DFI_ATTR_MB(ddr_pmu_read_bytes),
+	DFI_ATTR_MB(ddr_pmu_write_bytes),
+	DFI_ATTR_MB(ddr_pmu_read_bytes0),
+	DFI_ATTR_MB(ddr_pmu_write_bytes0),
+	DFI_ATTR_MB(ddr_pmu_read_bytes1),
+	DFI_ATTR_MB(ddr_pmu_write_bytes1),
+	DFI_ATTR_MB(ddr_pmu_read_bytes2),
+	DFI_ATTR_MB(ddr_pmu_write_bytes2),
+	DFI_ATTR_MB(ddr_pmu_read_bytes3),
+	DFI_ATTR_MB(ddr_pmu_write_bytes3),
+	DFI_ATTR_MB(ddr_pmu_bytes),
+	NULL,
+};
+
+static const struct attribute_group ddr_perf_events_attr_group = {
+	.name = "events",
+	.attrs = ddr_perf_events_attrs,
+};
+
+PMU_FORMAT_ATTR(event, "config:0-7");
+
+static struct attribute *ddr_perf_format_attrs[] = {
+	&format_attr_event.attr,
+	NULL,
+};
+
+static const struct attribute_group ddr_perf_format_attr_group = {
+	.name = "format",
+	.attrs = ddr_perf_format_attrs,
+};
+
+static const struct attribute_group *attr_groups[] = {
+	&ddr_perf_events_attr_group,
+	&ddr_perf_cpumask_attr_group,
+	&ddr_perf_format_attr_group,
+	NULL,
+};
+
+static int rockchip_ddr_perf_event_init(struct perf_event *event)
+{
+	struct rockchip_dfi *dfi = container_of(event->pmu, struct rockchip_dfi, pmu);
+
+	if (event->attr.type != event->pmu->type)
+		return -ENOENT;
+
+	if (event->attach_state & PERF_ATTACH_TASK)
+		return -EINVAL;
+
+	if (event->cpu < 0) {
+		dev_warn(dfi->dev, "Can't provide per-task data!\n");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static u64 rockchip_ddr_perf_event_get_count(struct perf_event *event)
+{
+	struct rockchip_dfi *dfi = container_of(event->pmu, struct rockchip_dfi, pmu);
+	int blen = dfi->burst_len;
+	struct dmc_count total, now;
+	unsigned int seq;
+	u64 count = 0;
+	int i;
+
+	rockchip_dfi_read_counters(dfi, &now);
+
+	do {
+		seq = read_seqbegin(&dfi->count_seqlock);
+		rockchip_ddr_perf_counters_add(dfi, &now, &total);
+	} while (read_seqretry(&dfi->count_seqlock, seq));
+
+	switch (event->attr.config) {
+	case PERF_EVENT_CYCLES:
+		count = total.c[0].clock_cycles;
+		break;
+	case PERF_EVENT_READ_BYTES:
+		for (i = 0; i < dfi->max_channels; i++)
+			count += total.c[i].read_access * blen * dfi->buswidth[i];
+		break;
+	case PERF_EVENT_WRITE_BYTES:
+		for (i = 0; i < dfi->max_channels; i++)
+			count += total.c[i].write_access * blen * dfi->buswidth[i];
+		break;
+	case PERF_EVENT_READ_BYTES0:
+		count = total.c[0].read_access * blen * dfi->buswidth[0];
+		break;
+	case PERF_EVENT_WRITE_BYTES0:
+		count = total.c[0].write_access * blen * dfi->buswidth[0];
+		break;
+	case PERF_EVENT_READ_BYTES1:
+		count = total.c[1].read_access * blen * dfi->buswidth[1];
+		break;
+	case PERF_EVENT_WRITE_BYTES1:
+		count = total.c[1].write_access * blen * dfi->buswidth[1];
+		break;
+	case PERF_EVENT_READ_BYTES2:
+		count = total.c[2].read_access * blen * dfi->buswidth[2];
+		break;
+	case PERF_EVENT_WRITE_BYTES2:
+		count = total.c[2].write_access * blen * dfi->buswidth[2];
+		break;
+	case PERF_EVENT_READ_BYTES3:
+		count = total.c[3].read_access * blen * dfi->buswidth[3];
+		break;
+	case PERF_EVENT_WRITE_BYTES3:
+		count = total.c[3].write_access * blen * dfi->buswidth[3];
+		break;
+	case PERF_EVENT_BYTES:
+		for (i = 0; i < dfi->max_channels; i++)
+			count += total.c[i].access * blen * dfi->buswidth[i];
+		break;
+	}
+
+	return count;
+}
+
+static void rockchip_ddr_perf_event_update(struct perf_event *event)
+{
+	u64 now;
+	s64 prev;
+
+	if (event->attr.config >= PERF_ACCESS_TYPE_MAX)
+		return;
+
+	now = rockchip_ddr_perf_event_get_count(event);
+	prev = local64_xchg(&event->hw.prev_count, now);
+	local64_add(now - prev, &event->count);
+}
+
+static void rockchip_ddr_perf_event_start(struct perf_event *event, int flags)
+{
+	u64 now = rockchip_ddr_perf_event_get_count(event);
+
+	local64_set(&event->hw.prev_count, now);
+}
+
+static int rockchip_ddr_perf_event_add(struct perf_event *event, int flags)
+{
+	struct rockchip_dfi *dfi = container_of(event->pmu, struct rockchip_dfi, pmu);
+
+	dfi->active_events++;
+
+	if (dfi->active_events == 1) {
+		dfi->total_count = (struct dmc_count){};
+		rockchip_dfi_read_counters(dfi, &dfi->last_perf_count);
+		hrtimer_start(&dfi->timer, ns_to_ktime(NSEC_PER_SEC), HRTIMER_MODE_REL);
+	}
+
+	if (flags & PERF_EF_START)
+		rockchip_ddr_perf_event_start(event, flags);
+
+	return 0;
+}
+
+static void rockchip_ddr_perf_event_stop(struct perf_event *event, int flags)
+{
+	rockchip_ddr_perf_event_update(event);
+}
+
+static void rockchip_ddr_perf_event_del(struct perf_event *event, int flags)
+{
+	struct rockchip_dfi *dfi = container_of(event->pmu, struct rockchip_dfi, pmu);
+
+	rockchip_ddr_perf_event_stop(event, PERF_EF_UPDATE);
+
+	dfi->active_events--;
+
+	if (dfi->active_events == 0)
+		hrtimer_cancel(&dfi->timer);
+}
+
+static enum hrtimer_restart rockchip_dfi_timer(struct hrtimer *timer)
+{
+	struct rockchip_dfi *dfi = container_of(timer, struct rockchip_dfi, timer);
+	struct dmc_count now, total;
+
+	rockchip_dfi_read_counters(dfi, &now);
+
+	write_seqlock(&dfi->count_seqlock);
+
+	rockchip_ddr_perf_counters_add(dfi, &now, &total);
+	dfi->total_count = total;
+	dfi->last_perf_count = now;
+
+	write_sequnlock(&dfi->count_seqlock);
+
+	hrtimer_forward_now(&dfi->timer, ns_to_ktime(NSEC_PER_SEC));
+
+	return HRTIMER_RESTART;
+};
+
+static int ddr_perf_offline_cpu(unsigned int cpu, struct hlist_node *node)
+{
+	struct rockchip_dfi *dfi = hlist_entry_safe(node, struct rockchip_dfi, node);
+	int target;
+
+	if (cpu != dfi->cpu)
+		return 0;
+
+	target = cpumask_any_but(cpu_online_mask, cpu);
+	if (target >= nr_cpu_ids)
+		return 0;
+
+	perf_pmu_migrate_context(&dfi->pmu, cpu, target);
+	dfi->cpu = target;
+
+	return 0;
+}
+
+static void rockchip_ddr_cpuhp_remove_state(void *data)
+{
+	struct rockchip_dfi *dfi = data;
+
+	cpuhp_remove_multi_state(dfi->cpuhp_state);
+
+	rockchip_dfi_disable(dfi);
+}
+
+static void rockchip_ddr_cpuhp_remove_instance(void *data)
+{
+	struct rockchip_dfi *dfi = data;
+
+	cpuhp_state_remove_instance_nocalls(dfi->cpuhp_state, &dfi->node);
+}
+
+static void rockchip_ddr_perf_remove(void *data)
+{
+	struct rockchip_dfi *dfi = data;
+
+	perf_pmu_unregister(&dfi->pmu);
+}
+
+static int rockchip_ddr_perf_init(struct rockchip_dfi *dfi)
+{
+	struct pmu *pmu = &dfi->pmu;
+	int ret;
+
+	seqlock_init(&dfi->count_seqlock);
+
+	pmu->module = THIS_MODULE;
+	pmu->capabilities = PERF_PMU_CAP_NO_EXCLUDE;
+	pmu->task_ctx_nr = perf_invalid_context;
+	pmu->attr_groups = attr_groups;
+	pmu->event_init  = rockchip_ddr_perf_event_init;
+	pmu->add = rockchip_ddr_perf_event_add;
+	pmu->del = rockchip_ddr_perf_event_del;
+	pmu->start = rockchip_ddr_perf_event_start;
+	pmu->stop = rockchip_ddr_perf_event_stop;
+	pmu->read = rockchip_ddr_perf_event_update;
+
+	dfi->cpu = raw_smp_processor_id();
+
+	ret = cpuhp_setup_state_multi(CPUHP_AP_ONLINE_DYN,
+				      "rockchip_ddr_perf_pmu",
+				      NULL,
+				      ddr_perf_offline_cpu);
+
+	if (ret < 0) {
+		dev_err(dfi->dev, "cpuhp_setup_state_multi failed: %d\n", ret);
+		return ret;
+	}
+
+	dfi->cpuhp_state = ret;
+
+	rockchip_dfi_enable(dfi);
+
+	ret = devm_add_action_or_reset(dfi->dev, rockchip_ddr_cpuhp_remove_state, dfi);
+	if (ret)
+		return ret;
+
+	ret = cpuhp_state_add_instance_nocalls(dfi->cpuhp_state, &dfi->node);
+	if (ret) {
+		dev_err(dfi->dev, "Error %d registering hotplug\n", ret);
+		return ret;
+	}
+
+	ret = devm_add_action_or_reset(dfi->dev, rockchip_ddr_cpuhp_remove_instance, dfi);
+	if (ret)
+		return ret;
+
+	hrtimer_setup(&dfi->timer, rockchip_dfi_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
+
+	switch (dfi->ddr_type) {
+	case ROCKCHIP_DDRTYPE_LPDDR2:
+	case ROCKCHIP_DDRTYPE_LPDDR3:
+		dfi->burst_len = 8;
+		break;
+	case ROCKCHIP_DDRTYPE_LPDDR4:
+	case ROCKCHIP_DDRTYPE_LPDDR4X:
+		dfi->burst_len = 16;
+		break;
+	}
+
+	ret = perf_pmu_register(pmu, "rockchip_ddr", -1);
+	if (ret)
+		return ret;
+
+	return devm_add_action_or_reset(dfi->dev, rockchip_ddr_perf_remove, dfi);
+}
+#else
+static int rockchip_ddr_perf_init(struct rockchip_dfi *dfi)
+{
+	return 0;
+}
+#endif
+
+static int rk3399_dfi_init(struct rockchip_dfi *dfi)
+{
+	struct regmap *regmap_pmu = dfi->regmap_pmu;
+	u32 val;
+
+	dfi->clk = devm_clk_get(dfi->dev, "pclk_ddr_mon");
+	if (IS_ERR(dfi->clk))
+		return dev_err_probe(dfi->dev, PTR_ERR(dfi->clk),
+				     "Cannot get the clk pclk_ddr_mon\n");
+
+	/* get ddr type */
+	regmap_read(regmap_pmu, RK3399_PMUGRF_OS_REG2, &val);
+	dfi->ddr_type = FIELD_GET(RK3399_PMUGRF_OS_REG2_DDRTYPE, val);
+
+	dfi->channel_mask = GENMASK(1, 0);
+	dfi->max_channels = 2;
+
+	dfi->buswidth[0] = FIELD_GET(RK3399_PMUGRF_OS_REG2_BW_CH0, val) == 0 ? 4 : 2;
+	dfi->buswidth[1] = FIELD_GET(RK3399_PMUGRF_OS_REG2_BW_CH1, val) == 0 ? 4 : 2;
+
+	dfi->ddrmon_stride = 0x14;
+	dfi->ddrmon_ctrl_single = true;
+
+	return 0;
+};
+
+static int rk3568_dfi_init(struct rockchip_dfi *dfi)
+{
+	struct regmap *regmap_pmu = dfi->regmap_pmu;
+	u32 reg2, reg3;
+
+	regmap_read(regmap_pmu, RK3568_PMUGRF_OS_REG2, &reg2);
+	regmap_read(regmap_pmu, RK3568_PMUGRF_OS_REG3, &reg3);
+
+	/* lower 3 bits of the DDR type */
+	dfi->ddr_type = FIELD_GET(RK3568_PMUGRF_OS_REG2_DRAMTYPE_INFO, reg2);
+
+	/*
+	 * For version three and higher the upper two bits of the DDR type are
+	 * in RK3568_PMUGRF_OS_REG3
+	 */
+	if (FIELD_GET(RK3568_PMUGRF_OS_REG3_SYSREG_VERSION, reg3) >= 0x3)
+		dfi->ddr_type |= FIELD_GET(RK3568_PMUGRF_OS_REG3_DRAMTYPE_INFO_V3, reg3) << 3;
+
+	dfi->channel_mask = BIT(0);
+	dfi->max_channels = 1;
+
+	dfi->buswidth[0] = FIELD_GET(RK3568_PMUGRF_OS_REG2_BW_CH0, reg2) == 0 ? 4 : 2;
+
+	dfi->ddrmon_stride = 0x0; /* not relevant, we only have a single channel on this SoC */
+	dfi->ddrmon_ctrl_single = true;
+
+	return 0;
+};
+
+static int rk3588_dfi_init(struct rockchip_dfi *dfi)
+{
+	struct regmap *regmap_pmu = dfi->regmap_pmu;
+	u32 reg2, reg3, reg4;
+
+	regmap_read(regmap_pmu, RK3588_PMUGRF_OS_REG2, &reg2);
+	regmap_read(regmap_pmu, RK3588_PMUGRF_OS_REG3, &reg3);
+	regmap_read(regmap_pmu, RK3588_PMUGRF_OS_REG4, &reg4);
+
+	/* lower 3 bits of the DDR type */
+	dfi->ddr_type = FIELD_GET(RK3588_PMUGRF_OS_REG2_DRAMTYPE_INFO, reg2);
+
+	/*
+	 * For version three and higher the upper two bits of the DDR type are
+	 * in RK3588_PMUGRF_OS_REG3
+	 */
+	if (FIELD_GET(RK3588_PMUGRF_OS_REG3_SYSREG_VERSION, reg3) >= 0x3)
+		dfi->ddr_type |= FIELD_GET(RK3588_PMUGRF_OS_REG3_DRAMTYPE_INFO_V3, reg3) << 3;
+
+	dfi->buswidth[0] = FIELD_GET(RK3588_PMUGRF_OS_REG2_BW_CH0, reg2) == 0 ? 4 : 2;
+	dfi->buswidth[1] = FIELD_GET(RK3588_PMUGRF_OS_REG2_BW_CH1, reg2) == 0 ? 4 : 2;
+	dfi->buswidth[2] = FIELD_GET(RK3568_PMUGRF_OS_REG2_BW_CH0, reg4) == 0 ? 4 : 2;
+	dfi->buswidth[3] = FIELD_GET(RK3588_PMUGRF_OS_REG2_BW_CH1, reg4) == 0 ? 4 : 2;
+	dfi->channel_mask = FIELD_GET(RK3588_PMUGRF_OS_REG2_CH_INFO, reg2) |
+			    FIELD_GET(RK3588_PMUGRF_OS_REG2_CH_INFO, reg4) << 2;
+	dfi->max_channels = 4;
+
+	dfi->ddrmon_stride = 0x4000;
+
+	return 0;
+};
+
+static const struct of_device_id rockchip_dfi_id_match[] = {
+	{ .compatible = "rockchip,rk3399-dfi", .data = rk3399_dfi_init },
+	{ .compatible = "rockchip,rk3568-dfi", .data = rk3568_dfi_init },
+	{ .compatible = "rockchip,rk3588-dfi", .data = rk3588_dfi_init },
+	{ },
+};
+
+MODULE_DEVICE_TABLE(of, rockchip_dfi_id_match);
+
+static int rockchip_dfi_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct rockchip_dfi *dfi;
+	struct devfreq_event_desc *desc;
+	struct device_node *np = pdev->dev.of_node, *node;
+	int (*soc_init)(struct rockchip_dfi *dfi);
+	int ret;
+
+	soc_init = of_device_get_match_data(&pdev->dev);
+	if (!soc_init)
+		return -EINVAL;
+
+	dfi = devm_kzalloc(dev, sizeof(*dfi), GFP_KERNEL);
+	if (!dfi)
+		return -ENOMEM;
+
+	dfi->regs = devm_platform_ioremap_resource(pdev, 0);
+	if (IS_ERR(dfi->regs))
+		return PTR_ERR(dfi->regs);
+
+	node = of_parse_phandle(np, "rockchip,pmu", 0);
+	if (!node)
+		return dev_err_probe(&pdev->dev, -ENODEV, "Can't find pmu_grf registers\n");
+
+	dfi->regmap_pmu = syscon_node_to_regmap(node);
+	of_node_put(node);
+	if (IS_ERR(dfi->regmap_pmu))
+		return PTR_ERR(dfi->regmap_pmu);
+
+	dfi->dev = dev;
+	mutex_init(&dfi->mutex);
+
+	desc = &dfi->desc;
+	desc->ops = &rockchip_dfi_ops;
+	desc->driver_data = dfi;
+	desc->name = np->name;
+
+	ret = soc_init(dfi);
+	if (ret)
+		return ret;
+
+	dfi->edev = devm_devfreq_event_add_edev(&pdev->dev, desc);
+	if (IS_ERR(dfi->edev)) {
+		dev_err(&pdev->dev,
+			"failed to add devfreq-event device\n");
+		return PTR_ERR(dfi->edev);
+	}
+
+	ret = rockchip_ddr_perf_init(dfi);
+	if (ret)
+		return ret;
+
+	platform_set_drvdata(pdev, dfi);
+
+	return 0;
+}
+
+static struct platform_driver rockchip_dfi_driver = {
+	.probe	= rockchip_dfi_probe,
+	.driver = {
+		.name	= "rockchip-dfi",
+		.of_match_table = rockchip_dfi_id_match,
+		.suppress_bind_attrs = true,
+	},
+};
+module_platform_driver(rockchip_dfi_driver);
+
+MODULE_LICENSE("GPL v2");
+MODULE_AUTHOR("Lin Huang <hl@rock-chips.com>");
+MODULE_DESCRIPTION("Rockchip DFI driver");
diff --git a/drivers/devfreq/rk3328_dmc.c b/drivers/devfreq/rk3328_dmc.c
new file mode 100644
index 000000000000..367694a3b5d1
--- /dev/null
+++ b/drivers/devfreq/rk3328_dmc.c
@@ -0,0 +1,836 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * Copyright (c) 2016, Fuzhou Rockchip Electronics Co., Ltd.
+ * Author: Lin Huang <hl@rock-chips.com>
+ */
+
+#include <linux/arm-smccc.h>
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/devfreq.h>
+#include <linux/devfreq-event.h>
+#include <linux/devfreq_cooling.h>
+#include <linux/interrupt.h>
+#include <linux/mfd/syscon.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/platform_device.h>
+#include <linux/pm_opp.h>
+#include <linux/regmap.h>
+#include <linux/regulator/consumer.h>
+#include <linux/rwsem.h>
+#include <linux/suspend.h>
+
+#include <soc/rockchip/rockchip_sip.h>
+
+#define DTS_PAR_OFFSET		(4096)
+
+struct share_params {
+	u32 hz;
+	u32 lcdc_type;
+	u32 vop;
+	u32 vop_dclk_mode;
+	u32 sr_idle_en;
+	u32 addr_mcu_el3;
+	/*
+	 * 1: need to wait flag1
+	 * 0: never wait flag1
+	 */
+	u32 wait_flag1;
+	/*
+	 * 1: need to wait flag1
+	 * 0: never wait flag1
+	 */
+	u32 wait_flag0;
+	u32 complt_hwirq;
+	/* if need, add parameter after */
+};
+
+static struct share_params *ddr_psci_param;
+
+/* hope this define can adapt all future platform */
+static const char * const rk3328_dts_timing[] = {
+	"ddr3_speed_bin",
+	"ddr4_speed_bin",
+	"pd_idle",
+	"sr_idle",
+	"sr_mc_gate_idle",
+	"srpd_lite_idle",
+	"standby_idle",
+
+	"auto_pd_dis_freq",
+	"auto_sr_dis_freq",
+	"ddr3_dll_dis_freq",
+	"ddr4_dll_dis_freq",
+	"phy_dll_dis_freq",
+
+	"ddr3_odt_dis_freq",
+	"phy_ddr3_odt_dis_freq",
+	"ddr3_drv",
+	"ddr3_odt",
+	"phy_ddr3_ca_drv",
+	"phy_ddr3_ck_drv",
+	"phy_ddr3_dq_drv",
+	"phy_ddr3_odt",
+
+	"lpddr3_odt_dis_freq",
+	"phy_lpddr3_odt_dis_freq",
+	"lpddr3_drv",
+	"lpddr3_odt",
+	"phy_lpddr3_ca_drv",
+	"phy_lpddr3_ck_drv",
+	"phy_lpddr3_dq_drv",
+	"phy_lpddr3_odt",
+
+	"lpddr4_odt_dis_freq",
+	"phy_lpddr4_odt_dis_freq",
+	"lpddr4_drv",
+	"lpddr4_dq_odt",
+	"lpddr4_ca_odt",
+	"phy_lpddr4_ca_drv",
+	"phy_lpddr4_ck_cs_drv",
+	"phy_lpddr4_dq_drv",
+	"phy_lpddr4_odt",
+
+	"ddr4_odt_dis_freq",
+	"phy_ddr4_odt_dis_freq",
+	"ddr4_drv",
+	"ddr4_odt",
+	"phy_ddr4_ca_drv",
+	"phy_ddr4_ck_drv",
+	"phy_ddr4_dq_drv",
+	"phy_ddr4_odt",
+};
+
+static const char * const rk3328_dts_ca_timing[] = {
+	"ddr3a1_ddr4a9_de-skew",
+	"ddr3a0_ddr4a10_de-skew",
+	"ddr3a3_ddr4a6_de-skew",
+	"ddr3a2_ddr4a4_de-skew",
+	"ddr3a5_ddr4a8_de-skew",
+	"ddr3a4_ddr4a5_de-skew",
+	"ddr3a7_ddr4a11_de-skew",
+	"ddr3a6_ddr4a7_de-skew",
+	"ddr3a9_ddr4a0_de-skew",
+	"ddr3a8_ddr4a13_de-skew",
+	"ddr3a11_ddr4a3_de-skew",
+	"ddr3a10_ddr4cs0_de-skew",
+	"ddr3a13_ddr4a2_de-skew",
+	"ddr3a12_ddr4ba1_de-skew",
+	"ddr3a15_ddr4odt0_de-skew",
+	"ddr3a14_ddr4a1_de-skew",
+	"ddr3ba1_ddr4a15_de-skew",
+	"ddr3ba0_ddr4bg0_de-skew",
+	"ddr3ras_ddr4cke_de-skew",
+	"ddr3ba2_ddr4ba0_de-skew",
+	"ddr3we_ddr4bg1_de-skew",
+	"ddr3cas_ddr4a12_de-skew",
+	"ddr3ckn_ddr4ckn_de-skew",
+	"ddr3ckp_ddr4ckp_de-skew",
+	"ddr3cke_ddr4a16_de-skew",
+	"ddr3odt0_ddr4a14_de-skew",
+	"ddr3cs0_ddr4act_de-skew",
+	"ddr3reset_ddr4reset_de-skew",
+	"ddr3cs1_ddr4cs1_de-skew",
+	"ddr3odt1_ddr4odt1_de-skew",
+};
+
+static const char * const rk3328_dts_cs0_timing[] = {
+	"cs0_dm0_rx_de-skew",
+	"cs0_dm0_tx_de-skew",
+	"cs0_dq0_rx_de-skew",
+	"cs0_dq0_tx_de-skew",
+	"cs0_dq1_rx_de-skew",
+	"cs0_dq1_tx_de-skew",
+	"cs0_dq2_rx_de-skew",
+	"cs0_dq2_tx_de-skew",
+	"cs0_dq3_rx_de-skew",
+	"cs0_dq3_tx_de-skew",
+	"cs0_dq4_rx_de-skew",
+	"cs0_dq4_tx_de-skew",
+	"cs0_dq5_rx_de-skew",
+	"cs0_dq5_tx_de-skew",
+	"cs0_dq6_rx_de-skew",
+	"cs0_dq6_tx_de-skew",
+	"cs0_dq7_rx_de-skew",
+	"cs0_dq7_tx_de-skew",
+	"cs0_dqs0_rx_de-skew",
+	"cs0_dqs0p_tx_de-skew",
+	"cs0_dqs0n_tx_de-skew",
+
+	"cs0_dm1_rx_de-skew",
+	"cs0_dm1_tx_de-skew",
+	"cs0_dq8_rx_de-skew",
+	"cs0_dq8_tx_de-skew",
+	"cs0_dq9_rx_de-skew",
+	"cs0_dq9_tx_de-skew",
+	"cs0_dq10_rx_de-skew",
+	"cs0_dq10_tx_de-skew",
+	"cs0_dq11_rx_de-skew",
+	"cs0_dq11_tx_de-skew",
+	"cs0_dq12_rx_de-skew",
+	"cs0_dq12_tx_de-skew",
+	"cs0_dq13_rx_de-skew",
+	"cs0_dq13_tx_de-skew",
+	"cs0_dq14_rx_de-skew",
+	"cs0_dq14_tx_de-skew",
+	"cs0_dq15_rx_de-skew",
+	"cs0_dq15_tx_de-skew",
+	"cs0_dqs1_rx_de-skew",
+	"cs0_dqs1p_tx_de-skew",
+	"cs0_dqs1n_tx_de-skew",
+
+	"cs0_dm2_rx_de-skew",
+	"cs0_dm2_tx_de-skew",
+	"cs0_dq16_rx_de-skew",
+	"cs0_dq16_tx_de-skew",
+	"cs0_dq17_rx_de-skew",
+	"cs0_dq17_tx_de-skew",
+	"cs0_dq18_rx_de-skew",
+	"cs0_dq18_tx_de-skew",
+	"cs0_dq19_rx_de-skew",
+	"cs0_dq19_tx_de-skew",
+	"cs0_dq20_rx_de-skew",
+	"cs0_dq20_tx_de-skew",
+	"cs0_dq21_rx_de-skew",
+	"cs0_dq21_tx_de-skew",
+	"cs0_dq22_rx_de-skew",
+	"cs0_dq22_tx_de-skew",
+	"cs0_dq23_rx_de-skew",
+	"cs0_dq23_tx_de-skew",
+	"cs0_dqs2_rx_de-skew",
+	"cs0_dqs2p_tx_de-skew",
+	"cs0_dqs2n_tx_de-skew",
+
+	"cs0_dm3_rx_de-skew",
+	"cs0_dm3_tx_de-skew",
+	"cs0_dq24_rx_de-skew",
+	"cs0_dq24_tx_de-skew",
+	"cs0_dq25_rx_de-skew",
+	"cs0_dq25_tx_de-skew",
+	"cs0_dq26_rx_de-skew",
+	"cs0_dq26_tx_de-skew",
+	"cs0_dq27_rx_de-skew",
+	"cs0_dq27_tx_de-skew",
+	"cs0_dq28_rx_de-skew",
+	"cs0_dq28_tx_de-skew",
+	"cs0_dq29_rx_de-skew",
+	"cs0_dq29_tx_de-skew",
+	"cs0_dq30_rx_de-skew",
+	"cs0_dq30_tx_de-skew",
+	"cs0_dq31_rx_de-skew",
+	"cs0_dq31_tx_de-skew",
+	"cs0_dqs3_rx_de-skew",
+	"cs0_dqs3p_tx_de-skew",
+	"cs0_dqs3n_tx_de-skew",
+};
+
+static const char * const rk3328_dts_cs1_timing[] = {
+	"cs1_dm0_rx_de-skew",
+	"cs1_dm0_tx_de-skew",
+	"cs1_dq0_rx_de-skew",
+	"cs1_dq0_tx_de-skew",
+	"cs1_dq1_rx_de-skew",
+	"cs1_dq1_tx_de-skew",
+	"cs1_dq2_rx_de-skew",
+	"cs1_dq2_tx_de-skew",
+	"cs1_dq3_rx_de-skew",
+	"cs1_dq3_tx_de-skew",
+	"cs1_dq4_rx_de-skew",
+	"cs1_dq4_tx_de-skew",
+	"cs1_dq5_rx_de-skew",
+	"cs1_dq5_tx_de-skew",
+	"cs1_dq6_rx_de-skew",
+	"cs1_dq6_tx_de-skew",
+	"cs1_dq7_rx_de-skew",
+	"cs1_dq7_tx_de-skew",
+	"cs1_dqs0_rx_de-skew",
+	"cs1_dqs0p_tx_de-skew",
+	"cs1_dqs0n_tx_de-skew",
+
+	"cs1_dm1_rx_de-skew",
+	"cs1_dm1_tx_de-skew",
+	"cs1_dq8_rx_de-skew",
+	"cs1_dq8_tx_de-skew",
+	"cs1_dq9_rx_de-skew",
+	"cs1_dq9_tx_de-skew",
+	"cs1_dq10_rx_de-skew",
+	"cs1_dq10_tx_de-skew",
+	"cs1_dq11_rx_de-skew",
+	"cs1_dq11_tx_de-skew",
+	"cs1_dq12_rx_de-skew",
+	"cs1_dq12_tx_de-skew",
+	"cs1_dq13_rx_de-skew",
+	"cs1_dq13_tx_de-skew",
+	"cs1_dq14_rx_de-skew",
+	"cs1_dq14_tx_de-skew",
+	"cs1_dq15_rx_de-skew",
+	"cs1_dq15_tx_de-skew",
+	"cs1_dqs1_rx_de-skew",
+	"cs1_dqs1p_tx_de-skew",
+	"cs1_dqs1n_tx_de-skew",
+
+	"cs1_dm2_rx_de-skew",
+	"cs1_dm2_tx_de-skew",
+	"cs1_dq16_rx_de-skew",
+	"cs1_dq16_tx_de-skew",
+	"cs1_dq17_rx_de-skew",
+	"cs1_dq17_tx_de-skew",
+	"cs1_dq18_rx_de-skew",
+	"cs1_dq18_tx_de-skew",
+	"cs1_dq19_rx_de-skew",
+	"cs1_dq19_tx_de-skew",
+	"cs1_dq20_rx_de-skew",
+	"cs1_dq20_tx_de-skew",
+	"cs1_dq21_rx_de-skew",
+	"cs1_dq21_tx_de-skew",
+	"cs1_dq22_rx_de-skew",
+	"cs1_dq22_tx_de-skew",
+	"cs1_dq23_rx_de-skew",
+	"cs1_dq23_tx_de-skew",
+	"cs1_dqs2_rx_de-skew",
+	"cs1_dqs2p_tx_de-skew",
+	"cs1_dqs2n_tx_de-skew",
+
+	"cs1_dm3_rx_de-skew",
+	"cs1_dm3_tx_de-skew",
+	"cs1_dq24_rx_de-skew",
+	"cs1_dq24_tx_de-skew",
+	"cs1_dq25_rx_de-skew",
+	"cs1_dq25_tx_de-skew",
+	"cs1_dq26_rx_de-skew",
+	"cs1_dq26_tx_de-skew",
+	"cs1_dq27_rx_de-skew",
+	"cs1_dq27_tx_de-skew",
+	"cs1_dq28_rx_de-skew",
+	"cs1_dq28_tx_de-skew",
+	"cs1_dq29_rx_de-skew",
+	"cs1_dq29_tx_de-skew",
+	"cs1_dq30_rx_de-skew",
+	"cs1_dq30_tx_de-skew",
+	"cs1_dq31_rx_de-skew",
+	"cs1_dq31_tx_de-skew",
+	"cs1_dqs3_rx_de-skew",
+	"cs1_dqs3p_tx_de-skew",
+	"cs1_dqs3n_tx_de-skew",
+};
+
+struct rk3328_ddr_dts_config_timing {
+	unsigned int ddr3_speed_bin;
+	unsigned int ddr4_speed_bin;
+	unsigned int pd_idle;
+	unsigned int sr_idle;
+	unsigned int sr_mc_gate_idle;
+	unsigned int srpd_lite_idle;
+	unsigned int standby_idle;
+
+	unsigned int auto_pd_dis_freq;
+	unsigned int auto_sr_dis_freq;
+	/* for ddr3 only */
+	unsigned int ddr3_dll_dis_freq;
+	/* for ddr4 only */
+	unsigned int ddr4_dll_dis_freq;
+	unsigned int phy_dll_dis_freq;
+
+	unsigned int ddr3_odt_dis_freq;
+	unsigned int phy_ddr3_odt_dis_freq;
+	unsigned int ddr3_drv;
+	unsigned int ddr3_odt;
+	unsigned int phy_ddr3_ca_drv;
+	unsigned int phy_ddr3_ck_drv;
+	unsigned int phy_ddr3_dq_drv;
+	unsigned int phy_ddr3_odt;
+
+	unsigned int lpddr3_odt_dis_freq;
+	unsigned int phy_lpddr3_odt_dis_freq;
+	unsigned int lpddr3_drv;
+	unsigned int lpddr3_odt;
+	unsigned int phy_lpddr3_ca_drv;
+	unsigned int phy_lpddr3_ck_drv;
+	unsigned int phy_lpddr3_dq_drv;
+	unsigned int phy_lpddr3_odt;
+
+	unsigned int lpddr4_odt_dis_freq;
+	unsigned int phy_lpddr4_odt_dis_freq;
+	unsigned int lpddr4_drv;
+	unsigned int lpddr4_dq_odt;
+	unsigned int lpddr4_ca_odt;
+	unsigned int phy_lpddr4_ca_drv;
+	unsigned int phy_lpddr4_ck_cs_drv;
+	unsigned int phy_lpddr4_dq_drv;
+	unsigned int phy_lpddr4_odt;
+
+	unsigned int ddr4_odt_dis_freq;
+	unsigned int phy_ddr4_odt_dis_freq;
+	unsigned int ddr4_drv;
+	unsigned int ddr4_odt;
+	unsigned int phy_ddr4_ca_drv;
+	unsigned int phy_ddr4_ck_drv;
+	unsigned int phy_ddr4_dq_drv;
+	unsigned int phy_ddr4_odt;
+
+	unsigned int ca_skew[15];
+	unsigned int cs0_skew[44];
+	unsigned int cs1_skew[44];
+
+	unsigned int available;
+};
+
+struct rk3328_ddr_de_skew_setting {
+	unsigned int ca_de_skew[30];
+	unsigned int cs0_de_skew[84];
+	unsigned int cs1_de_skew[84];
+};
+
+struct rk3328_devfreq {
+	struct devfreq *devfreq;
+	struct thermal_cooling_device *cooling;
+};
+
+struct rk3328_dmcfreq {
+	struct device *dev;
+	//struct devfreq *devfreq;
+	struct devfreq_simple_ondemand_data ondemand_data;
+	struct clk *dmc_clk;
+	struct devfreq_event_dev *edev;
+	struct mutex lock;
+	struct regulator *vdd_center;
+	struct rk3328_devfreq devfreq;
+	unsigned long rate, target_rate;
+	unsigned long volt, target_volt;
+
+	int (*set_auto_self_refresh)(u32 en);
+};
+
+static void
+rk3328_de_skew_setting_2_register(struct rk3328_ddr_de_skew_setting *de_skew,
+				  struct rk3328_ddr_dts_config_timing *tim)
+{
+	u32 n;
+	u32 offset;
+	u32 shift;
+
+	memset_io(tim->ca_skew, 0, sizeof(tim->ca_skew));
+	memset_io(tim->cs0_skew, 0, sizeof(tim->cs0_skew));
+	memset_io(tim->cs1_skew, 0, sizeof(tim->cs1_skew));
+
+	/* CA de-skew */
+	for (n = 0; n < ARRAY_SIZE(de_skew->ca_de_skew); n++) {
+		offset = n / 2;
+		shift = n % 2;
+		/* 0 => 4; 1 => 0 */
+		shift = (shift == 0) ? 4 : 0;
+		tim->ca_skew[offset] &= ~(0xf << shift);
+		tim->ca_skew[offset] |= (de_skew->ca_de_skew[n] << shift);
+	}
+
+	/* CS0 data de-skew */
+	for (n = 0; n < ARRAY_SIZE(de_skew->cs0_de_skew); n++) {
+		offset = ((n / 21) * 11) + ((n % 21) / 2);
+		shift = ((n % 21) % 2);
+		if ((n % 21) == 20)
+			shift = 0;
+		else
+			/* 0 => 4; 1 => 0 */
+			shift = (shift == 0) ? 4 : 0;
+		tim->cs0_skew[offset] &= ~(0xf << shift);
+		tim->cs0_skew[offset] |= (de_skew->cs0_de_skew[n] << shift);
+	}
+
+	/* CS1 data de-skew */
+	for (n = 0; n < ARRAY_SIZE(de_skew->cs1_de_skew); n++) {
+		offset = ((n / 21) * 11) + ((n % 21) / 2);
+		shift = ((n % 21) % 2);
+		if ((n % 21) == 20)
+			shift = 0;
+		else
+			/* 0 => 4; 1 => 0 */
+			shift = (shift == 0) ? 4 : 0;
+		tim->cs1_skew[offset] &= ~(0xf << shift);
+		tim->cs1_skew[offset] |= (de_skew->cs1_de_skew[n] << shift);
+	}
+}
+
+static void of_get_rk3328_timings(struct device *dev,
+				  struct device_node *np, uint32_t *timing)
+{
+	struct device_node *np_tim;
+	u32 *p;
+	struct rk3328_ddr_dts_config_timing *dts_timing;
+	struct rk3328_ddr_de_skew_setting *de_skew;
+	int ret = 0;
+	u32 i;
+
+	dts_timing =
+		(struct rk3328_ddr_dts_config_timing *)(timing +
+							DTS_PAR_OFFSET / 4);
+
+	np_tim = of_parse_phandle(np, "ddr_timing", 0);
+	if (!np_tim) {
+		ret = -EINVAL;
+		goto end;
+	}
+	de_skew = kmalloc(sizeof(*de_skew), GFP_KERNEL);
+	if (!de_skew) {
+		ret = -ENOMEM;
+		goto end;
+	}
+
+	p = (u32 *)dts_timing;
+	for (i = 0; i < ARRAY_SIZE(rk3328_dts_timing); i++) {
+		ret |= of_property_read_u32(np_tim, rk3328_dts_timing[i],
+					p + i);
+	}
+	p = (u32 *)de_skew->ca_de_skew;
+	for (i = 0; i < ARRAY_SIZE(rk3328_dts_ca_timing); i++) {
+		ret |= of_property_read_u32(np_tim, rk3328_dts_ca_timing[i],
+					p + i);
+	}
+	p = (u32 *)de_skew->cs0_de_skew;
+	for (i = 0; i < ARRAY_SIZE(rk3328_dts_cs0_timing); i++) {
+		ret |= of_property_read_u32(np_tim, rk3328_dts_cs0_timing[i],
+					p + i);
+	}
+	p = (u32 *)de_skew->cs1_de_skew;
+	for (i = 0; i < ARRAY_SIZE(rk3328_dts_cs1_timing); i++) {
+		ret |= of_property_read_u32(np_tim, rk3328_dts_cs1_timing[i],
+					p + i);
+	}
+	if (!ret)
+		rk3328_de_skew_setting_2_register(de_skew, dts_timing);
+
+	kfree(de_skew);
+end:
+	if (!ret) {
+		dts_timing->available = 1;
+	} else {
+		dts_timing->available = 0;
+		dev_err(dev, "of_get_ddr_timings: fail\n");
+	}
+
+	of_node_put(np_tim);
+}
+
+static int rockchip_ddr_set_auto_self_refresh(uint32_t en)
+{
+	struct arm_smccc_res res;
+
+	ddr_psci_param->sr_idle_en = en;
+
+	arm_smccc_smc(ROCKCHIP_SIP_DRAM_FREQ,
+		      SHARE_PAGE_TYPE_DDR, 0, ROCKCHIP_SIP_CONFIG_DRAM_SET_AT_SR,
+		      0, 0, 0, 0, &res);
+
+	return res.a0;
+}
+
+static int rk3328_dmc_init(struct platform_device *pdev,
+			   struct rk3328_dmcfreq *dmcfreq)
+{
+	struct arm_smccc_res res;
+	u32 size, page_num;
+
+	arm_smccc_smc(ROCKCHIP_SIP_DRAM_FREQ,
+		      0, 0, ROCKCHIP_SIP_CONFIG_DRAM_GET_VERSION,
+		      0, 0, 0, 0, &res);
+	if (res.a0 || (res.a1 < 0x101)) {
+		dev_err(&pdev->dev,
+			"trusted firmware need to update or is invalid\n");
+		return -ENXIO;
+	}
+
+	dev_notice(&pdev->dev, "current ATF version 0x%lx\n", res.a1);
+
+	/*
+	 * first 4KB is used for interface parameters
+	 * after 4KB * N is dts parameters
+	 */
+	size = sizeof(struct rk3328_ddr_dts_config_timing);
+	page_num = DIV_ROUND_UP(size, 4096) + 1;
+
+	arm_smccc_smc(ROCKCHIP_SIP_SHARE_MEM,
+		      page_num, SHARE_PAGE_TYPE_DDR, 0,
+		      0, 0, 0, 0, &res);
+	if (res.a0 != 0) {
+		dev_err(&pdev->dev, "no ATF memory for init\n");
+		return -ENOMEM;
+	}
+
+	ddr_psci_param = ioremap(res.a1, page_num << 12);
+	of_get_rk3328_timings(&pdev->dev, pdev->dev.of_node,
+			      (uint32_t *)ddr_psci_param);
+
+	arm_smccc_smc(ROCKCHIP_SIP_DRAM_FREQ,
+		      SHARE_PAGE_TYPE_DDR, 0, ROCKCHIP_SIP_CONFIG_DRAM_INIT,
+		      0, 0, 0, 0, &res);
+	if (res.a0) {
+		dev_err(&pdev->dev, "Rockchip dram init error %lx\n", res.a0);
+		return -ENOMEM;
+	}
+
+	dmcfreq->set_auto_self_refresh = rockchip_ddr_set_auto_self_refresh;
+
+	return 0;
+}
+
+static int rk3328_dmcfreq_target(struct device *dev, unsigned long *freq,
+				 u32 flags)
+{
+	struct rk3328_dmcfreq *rdev = dev_get_drvdata(dev);
+	struct dev_pm_opp *opp;
+	int err;
+
+	opp = devfreq_recommended_opp(dev, freq, flags);
+	if (IS_ERR(opp))
+		return PTR_ERR(opp);
+	dev_pm_opp_put(opp);
+
+	err = dev_pm_opp_set_rate(dev, *freq);
+	if (err)
+		return err;
+
+	rdev->rate = *freq;
+
+	return 0;
+}
+
+static int rk3328_dmcfreq_get_dev_status(struct device *dev,
+					 struct devfreq_dev_status *stat)
+{
+	struct rk3328_dmcfreq *dmcfreq = dev_get_drvdata(dev);
+	struct devfreq_event_data edata;
+	int ret = 0;
+
+	ret = devfreq_event_get_event(dmcfreq->edev, &edata);
+	if (ret < 0)
+		return ret;
+
+	stat->current_frequency = dmcfreq->rate;
+	stat->busy_time = edata.load_count;
+	stat->total_time = edata.total_count;
+
+	return ret;
+}
+
+static int rk3328_dmcfreq_get_cur_freq(struct device *dev, unsigned long *freq)
+{
+	struct rk3328_dmcfreq *dmcfreq = dev_get_drvdata(dev);
+
+	*freq = dmcfreq->rate;
+
+	return 0;
+}
+
+static struct devfreq_dev_profile rk3328_devfreq_dmc_profile = {
+	.polling_ms	= 50,
+	.target		= rk3328_dmcfreq_target,
+	.get_dev_status	= rk3328_dmcfreq_get_dev_status,
+	.get_cur_freq	= rk3328_dmcfreq_get_cur_freq,
+};
+
+static __maybe_unused int rk3328_dmcfreq_suspend(struct device *dev)
+{
+	struct rk3328_dmcfreq *dmcfreq = dev_get_drvdata(dev);
+	int ret = 0;
+
+	ret = devfreq_event_disable_edev(dmcfreq->edev);
+	if (ret < 0) {
+		dev_err(dev, "failed to disable the devfreq-event devices\n");
+		return ret;
+	}
+
+	ret = devfreq_suspend_device(dmcfreq->devfreq.devfreq);
+	if (ret < 0) {
+		dev_err(dev, "failed to suspend the devfreq devices\n");
+		return ret;
+	}
+
+	return 0;
+}
+
+static __maybe_unused int rk3328_dmcfreq_resume(struct device *dev)
+{
+	struct rk3328_dmcfreq *dmcfreq = dev_get_drvdata(dev);
+	int ret = 0;
+
+	ret = devfreq_event_enable_edev(dmcfreq->edev);
+	if (ret < 0) {
+		dev_err(dev, "failed to enable the devfreq-event devices\n");
+		return ret;
+	}
+
+	ret = devfreq_resume_device(dmcfreq->devfreq.devfreq);
+	if (ret < 0) {
+		dev_err(dev, "failed to resume the devfreq devices\n");
+		return ret;
+	}
+	return ret;
+}
+
+static SIMPLE_DEV_PM_OPS(rk3328_dmcfreq_pm, rk3328_dmcfreq_suspend,
+			 rk3328_dmcfreq_resume);
+
+void rk3328_devfreq_fini(struct rk3328_dmcfreq *rdev)
+{
+	struct rk3328_devfreq *devfreq = &rdev->devfreq;
+
+	if (devfreq->cooling) {
+		devfreq_cooling_unregister(devfreq->cooling);
+		devfreq->cooling = NULL;
+	}
+
+	if (devfreq->devfreq) {
+		devm_devfreq_remove_device(rdev->dev, devfreq->devfreq);
+		devfreq->devfreq = NULL;
+	}
+
+}
+
+int rk3328_devfreq_init(struct rk3328_dmcfreq *rdev)
+{
+	struct thermal_cooling_device *cooling;
+	struct device *dev = rdev->dev;
+	struct devfreq *devfreq;
+	struct rk3328_devfreq *rdevfreq = &rdev->devfreq;
+	const char *regulator_names[] = { "center", NULL };
+	
+	struct dev_pm_opp *opp;
+	unsigned long cur_freq;
+	int ret;
+
+	if (!device_property_present(dev, "operating-points-v2"))
+		/* Optional, continue without devfreq */
+		return 0;
+
+	ret= devm_pm_opp_set_clkname(dev, "dmc_clk");
+	if (ret)
+		goto err_fini;
+
+	ret = devm_pm_opp_set_regulators(dev, regulator_names);
+	
+	if (ret) {
+		/* Continue if the optional regulator is missing */
+		if (ret != -ENODEV)
+			goto err_fini;
+	}
+
+	ret = devm_pm_opp_of_add_table(dev);
+	if (ret)
+		goto err_fini;
+
+	cur_freq = 0;
+
+	opp = devfreq_recommended_opp(dev, &cur_freq, 0);
+	if (IS_ERR(opp)) {
+		ret = PTR_ERR(opp);
+		goto err_fini;
+	}
+
+	rk3328_devfreq_dmc_profile.initial_freq = cur_freq;
+	dev_pm_opp_put(opp);
+
+	rdev->ondemand_data.upthreshold = 15;
+	rdev->ondemand_data.downdifferential = 5;
+
+	devfreq = devm_devfreq_add_device(dev, &rk3328_devfreq_dmc_profile,
+					  DEVFREQ_GOV_SIMPLE_ONDEMAND, &rdev->ondemand_data);
+	if (IS_ERR(devfreq)) {
+		dev_err(dev, "Couldn't initialize rk3328-dmc devfreq\n");
+		ret = PTR_ERR(devfreq);
+		goto err_fini;
+	}
+
+	rdevfreq->devfreq = devfreq;
+
+	cooling = of_devfreq_cooling_register(dev->of_node, devfreq);
+	if (IS_ERR(cooling))
+		dev_warn(dev, "Failed to register cooling device\n");
+	else
+		rdevfreq->cooling = cooling;
+
+	return 0;
+
+err_fini:
+	rk3328_devfreq_fini(rdev);
+	return ret;
+}
+
+static int rk3328_dmcfreq_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct rk3328_dmcfreq *data;
+	int ret;
+
+	data = devm_kzalloc(dev, sizeof(struct rk3328_dmcfreq), GFP_KERNEL);
+	if (!data)
+		return -ENOMEM;
+
+	mutex_init(&data->lock);
+
+	data->dev = dev;
+
+	data->dmc_clk = devm_clk_get(dev, "dmc_clk");
+	if (IS_ERR(data->dmc_clk)) {
+		if (PTR_ERR(data->dmc_clk) == -EPROBE_DEFER)
+			return -EPROBE_DEFER;
+
+		dev_err(dev, "Cannot get the clk dmc_clk\n");
+		return PTR_ERR(data->dmc_clk);
+	}
+
+	data->edev = devfreq_event_get_edev_by_phandle(dev, "devfreq-events", 0);
+	if (IS_ERR(data->edev))
+		return -EPROBE_DEFER;
+
+	ret = devfreq_event_enable_edev(data->edev);
+	if (ret < 0) {
+		dev_err(dev, "failed to enable devfreq-event devices\n");
+		return ret;
+	}
+
+	ret = rk3328_dmc_init(pdev, data);
+	if (ret)
+		return ret;
+
+	ret = rk3328_devfreq_init(data);
+	if (ret)
+		return ret;
+
+	platform_set_drvdata(pdev, data);
+
+	return 0;
+
+}
+
+static void rk3328_dmcfreq_remove(struct platform_device *pdev)
+{
+	struct rk3328_dmcfreq *dmcfreq = dev_get_drvdata(&pdev->dev);
+
+	/*
+	 * Before remove the opp table we need to unregister the opp notifier.
+	 */
+	rk3328_devfreq_fini(dmcfreq);
+
+	return;
+}
+
+static const struct of_device_id rk3328dmc_devfreq_of_match[] = {
+	{ .compatible = "rockchip,rk3328-dmc" },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, rk3328dmc_devfreq_of_match);
+
+static struct platform_driver rk3328_dmcfreq_driver = {
+	.probe	= rk3328_dmcfreq_probe,
+	.remove = rk3328_dmcfreq_remove,
+	.driver = {
+		.name	= "rk3328-dmc",
+		.pm	= &rk3328_dmcfreq_pm,
+		.of_match_table = rk3328dmc_devfreq_of_match,
+	},
+};
+module_platform_driver(rk3328_dmcfreq_driver);
+
+MODULE_LICENSE("GPL v2");
+MODULE_AUTHOR("Lin Huang <hl@rock-chips.com>");
+MODULE_DESCRIPTION("RK3328 dmcfreq driver with devfreq framework");
diff --git a/drivers/phy/rockchip/Kconfig b/drivers/phy/rockchip/Kconfig
index 14698571b607..858e451edc5a 100644
--- a/drivers/phy/rockchip/Kconfig
+++ b/drivers/phy/rockchip/Kconfig
@@ -48,6 +48,16 @@ config PHY_ROCKCHIP_INNO_USB2
 	help
 	  Support for Rockchip USB2.0 PHY with Innosilicon IP block.
 
+config PHY_ROCKCHIP_INNO_USB3
+	tristate "Rockchip INNO USB3PHY Driver"
+	depends on (ARCH_ROCKCHIP || COMPILE_TEST) && OF
+	depends on COMMON_CLK
+	depends on USB_SUPPORT
+	select GENERIC_PHY
+	select USB_COMMON
+	help
+	  Support for Rockchip USB3.0 PHY with Innosilicon IP block.
+
 config PHY_ROCKCHIP_INNO_CSIDPHY
 	tristate "Rockchip Innosilicon MIPI CSI PHY driver"
 	depends on (ARCH_ROCKCHIP || COMPILE_TEST) && OF
diff --git a/drivers/phy/rockchip/Makefile b/drivers/phy/rockchip/Makefile
index 117aaffd037d..d7b7b090b1e2 100644
--- a/drivers/phy/rockchip/Makefile
+++ b/drivers/phy/rockchip/Makefile
@@ -6,6 +6,7 @@ obj-$(CONFIG_PHY_ROCKCHIP_INNO_CSIDPHY)	+= phy-rockchip-inno-csidphy.o
 obj-$(CONFIG_PHY_ROCKCHIP_INNO_DSIDPHY)	+= phy-rockchip-inno-dsidphy.o
 obj-$(CONFIG_PHY_ROCKCHIP_INNO_HDMI)	+= phy-rockchip-inno-hdmi.o
 obj-$(CONFIG_PHY_ROCKCHIP_INNO_USB2)	+= phy-rockchip-inno-usb2.o
+obj-$(CONFIG_PHY_ROCKCHIP_INNO_USB3)	+= phy-rockchip-inno-usb3.o
 obj-$(CONFIG_PHY_ROCKCHIP_NANENG_COMBO_PHY)	+= phy-rockchip-naneng-combphy.o
 obj-$(CONFIG_PHY_ROCKCHIP_PCIE)		+= phy-rockchip-pcie.o
 obj-$(CONFIG_PHY_ROCKCHIP_SAMSUNG_DCPHY)	+= phy-rockchip-samsung-dcphy.o
diff --git a/drivers/phy/rockchip/phy-rockchip-inno-usb3.c b/drivers/phy/rockchip/phy-rockchip-inno-usb3.c
new file mode 100644
index 000000000000..089cfa18b2e1
--- /dev/null
+++ b/drivers/phy/rockchip/phy-rockchip-inno-usb3.c
@@ -0,0 +1,870 @@
+// SPDX-License-Identifier: GPL-2.0+
+
+/*
+ * phy-rockchip-inno-usb3.c - USB3 PHY based on Innosilicon IP as
+ * implemented on Rockchip rk3328. Tuning data magic bits are taken as is
+ * from the downstream driver. Downstream driver is located at:
+ * https://github.com/rockchip-linux/kernel/blob/240a5660d7c23841ccf7b7cc489078bf521b9802/drivers/phy/rockchip/phy-rockchip-inno-usb3.c
+ *
+ * Author: Peter Geis <pgwipeout@gmail.com>
+ * TODO:
+ * - Find the rest of the register names / definitions.
+ * - Implement pm functions.
+ * - Implement board specific tuning from dts.
+ * - Implement regulator control.
+ */
+
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/of_device.h>
+#include <linux/of_irq.h>
+#include <linux/of_platform.h>
+#include <linux/phy/phy.h>
+#include <linux/platform_device.h>
+#include <linux/regmap.h>
+#include <linux/reset.h>
+#include <linux/mfd/syscon.h>
+#include <linux/usb/of.h>
+
+#define REG_WRITE_MASK		GENMASK(31, 16)
+#define REG_WRITE_SHIFT		16
+#define DISABLE_BITS		0x0
+
+/* USB3PHY GRF Registers */
+#define USB3PHY_WAKEUP_CON_REG	0x40
+#define USB3PHY_WAKEUP_STAT_REG	0x44
+#define USB3_LINESTATE_IRQ_EN	BIT(0)
+#define USB3_RXDET_IRQ_EN		BIT(1)
+#define USB3_BVALID_RISE_IRQ_EN	BIT(2)
+#define USB3_BVALID_FALL_IRQ_EN	BIT(3)
+#define USB3_BVALID_CLEAR_MASK	GENMASK(3, 2)
+#define USB3_ID_RISE_IRQ_EN		BIT(4)
+#define USB3_ID_FALL_IRQ_EN		BIT(5)
+#define USB3_ID_CLEAR_MASK		GENMASK(5, 4)
+#define USB3_RXDET_EN			BIT(6)
+
+/* PIPE registers */
+/* 0x08 for SSC, default 0x0e */
+#define UNKNOWN_PIPE_REG_000			0x000
+#define UNKNOWN_SSC_000_MASK			GENMASK(2, 1)
+#define UNKNOWN_SSC_000_ENABLE			(0x00 << 1)
+
+/* 0x83 for 24m, 0x01 for 25m, default 0x86 */
+#define PIPE_REG_020					0x020
+/* RX CDR multiplier high bits [7:6], as P, default 0x2, RX data rate = (2*refclk*P)/Q */
+#define PIPE_RX_CDR_MULT_HIGH_MASK		GENMASK(7, 6)
+/* TX PLL divider bits [4:0], as N, default 0x6, TX data rate = (2*refclk*M)/N */
+#define PIPE_TX_PLL_DIV_MASK			GENMASK(4, 0)
+
+/* 0x71 for 24m, 0x64 for 25m, default 0x71 */
+#define PIPE_REG_028					0x028
+/* RX CDR multiplier low bits [7:0], as P, default 0x71, RX data rate = (2*refclk*P)/Q */
+#define PIPE_RX_CDR_MULT_LOW_MASK		GENMASK(7, 0)
+
+/* 0x26 for 24m?, 0x21 for 25m, default 0x26 */
+#define PIPE_REG_030					0x030
+/* RX CDR divider bits [4:0], as Q, default 0x6, RX data rate = (2*refclk*P)/Q */
+#define PIPE_RX_CDR_DIV_MASK			GENMASK(4, 0)
+
+/* 1'b1 Disable bandgap power, default 0x00 */
+#define PIPE_REG_044					0x044
+#define BANDGAP_POWER_DISABLE			BIT(4)
+
+/* 0xe0 for rx tune?, default 0xe1 */
+#define PIPE_REG_060					0x060
+#define PIPE_TX_DETECT_BYPASS_DEBUG		BIT(4) /* enable to always force detection */
+/* RX CTLE frequency bandwidth response tuning bits [1:0], default 0x1 */
+#define PIPE_RX_CTLE_FREQ_BW_MASK		GENMASK(1, 0)
+#define PIPE_RX_CTLE_FREQ_BW_TUNE		0x0
+
+/* default 0x49 */
+#define PIPE_REG_064					0x064
+/* RX equalizer tail current control bits [6:4], default 0x4 */
+#define PIPE_RX_EQ_TAIL_CURR_MASK		GENMASK(6, 4)
+
+/* 0x08 for rx tune?, default 0x07 */
+#define PIPE_REG_068					0x068
+/* RX equalizer low frequency gain control bits [7:4], default 0x0 */
+#define PIPE_RX_EQ_LOW_GAIN_MASK		GENMASK(7, 4)
+#define PIPE_RX_EQ_LOW_GAIN_TUNE		(0x1 << 4)
+/* RX CTLE gain tuning bits [3:0], higher = more gain default 0x7 */
+#define PIPE_RX_CTLE_GAIN_MASK			GENMASK(3, 0)
+#define PIPE_RX_CTLE_GAIN_TUNE			0x7 /* 0x5 lowest functional value, 0xf highest */
+
+/* RX ODT manual resistance config, higher = less resistance, depends on REG_1C4 BIT(5) set */
+#define PIPE_REG_06C					0x06c
+/* RX ODT manual resistance high bits [3:0], default 0x0 */
+#define PIPE_RX_ODT_RES_HIGH_MASK		GENMASK(3, 0)
+#define PIPE_RX_ODT_RES_HIGH_TUNE		0xf
+
+#define PIPE_REG_070					0x070
+/* RX ODT manual resistance mid bits [7:0], default 0x03 */
+#define PIPE_RX_ODT_RES_MID_MASK		GENMASK(7, 0)
+#define PIPE_RX_ODT_RES_MID_TUNE		0xff
+
+#define PIPE_REG_074					0x074
+/* RX ODT manual resistance low bits [7:0], default 0xff */
+#define PIPE_RX_ODT_RES_LOW_MASK		GENMASK(7, 0)
+#define PIPE_RX_ODT_RES_LOW_TUNE		0xff
+
+/* default 0x08 */
+#define PIPE_REG_080					0x080
+#define PIPE_TX_COMMON_MODE_DIS			BIT(2)	/* 1'b1 disable TX common type */
+
+/* default 0x33 */
+#define PIPE_REG_088					0x088
+#define PIPE_TX_DRIVER_PREEMP_EN		BIT(4)	/* 1'b1 enable pre-emphasis */
+
+/* default 0x18 */
+#define PIPE_REG_0C0					0x0c0
+#define PIPE_RX_CM_EN					BIT(3)	/* 1'b1 enable RX CM */
+#define PIPE_TX_OBS_EN					BIT(4)	/* 1'b1 enable TX OBS */
+
+/* 0x12 for rx tune?, default 0x14 */
+#define PIPE_REG_0C8					0x0c8
+/* RX CDR charge pump current bits [3:1], default 0x2 */
+#define PIPE_RX_CDR_CHG_PUMP_MASK		GENMASK(3, 1)
+#define PIPE_RX_CDR_CHG_PUMP_TUNE		(0x2 << 1)
+
+/* 0x02 for 24m, 0x06 for 25m, default 0x06 */
+#define UNKNOWN_PIPE_REG_108			0x108
+#define UNKNOWN_REFCLK_108_24M			0x02
+
+/* 0x80 for 24m, default 0x00 */
+#define UNKNOWN_PIPE_REG_10C			0x10c
+#define UNKNOWN_REFCLK_10C_24M			BIT(7)
+
+/* 0x01 for 24m, 0x00 for 25m, default 0x02 */
+#define PIPE_REG_118					0x118
+/* TX PLL multiplier high bits [3:0], as M, default 0x2, TX data rate = (2*refclk*M)/N */
+#define PIPE_TX_PLL_MUL_HIGH_MASK		GENMASK(3, 0)
+
+/* 0x38 for 24m, 0x64 for 25m, default 0x71 */
+#define PIPE_REG_11C					0x11c
+/* TX PLL multiplier low bits [7:0], as M, default 0x71, TX data rate = (2*refclk*M)/N */
+#define PIPE_TX_PLL_MUL_LOW_MASK		GENMASK(7, 0)
+
+/* 0x0c for SSC, default 0x1c */
+#define UNKNOWN_PIPE_REG_120			0x120
+#define UNKNOWN_SSC_120_MASK			BIT(4)
+#define UNKNOWN_SSC_120_ENABLE			(0x0 << 4)
+
+/* default 0x40 */
+#define PIPE_REG_12C					0x12c
+#define PIPE_TX_PLL_ALWAYS_ON			BIT(0) /* disable for PLL control by pipe_pd */
+
+/* 0x05 for rx tune, default 0x01 */
+#define PIPE_REG_148					0x148
+#define PIPE_RX_CHG_PUMP_DIV_2			BIT(2) /* RX CDR charge pump div/2, default 0 */
+
+/* 0x70 for rx tune, default 0x72 */
+#define PIPE_REG_150					0x150
+#define PIPE_TX_BIAS_EN					BIT(6)	/* 1'b1 Enable TX Bias */
+/* RX CDR phase tracking speed bits [3:0], default 0x2 */
+#define PIPE_RX_CDR_SPEED_MASK			GENMASK(3, 0)
+#define PIPE_RX_CDR_SPEED_TUNE			0x00
+
+/* default 0xd4 */
+#define PIPE_REG_160
+/* RX common mode voltage strength bits [5:4], default 0x1 */
+#define PIPE_RX_CDR_COM_VOLT_MASK		GENMASK(5, 4)
+#define PIPE_RX_CDR_COM_VOLT_TUNE		(0x1 << 4)
+
+/* default 0x00 */
+#define PIPE_REG_180					0x180
+/* TX driver bias reference voltage bits [3:2], in mv */
+#define PIPE_TX_BIAS_REF_VOLT_MASK		GENMASK(3, 2)
+#define PIPE_TX_BIAS_REF_VOLT_200		(0x0 << 2)
+#define PIPE_TX_BIAS_REF_VOLT_175		(0x1 << 2)
+#define PIPE_TX_BIAS_REF_VOLT_225		(0x2 << 2) /* downstream 5.10 driver setting */
+#define PIPE_TX_BIAS_REF_VOLT_250		(0x3 << 2)
+
+/* default 0x01 */
+#define PIPE_REG_1A8			0x1a8
+#define PIPE_LDO_POWER_DIS				BIT(4)	/* 1'b1 Disable LDO Power */
+
+/* default 0x07 */
+#define PIPE_REG_1AC			0x1ac
+/* TX driver output common voltage bits [5:4], in mv */
+#define PIPE_TX_COMMON_VOLT_MASK		GENMASK(5, 4)
+#define PIPE_TX_COMMON_VOLT_800			(0x0 << 4)
+#define PIPE_TX_COMMON_VOLT_750			(0x1 << 4)
+#define PIPE_TX_COMMON_VOLT_950			(0x2 << 4)
+#define PIPE_TX_COMMON_VOLT_1100		(0x3 << 4)
+
+/* default 0xfb */
+#define PIPE_REG_1B8					0x1b8
+/* TX driver swing strength bits [7:4], range 0x0 to 0xf */
+#define PIPE_TX_DRIVER_SWING_MASK		GENMASK(7, 4) /* 0x2 lowest functional value */
+/* TX driver pre-emphasis strength bits [1:0], default 0x3, enabled by REG 088 */
+#define PIPE_TX_DRIVER_PREEMP_STR_MASK	GENMASK(1, 0)
+
+/* set to 0xf0 for rx tune?, default 0xd0 */
+#define PIPE_REG_1C4					0x1c4
+#define PIPE_RX_ODT_AUTO_DIS			BIT(5) /* Disable RX ODT auto compensation */
+#define PIPE_TX_ODT_AUTO_DIS			BIT(3) /* Disable TX ODT auto compensation */
+
+/* UTMI registers */
+/* 0x0f for utmi tune, default 0x09*/
+#define UTMI_REG_030					0x030
+/* {bits[2:0]=111}: always enable pre-emphasis */
+#define UTMI_ENABLE_PRE_EMPH_MASK		GENMASK(2, 0)
+#define UTMI_ENABLE_PRE_EMPH			0x07
+
+/* 0x41 for utmi tune, default 0x49 */
+#define UTMI_REG_040					0x040
+/* TX HS pre-emphasis strength bits [5:3], default 0x1*/
+#define UTMI_TX_PRE_EMPH_STR_MASK		GENMASK(5, 3)
+#define UTMI_TX_PRE_EMPH_WEAKEST		(0x0 << 3)
+
+/* set to 0xb5 for utmi tune, default 0xb5 */
+#define UTMI_REG_11C					0x11c
+/* {bits[4:0]=10101}: odt 45ohm tuning */
+#define UTMI_ODT_45_OHM_MASK			GENMASK(4, 0)
+#define UTMI_ODT_45_OHM_TUNE			0x15
+
+enum rockchip_usb3phy_type {
+	USB3PHY_TYPE_USB2,
+	USB3PHY_TYPE_USB3,
+	USB3PHY_TYPE_MAX,
+};
+
+/**
+ * struct rockchip_usb3phy_port - usb-phy port data.
+ * @phy: port usb phy struct.
+ * @regmap: port regmap.
+ * @type: port usb phy type.
+ */
+struct rockchip_usb3phy_port {
+	struct phy					*phy;
+	struct regmap				*regmap;
+	enum rockchip_usb3phy_type	type;
+};
+
+struct rockchip_usb3phy {
+	struct device				*dev;
+	struct regmap				*regmap;
+	struct clk					*clk_pipe;
+	struct clk					*clk_otg;
+	struct clk					*clk_ref;
+	struct reset_control		*u3por_rst;
+	struct reset_control		*u2por_rst;
+	struct reset_control		*pipe_rst;
+	struct reset_control		*utmi_rst;
+	struct reset_control		*pipe_apb_rst;
+	struct reset_control		*utmi_apb_rst;
+	struct rockchip_usb3phy_port	ports[USB3PHY_TYPE_MAX];
+	int	bvalid_irq;
+	int	id_irq;
+	int	ls_irq;
+	int	rxdet_irq;
+};
+
+struct usb3phy_config {
+	unsigned int reg;
+	unsigned int mask;
+	u8 def;
+};
+
+static const struct usb3phy_config rk3328_rx_config[] = {
+	{ PIPE_REG_150, PIPE_RX_CDR_SPEED_MASK, PIPE_RX_CDR_SPEED_TUNE },
+	{ PIPE_REG_0C8, PIPE_RX_CDR_CHG_PUMP_MASK, PIPE_RX_CDR_CHG_PUMP_TUNE },
+	{ PIPE_REG_148, PIPE_RX_CHG_PUMP_DIV_2, PIPE_RX_CHG_PUMP_DIV_2 },
+	{ PIPE_REG_068, PIPE_RX_CTLE_GAIN_MASK, PIPE_RX_CTLE_GAIN_TUNE },
+//	{ PIPE_REG_1C4, PIPE_RX_ODT_AUTO_DIS, PIPE_RX_ODT_AUTO_DIS },
+	{ PIPE_REG_070, PIPE_RX_ODT_RES_MID_MASK, PIPE_RX_ODT_RES_MID_TUNE },
+	{ PIPE_REG_06C, PIPE_RX_ODT_RES_HIGH_MASK, PIPE_RX_ODT_RES_HIGH_TUNE },
+	{ PIPE_REG_060, PIPE_RX_CTLE_FREQ_BW_MASK, PIPE_RX_CTLE_FREQ_BW_TUNE },
+	{ UNKNOWN_PIPE_REG_10C, UNKNOWN_REFCLK_10C_24M, UNKNOWN_REFCLK_10C_24M },
+	{ PIPE_REG_060, PIPE_RX_CTLE_FREQ_BW_MASK, PIPE_RX_CTLE_FREQ_BW_TUNE },
+	{ PIPE_REG_068, PIPE_RX_EQ_LOW_GAIN_MASK, PIPE_RX_EQ_LOW_GAIN_TUNE },
+};
+
+static const struct usb3phy_config rk3328_tx_config[] = {
+	{ PIPE_REG_180, PIPE_TX_BIAS_REF_VOLT_MASK, PIPE_TX_BIAS_REF_VOLT_250 },
+};
+
+static const struct usb3phy_config rk3328_ssc_config[] = {
+	{ UNKNOWN_PIPE_REG_000, UNKNOWN_SSC_000_MASK, UNKNOWN_SSC_000_ENABLE },
+	{ UNKNOWN_PIPE_REG_120, UNKNOWN_SSC_120_MASK, UNKNOWN_SSC_120_ENABLE },
+};
+
+static const struct usb3phy_config rk3328_utmi_config[] = {
+	{ UTMI_REG_030, UTMI_ENABLE_PRE_EMPH_MASK, UTMI_ENABLE_PRE_EMPH },
+	{ UTMI_REG_040, UTMI_TX_PRE_EMPH_STR_MASK, UTMI_TX_PRE_EMPH_WEAKEST },
+	{ UTMI_REG_11C, UTMI_ODT_45_OHM_MASK, UTMI_ODT_45_OHM_TUNE },
+};
+
+static const struct usb3phy_config rk3328_pipe_pwr_en_config[] = {
+	{ PIPE_REG_1A8, PIPE_LDO_POWER_DIS, DISABLE_BITS },
+	{ PIPE_REG_044, BANDGAP_POWER_DISABLE, DISABLE_BITS },
+	{ PIPE_REG_150, PIPE_TX_BIAS_EN, PIPE_TX_BIAS_EN },
+	{ PIPE_REG_080, PIPE_TX_COMMON_MODE_DIS, DISABLE_BITS },
+	{ PIPE_REG_0C0, PIPE_TX_OBS_EN, PIPE_TX_OBS_EN },
+	{ PIPE_REG_0C0, PIPE_RX_CM_EN, PIPE_RX_CM_EN },
+};
+
+static int rockchip_usb3phy_reset(struct rockchip_usb3phy *usb3phy,
+				  bool reset, enum rockchip_usb3phy_type type)
+{
+	if (reset) {
+		if (type == USB3PHY_TYPE_USB2) {
+			clk_disable_unprepare(usb3phy->clk_otg);
+			reset_control_assert(usb3phy->utmi_rst);
+			reset_control_assert(usb3phy->u2por_rst);
+		}
+		if (type == USB3PHY_TYPE_USB3) {
+			clk_disable_unprepare(usb3phy->clk_pipe);
+			reset_control_assert(usb3phy->pipe_rst);
+			reset_control_assert(usb3phy->u3por_rst);
+		}
+	} else {
+		if (type == USB3PHY_TYPE_USB2) {
+			reset_control_deassert(usb3phy->u2por_rst);
+			fsleep(1000);
+			clk_prepare_enable(usb3phy->clk_otg);
+			fsleep(500);
+			reset_control_deassert(usb3phy->utmi_rst);
+			fsleep(100);
+		}
+		if (type == USB3PHY_TYPE_USB3) {
+			reset_control_deassert(usb3phy->u3por_rst);
+			fsleep(500);
+			clk_prepare_enable(usb3phy->clk_pipe);
+			fsleep(1000);
+			reset_control_deassert(usb3phy->pipe_rst);
+			fsleep(100);
+		}
+	}
+	return 0;
+}
+
+static irqreturn_t rockchip_usb3phy_linestate_irq(int irq, void *data)
+{
+	struct rockchip_usb3phy *usb3phy = data;
+	int tmp;
+
+	/* check if the interrupt is enabled */
+	regmap_read(usb3phy->regmap, USB3PHY_WAKEUP_CON_REG, &tmp);
+	if (!(tmp & USB3_LINESTATE_IRQ_EN)) {
+		dev_warn(usb3phy->dev, "invalid linestate irq received\n");
+		return IRQ_NONE;
+	}
+
+	regmap_read(usb3phy->regmap, USB3PHY_WAKEUP_STAT_REG, &tmp);
+	if (tmp & USB3_LINESTATE_IRQ_EN)
+		dev_dbg_ratelimited(usb3phy->dev, "linestate irq received\n");
+
+	/* clear the interrupt */
+	regmap_write(usb3phy->regmap, USB3PHY_WAKEUP_STAT_REG, USB3_LINESTATE_IRQ_EN);
+
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t rockchip_usb3phy_bvalid_irq(int irq, void *data)
+{
+	struct rockchip_usb3phy *usb3phy = data;
+	int tmp;
+
+	/* check if the interrupt is enabled */
+	regmap_read(usb3phy->regmap, USB3PHY_WAKEUP_CON_REG, &tmp);
+	if (!((tmp & USB3_BVALID_FALL_IRQ_EN) | (tmp & USB3_BVALID_RISE_IRQ_EN))) {
+		dev_warn_ratelimited(usb3phy->dev, "invalid bvalid irq received\n");
+		return IRQ_NONE;
+	}
+
+	regmap_read(usb3phy->regmap, USB3PHY_WAKEUP_STAT_REG, &tmp);
+	if (tmp & USB3_BVALID_FALL_IRQ_EN)
+		dev_dbg(usb3phy->dev, "bvalid falling irq received\n");
+	if (tmp & USB3_BVALID_RISE_IRQ_EN)
+		dev_dbg(usb3phy->dev, "bvalid rising irq received\n");
+
+	/* clear the interrupt */
+	regmap_write(usb3phy->regmap, USB3PHY_WAKEUP_STAT_REG, USB3_BVALID_CLEAR_MASK);
+
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t rockchip_usb3phy_id_irq(int irq, void *data)
+{
+	struct rockchip_usb3phy *usb3phy = data;
+	int tmp;
+
+	/* check if the interrupt is enabled */
+	regmap_read(usb3phy->regmap, USB3PHY_WAKEUP_CON_REG, &tmp);
+	if (!((tmp & USB3_ID_FALL_IRQ_EN) | (tmp & USB3_ID_RISE_IRQ_EN))) {
+		dev_warn(usb3phy->dev, "invalid id irq received\n");
+		return IRQ_NONE;
+	}
+
+	regmap_read(usb3phy->regmap, USB3PHY_WAKEUP_STAT_REG, &tmp);
+	if (tmp & USB3_ID_FALL_IRQ_EN)
+		dev_dbg(usb3phy->dev, "id falling irq received\n");
+	if (tmp & USB3_ID_RISE_IRQ_EN)
+		dev_dbg(usb3phy->dev, "id rising irq received\n");
+
+	/* clear the interrupt */
+	regmap_write(usb3phy->regmap, USB3PHY_WAKEUP_STAT_REG, USB3_ID_CLEAR_MASK);
+
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t rockchip_usb3phy_rxdet_irq(int irq, void *data)
+{
+	struct rockchip_usb3phy *usb3phy = data;
+	int tmp;
+
+	/* check if the interrupt is enabled */
+	regmap_read(usb3phy->regmap, USB3PHY_WAKEUP_CON_REG, &tmp);
+	if (!(tmp & USB3_RXDET_IRQ_EN)) {
+		dev_warn(usb3phy->dev, "invalid rxdet irq received\n");
+		return IRQ_NONE;
+	}
+
+	regmap_read(usb3phy->regmap, USB3PHY_WAKEUP_STAT_REG, &tmp);
+	if (tmp & USB3_RXDET_IRQ_EN)
+		dev_dbg_ratelimited(usb3phy->dev, "rxdet irq received\n");
+
+	/* clear the interrupt */
+	regmap_write(usb3phy->regmap, USB3PHY_WAKEUP_STAT_REG, USB3_RXDET_IRQ_EN);
+
+	return IRQ_HANDLED;
+}
+
+static int rockchip_usb3phy_bulk_update(struct rockchip_usb3phy *usb3phy, struct regmap *regmap,
+					const struct usb3phy_config *config, unsigned int size)
+{
+	unsigned int i, val, tmp;
+	int ret = 0;
+
+	for (i = 0; i < size; i++) {
+		ret = regmap_read(regmap, config[i].reg, &val);
+		if (ret < 0) {
+			dev_err(usb3phy->dev, "failed to read addr: 0x%02x\n", config[i].reg);
+			return ret;
+		}
+		tmp = val & ~config[i].mask;
+		tmp |= config[i].def;
+		dev_dbg(usb3phy->dev, "write: 0x%03x old: 0x%02x new: 0x%02x\n",
+			config[i].reg, val, tmp);
+		ret = regmap_write(regmap, config[i].reg, tmp);
+		if (ret < 0) {
+			dev_err(usb3phy->dev, "failed to write addr: 0x%02x\n", config[i].reg);
+			return ret;
+		}
+	}
+
+	return ret;
+}
+
+static int rockchip_usb3phy_calc_rate(struct rockchip_usb3phy *usb3phy, struct regmap *regmap)
+{
+	long rate;
+	unsigned int mul, div, target = (5000000000 / 100000);
+
+	rate = clk_get_rate(usb3phy->clk_ref) / 100000;
+	if (rate < 0) {
+		dev_err(usb3phy->dev, "failed to get refclk, %ld\n", rate);
+		return rate;
+	/* lowest possible supported clock is 4.8MHZ, highest rk3328 can do is 1.6GHZ */
+	} else if ((rate < 48) | (rate > 16000)) {
+		goto error;
+	}
+
+	for (div = 1; div < 32; div++) {
+		for (mul = 1; mul < 1024; mul++) {
+			if (((2 * rate * mul) / div) == target)
+				goto done;
+			if (((2 * rate * mul) / div) > target)
+				break;
+		}
+	}
+
+error:
+	dev_err(usb3phy->dev, "invalid refclock rate, %ld\n", rate * 100000);
+	return -EINVAL;
+
+done:
+	dev_dbg(usb3phy->dev, "refclk rate mul: %x div: %x rate: %ld\n", mul, div, (rate * 100000));
+
+	regmap_write(regmap, PIPE_REG_020, (mul >> 2) & PIPE_RX_CDR_MULT_HIGH_MASK);
+	regmap_write(regmap, PIPE_REG_020, div & PIPE_TX_PLL_DIV_MASK);
+	regmap_write(regmap, PIPE_REG_028, mul & PIPE_RX_CDR_MULT_LOW_MASK);
+	regmap_write(regmap, PIPE_REG_030, div & PIPE_RX_CDR_DIV_MASK);
+	regmap_write(regmap, PIPE_REG_118, (mul >> 8) & PIPE_TX_PLL_MUL_HIGH_MASK);
+	regmap_write(regmap, PIPE_REG_11C, mul & PIPE_TX_PLL_MUL_LOW_MASK);
+
+	return 0;
+}
+
+static int rockchip_usb3phy_init(struct phy *phy)
+{
+	struct rockchip_usb3phy_port *port = phy_get_drvdata(phy);
+	struct rockchip_usb3phy *usb3phy = dev_get_drvdata(phy->dev.parent);
+	int tmp, ret;
+
+	dev_warn(usb3phy->dev, "usb3phy_init %s\n", dev_name(&phy->dev));
+	clk_prepare_enable(usb3phy->clk_ref);
+	rockchip_usb3phy_reset(usb3phy, false, port->type);
+
+	if (port->type == USB3PHY_TYPE_USB2) {
+		/*
+		 * "For RK3328 SoC, pre-emphasis and pre-emphasis strength must be
+		 * written as one fixed value. The ODT 45ohm value should be tuned
+		 * for different boards to adjust HS eye height."
+		 */
+		dev_dbg(usb3phy->dev, "tuning UTMI\n");
+		ret = rockchip_usb3phy_bulk_update(usb3phy, port->regmap, rk3328_utmi_config,
+						   ARRAY_SIZE(rk3328_utmi_config));
+	}
+
+	if (port->type == USB3PHY_TYPE_USB3) {
+		/* Enable interrupts */
+		tmp = (USB3_LINESTATE_IRQ_EN | USB3_ID_FALL_IRQ_EN | USB3_ID_RISE_IRQ_EN |
+			USB3_RXDET_IRQ_EN | USB3_BVALID_RISE_IRQ_EN | USB3_BVALID_FALL_IRQ_EN);
+		tmp |= (tmp << REG_WRITE_SHIFT);
+
+		ret = regmap_write(usb3phy->regmap, USB3PHY_WAKEUP_CON_REG, tmp);
+		if (ret < 0) {
+			/* interrupt write determines if we have write access */
+			dev_err(usb3phy->dev, "failed to write interrupts\n");
+			return ret;
+		}
+
+		/* Configure for 24M ref clk */
+		dev_dbg(usb3phy->dev, "setting pipe for 24M refclk\n");
+		if (rockchip_usb3phy_calc_rate(usb3phy, usb3phy->regmap))
+			return -EINVAL;
+
+		/* Enable SSC */
+		udelay(3);
+		dev_dbg(usb3phy->dev, "setting pipe for SSC\n");
+		ret = rockchip_usb3phy_bulk_update(usb3phy, port->regmap, rk3328_ssc_config,
+						   ARRAY_SIZE(rk3328_ssc_config));
+
+		/* "Tuning RX for compliance RJTL test" */
+		dev_dbg(usb3phy->dev, "setting pipe for RX tuning\n");
+		ret = rockchip_usb3phy_bulk_update(usb3phy, port->regmap, rk3328_rx_config,
+						   ARRAY_SIZE(rk3328_rx_config));
+		if (ret)
+			return ret;
+
+		/*
+		 * "Tuning TX to increase the bias current used in TX driver and RX EQ,
+		 * it can also increase the voltage of LFPS."
+		 */
+		dev_dbg(usb3phy->dev, "setting pipe for TX tuning\n");
+		ret = rockchip_usb3phy_bulk_update(usb3phy, port->regmap,
+						   rk3328_tx_config, ARRAY_SIZE(rk3328_tx_config));
+
+		/* Power up the pipe */
+		dev_dbg(usb3phy->dev, "setting pipe power on\n");
+		ret = rockchip_usb3phy_bulk_update(usb3phy, port->regmap, rk3328_pipe_pwr_en_config,
+						   ARRAY_SIZE(rk3328_pipe_pwr_en_config));
+	}
+
+	return 0;
+}
+
+static int rockchip_usb3phy_parse_dt(struct rockchip_usb3phy *usb3phy, struct device *dev)
+{
+	int ret;
+
+	usb3phy->clk_pipe = devm_clk_get(dev, "usb3phy-pipe");
+	if (IS_ERR(usb3phy->clk_pipe)) {
+		dev_err(dev, "could not get usb3phy pipe clock\n");
+		return PTR_ERR(usb3phy->clk_pipe);
+	}
+
+	usb3phy->clk_otg = devm_clk_get(dev, "usb3phy-otg");
+	if (IS_ERR(usb3phy->clk_otg)) {
+		dev_err(dev, "could not get usb3phy otg clock\n");
+		return PTR_ERR(usb3phy->clk_otg);
+	}
+
+	usb3phy->clk_ref = devm_clk_get(dev, "refclk-usb3otg");
+	if (IS_ERR(usb3phy->clk_ref)) {
+		dev_err(dev, "could not get usb3phy ref clock\n");
+		return PTR_ERR(usb3phy->clk_ref);
+	}
+
+	usb3phy->u2por_rst = devm_reset_control_get(dev, "usb3phy-u2-por");
+	if (IS_ERR(usb3phy->u2por_rst)) {
+		dev_err(dev, "no usb3phy-u2-por reset control found\n");
+		return PTR_ERR(usb3phy->u2por_rst);
+	}
+
+	usb3phy->u3por_rst = devm_reset_control_get(dev, "usb3phy-u3-por");
+	if (IS_ERR(usb3phy->u3por_rst)) {
+		dev_err(dev, "no usb3phy-u3-por reset control found\n");
+		return PTR_ERR(usb3phy->u3por_rst);
+	}
+
+	usb3phy->pipe_rst = devm_reset_control_get(dev, "usb3phy-pipe-mac");
+	if (IS_ERR(usb3phy->pipe_rst)) {
+		dev_err(dev, "no usb3phy_pipe_mac reset control found\n");
+		return PTR_ERR(usb3phy->pipe_rst);
+	}
+
+	usb3phy->utmi_rst = devm_reset_control_get(dev, "usb3phy-utmi-mac");
+	if (IS_ERR(usb3phy->utmi_rst)) {
+		dev_err(dev, "no usb3phy-utmi-mac reset control found\n");
+		return PTR_ERR(usb3phy->utmi_rst);
+	}
+
+	usb3phy->pipe_apb_rst = devm_reset_control_get(dev, "usb3phy-pipe-apb");
+	if (IS_ERR(usb3phy->pipe_apb_rst)) {
+		dev_err(dev, "no usb3phy-pipe-apb reset control found\n");
+		return PTR_ERR(usb3phy->pipe_apb_rst);
+	}
+
+	usb3phy->utmi_apb_rst = devm_reset_control_get(dev, "usb3phy-utmi-apb");
+	if (IS_ERR(usb3phy->utmi_apb_rst)) {
+		dev_err(dev, "no usb3phy-utmi-apb reset control found\n");
+		return PTR_ERR(usb3phy->utmi_apb_rst);
+	}
+
+	usb3phy->ls_irq = of_irq_get_byname(dev->of_node, "linestate");
+	if (usb3phy->ls_irq < 0) {
+		dev_err(dev, "no linestate irq provided\n");
+		return usb3phy->ls_irq;
+	}
+
+	ret = devm_request_threaded_irq(dev, usb3phy->ls_irq, NULL, rockchip_usb3phy_linestate_irq,
+					IRQF_ONESHOT, "rockchip_usb3phy_ls", usb3phy);
+	if (ret) {
+		dev_err(dev, "failed to request linestate irq handle\n");
+		return ret;
+	}
+
+	usb3phy->bvalid_irq = of_irq_get_byname(dev->of_node, "bvalid");
+	if (usb3phy->bvalid_irq < 0) {
+		dev_err(dev, "no bvalid irq provided\n");
+		return usb3phy->bvalid_irq;
+	}
+
+	ret = devm_request_threaded_irq(dev, usb3phy->bvalid_irq, NULL, rockchip_usb3phy_bvalid_irq,
+					IRQF_ONESHOT, "rockchip_usb3phy_bvalid", usb3phy);
+	if (ret) {
+		dev_err(dev, "failed to request bvalid irq handle\n");
+		return ret;
+	}
+
+	usb3phy->id_irq = of_irq_get_byname(dev->of_node, "id");
+	if (usb3phy->id_irq < 0) {
+		dev_err(dev, "no id irq provided\n");
+		return usb3phy->id_irq;
+	}
+
+	ret = devm_request_threaded_irq(dev, usb3phy->id_irq, NULL, rockchip_usb3phy_id_irq,
+					IRQF_ONESHOT, "rockchip_usb3phy-id", usb3phy);
+	if (ret) {
+		dev_err(dev, "failed to request id irq handle\n");
+		return ret;
+	}
+
+		usb3phy->rxdet_irq = of_irq_get_byname(dev->of_node, "rxdet");
+	if (usb3phy->rxdet_irq < 0) {
+		dev_err(dev, "no rxdet irq provided\n");
+		return usb3phy->rxdet_irq;
+	}
+
+	ret = devm_request_threaded_irq(dev, usb3phy->rxdet_irq, NULL, rockchip_usb3phy_rxdet_irq,
+					IRQF_ONESHOT, "rockchip_usb3phy-rxdet", usb3phy);
+	if (ret) {
+		dev_err(dev, "failed to request rxdet irq handle\n");
+		return ret;
+	}
+
+	return 0;
+}
+
+static int rockchip_usb3phy_exit(struct phy *phy)
+{
+	struct rockchip_usb3phy_port *port = phy_get_drvdata(phy);
+	struct rockchip_usb3phy *usb3phy = dev_get_drvdata(phy->dev.parent);
+
+	dev_dbg(usb3phy->dev, "usb3phy_shutdown\n");
+	rockchip_usb3phy_reset(usb3phy, true, port->type);
+
+	return 0;
+}
+
+static const struct phy_ops rockchip_usb3phy_ops = {
+	.init		= rockchip_usb3phy_init,
+	.exit		= rockchip_usb3phy_exit,
+	.owner		= THIS_MODULE,
+};
+
+static const struct regmap_config rockchip_usb3phy_utmi_port_regmap_config = {
+	.reg_bits = 32,
+	.val_bits = 32,
+	.reg_stride = 4,
+	.max_register = 0x400,
+	.cache_type = REGCACHE_NONE,
+	.fast_io = true,
+	.name = "utmi-port",
+};
+
+static const struct regmap_config rockchip_usb3phy_pipe_port_regmap_config = {
+	.reg_bits = 32,
+	.val_bits = 32,
+	.reg_stride = 4,
+	.max_register = 0x400,
+	.cache_type = REGCACHE_NONE,
+	.fast_io = true,
+	.name = "pipe-port",
+};
+
+static const struct regmap_config rockchip_usb3phy_regmap_config = {
+	.reg_bits = 32,
+	.val_bits = 32,
+	.reg_stride = 4,
+	.max_register = 0x400,
+	.write_flag_mask = REG_WRITE_MASK,
+	.cache_type = REGCACHE_NONE,
+	.fast_io = true,
+};
+
+static int rockchip_usb3phy_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct device_node *np = dev->of_node;
+	struct device_node *child_np;
+	struct phy_provider *provider;
+	struct rockchip_usb3phy *usb3phy;
+	const struct regmap_config regmap_config = rockchip_usb3phy_regmap_config;
+	void __iomem *base;
+	int i, ret;
+
+	dev_dbg(dev, "Probe usb3phy main block\n");
+	usb3phy = devm_kzalloc(dev, sizeof(*usb3phy), GFP_KERNEL);
+	if (!usb3phy)
+		return -ENOMEM;
+
+	ret = rockchip_usb3phy_parse_dt(usb3phy, dev);
+	if (ret) {
+		dev_err(dev, "parse dt failed %i\n", ret);
+		return ret;
+	}
+
+	base = devm_of_iomap(dev, np, 0, NULL);
+	if (IS_ERR(base)) {
+		dev_err(dev, "failed port ioremap\n");
+		return PTR_ERR(base);
+	}
+
+	usb3phy->regmap = devm_regmap_init_mmio(dev, base, &regmap_config);
+	if (IS_ERR(usb3phy->regmap)) {
+		dev_err(dev, "regmap init failed\n");
+		return PTR_ERR(usb3phy->regmap);
+	}
+
+	usb3phy->dev = dev;
+	platform_set_drvdata(pdev, usb3phy);
+
+	/* place block in reset */
+	reset_control_assert(usb3phy->pipe_rst);
+	reset_control_assert(usb3phy->utmi_rst);
+	reset_control_assert(usb3phy->u3por_rst);
+	reset_control_assert(usb3phy->u2por_rst);
+	reset_control_assert(usb3phy->pipe_apb_rst);
+	reset_control_assert(usb3phy->utmi_apb_rst);
+
+	fsleep(20);
+
+	/* take apb interface out of reset */
+	reset_control_deassert(usb3phy->utmi_apb_rst);
+	reset_control_deassert(usb3phy->pipe_apb_rst);
+
+	/* enable usb3phy rx detection to fix disconnection issues */
+	regmap_write(usb3phy->regmap, USB3PHY_WAKEUP_CON_REG,
+		     (USB3_RXDET_EN | (USB3_RXDET_EN << REG_WRITE_SHIFT)));
+
+	dev_dbg(dev, "Completed usb3phy core probe\n");
+
+	/* probe the actual ports */
+	i = 0;
+	for_each_available_child_of_node(np, child_np) {
+		const struct regmap_config *regmap_port_config;
+		struct rockchip_usb3phy_port *port = &usb3phy->ports[i];
+		struct phy *phy;
+
+		if (of_node_name_eq(child_np, "utmi-port")) {
+			port->type = USB3PHY_TYPE_USB2;
+			regmap_port_config = &rockchip_usb3phy_utmi_port_regmap_config;
+		} else if (of_node_name_eq(child_np, "pipe-port")) {
+			port->type	= USB3PHY_TYPE_USB3;
+			regmap_port_config = &rockchip_usb3phy_pipe_port_regmap_config;
+		} else {
+			dev_err(dev, "unknown child node port type %s\n", child_np->name);
+			goto err_port;
+		}
+
+		base = devm_of_iomap(dev, child_np, 0, NULL);
+		if (IS_ERR(base)) {
+			dev_err(dev, "failed port ioremap\n");
+			ret = PTR_ERR(base);
+			goto err_port;
+		}
+
+		port->regmap = devm_regmap_init_mmio(dev, base, regmap_port_config);
+		if (IS_ERR(port->regmap)) {
+			dev_err(dev, "regmap init failed\n");
+			ret = PTR_ERR(port->regmap);
+			goto err_port;
+		}
+
+		phy = devm_phy_create(dev, child_np, &rockchip_usb3phy_ops);
+		if (IS_ERR(phy)) {
+			dev_err_probe(dev, PTR_ERR(phy), "failed to create phy\n");
+			ret = PTR_ERR(phy);
+			goto err_port;
+		}
+
+		port->phy = phy;
+		phy_set_drvdata(port->phy, port);
+
+		/* to prevent out of boundary */
+		if (++i >= USB3PHY_TYPE_MAX) {
+			of_node_put(child_np);
+			break;
+		}
+
+		dev_info(dev, "Completed usb3phy %s port init\n", child_np->name);
+	}
+
+	provider = devm_of_phy_provider_register(dev, of_phy_simple_xlate);
+	return PTR_ERR_OR_ZERO(provider);
+
+err_port:
+	of_node_put(child_np);
+	return ret;
+}
+
+static const struct of_device_id rockchip_usb3phy_dt_ids[] = {
+	{ .compatible = "rockchip,rk3328-usb3phy", },
+	{ /* sentinel */ }
+};
+
+MODULE_DEVICE_TABLE(of, rockchip_usb3phy_dt_ids);
+
+static struct platform_driver rockchip_usb3phy_driver = {
+	.probe		= rockchip_usb3phy_probe,
+	.driver		= {
+		.name	= "rockchip-usb3-phy",
+		.of_match_table = rockchip_usb3phy_dt_ids,
+	},
+};
+
+module_platform_driver(rockchip_usb3phy_driver);
+
+MODULE_AUTHOR("Peter Geis <pgwipeout@gmail.com>");
+MODULE_DESCRIPTION("Rockchip Innosilicon USB3PHY driver");
+MODULE_LICENSE("GPL");
diff --git a/include/dt-bindings/clock/rockchip-ddr.h b/include/dt-bindings/clock/rockchip-ddr.h
new file mode 100644
index 000000000000..b065432e7793
--- /dev/null
+++ b/include/dt-bindings/clock/rockchip-ddr.h
@@ -0,0 +1,63 @@
+/*
+ *
+ * Copyright (C) 2017 ROCKCHIP, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#ifndef _DT_BINDINGS_CLOCK_ROCKCHIP_DDR_H
+#define _DT_BINDINGS_CLOCK_ROCKCHIP_DDR_H
+
+#define DDR2_DEFAULT	(0)
+
+#define DDR3_800D	(0)	/* 5-5-5 */
+#define DDR3_800E	(1)	/* 6-6-6 */
+#define DDR3_1066E	(2)	/* 6-6-6 */
+#define DDR3_1066F	(3)	/* 7-7-7 */
+#define DDR3_1066G	(4)	/* 8-8-8 */
+#define DDR3_1333F	(5)	/* 7-7-7 */
+#define DDR3_1333G	(6)	/* 8-8-8 */
+#define DDR3_1333H	(7)	/* 9-9-9 */
+#define DDR3_1333J	(8)	/* 10-10-10 */
+#define DDR3_1600G	(9)	/* 8-8-8 */
+#define DDR3_1600H	(10)	/* 9-9-9 */
+#define DDR3_1600J	(11)	/* 10-10-10 */
+#define DDR3_1600K	(12)	/* 11-11-11 */
+#define DDR3_1866J	(13)	/* 10-10-10 */
+#define DDR3_1866K	(14)	/* 11-11-11 */
+#define DDR3_1866L	(15)	/* 12-12-12 */
+#define DDR3_1866M	(16)	/* 13-13-13 */
+#define DDR3_2133K	(17)	/* 11-11-11 */
+#define DDR3_2133L	(18)	/* 12-12-12 */
+#define DDR3_2133M	(19)	/* 13-13-13 */
+#define DDR3_2133N	(20)	/* 14-14-14 */
+#define DDR3_DEFAULT	(21)
+#define DDR_DDR2	(22)
+#define DDR_LPDDR	(23)
+#define DDR_LPDDR2	(24)
+
+#define DDR4_1600J	(0)	/* 10-10-10 */
+#define DDR4_1600K	(1)	/* 11-11-11 */
+#define DDR4_1600L	(2)	/* 12-12-12 */
+#define DDR4_1866L	(3)	/* 12-12-12 */
+#define DDR4_1866M	(4)	/* 13-13-13 */
+#define DDR4_1866N	(5)	/* 14-14-14 */
+#define DDR4_2133N	(6)	/* 14-14-14 */
+#define DDR4_2133P	(7)	/* 15-15-15 */
+#define DDR4_2133R	(8)	/* 16-16-16 */
+#define DDR4_2400P	(9)	/* 15-15-15 */
+#define DDR4_2400R	(10)	/* 16-16-16 */
+#define DDR4_2400U	(11)	/* 18-18-18 */
+#define DDR4_DEFAULT	(12)
+
+#define PAUSE_CPU_STACK_SIZE	16
+
+#endif
diff --git a/include/dt-bindings/memory/rk3328-dram.h b/include/dt-bindings/memory/rk3328-dram.h
new file mode 100644
index 000000000000..171f41c256d3
--- /dev/null
+++ b/include/dt-bindings/memory/rk3328-dram.h
@@ -0,0 +1,159 @@
+/*
+ * Copyright (c) 2017 Fuzhou Rockchip Electronics Co., Ltd
+ *
+ * This file is dual-licensed: you can use it either under the terms
+ * of the GPL or the X11 license, at your option. Note that this dual
+ * licensing only applies to this file, and not this project as a
+ * whole.
+ *
+ *  a) This library is free software; you can redistribute it and/or
+ *     modify it under the terms of the GNU General Public License as
+ *     published by the Free Software Foundation; either version 2 of the
+ *     License, or (at your option) any later version.
+ *
+ *     This library is distributed in the hope that it will be useful,
+ *     but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *     GNU General Public License for more details.
+ *
+ * Or, alternatively,
+ *
+ *  b) Permission is hereby granted, free of charge, to any person
+ *     obtaining a copy of this software and associated documentation
+ *     files (the "Software"), to deal in the Software without
+ *     restriction, including without limitation the rights to use,
+ *     copy, modify, merge, publish, distribute, sublicense, and/or
+ *     sell copies of the Software, and to permit persons to whom the
+ *     Software is furnished to do so, subject to the following
+ *     conditions:
+ *
+ *     The above copyright notice and this permission notice shall be
+ *     included in all copies or substantial portions of the Software.
+ *
+ *     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ *     EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
+ *     OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ *     NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+ *     HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+ *     WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ *     FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ *     OTHER DEALINGS IN THE SOFTWARE.
+ */
+#ifndef _DT_BINDINGS_DRAM_ROCKCHIP_RK3328_H
+#define _DT_BINDINGS_DRAM_ROCKCHIP_RK3328_H
+
+#define DDR3_DS_34ohm			(34)
+#define DDR3_DS_40ohm			(40)
+
+#define DDR3_ODT_DIS			(0)
+#define DDR3_ODT_40ohm			(40)
+#define DDR3_ODT_60ohm			(60)
+#define DDR3_ODT_120ohm			(120)
+
+#define LP2_DS_34ohm			(34)
+#define LP2_DS_40ohm			(40)
+#define LP2_DS_48ohm			(48)
+#define LP2_DS_60ohm			(60)
+#define LP2_DS_68_6ohm			(68)	/* optional */
+#define LP2_DS_80ohm			(80)
+#define LP2_DS_120ohm			(120)	/* optional */
+
+#define LP3_DS_34ohm			(34)
+#define LP3_DS_40ohm			(40)
+#define LP3_DS_48ohm			(48)
+#define LP3_DS_60ohm			(60)
+#define LP3_DS_80ohm			(80)
+#define LP3_DS_34D_40U			(3440)
+#define LP3_DS_40D_48U			(4048)
+#define LP3_DS_34D_48U			(3448)
+
+#define LP3_ODT_DIS			(0)
+#define LP3_ODT_60ohm			(60)
+#define LP3_ODT_120ohm			(120)
+#define LP3_ODT_240ohm			(240)
+
+#define LP4_PDDS_40ohm			(40)
+#define LP4_PDDS_48ohm			(48)
+#define LP4_PDDS_60ohm			(60)
+#define LP4_PDDS_80ohm			(80)
+#define LP4_PDDS_120ohm			(120)
+#define LP4_PDDS_240ohm			(240)
+
+#define LP4_DQ_ODT_40ohm		(40)
+#define LP4_DQ_ODT_48ohm		(48)
+#define LP4_DQ_ODT_60ohm		(60)
+#define LP4_DQ_ODT_80ohm		(80)
+#define LP4_DQ_ODT_120ohm		(120)
+#define LP4_DQ_ODT_240ohm		(240)
+#define LP4_DQ_ODT_DIS			(0)
+
+#define LP4_CA_ODT_40ohm		(40)
+#define LP4_CA_ODT_48ohm		(48)
+#define LP4_CA_ODT_60ohm		(60)
+#define LP4_CA_ODT_80ohm		(80)
+#define LP4_CA_ODT_120ohm		(120)
+#define LP4_CA_ODT_240ohm		(240)
+#define LP4_CA_ODT_DIS			(0)
+
+#define DDR4_DS_34ohm			(34)
+#define DDR4_DS_48ohm			(48)
+#define DDR4_RTT_NOM_DIS		(0)
+#define DDR4_RTT_NOM_60ohm		(60)
+#define DDR4_RTT_NOM_120ohm		(120)
+#define DDR4_RTT_NOM_40ohm		(40)
+#define DDR4_RTT_NOM_240ohm		(240)
+#define DDR4_RTT_NOM_48ohm		(48)
+#define DDR4_RTT_NOM_80ohm		(80)
+#define DDR4_RTT_NOM_34ohm		(34)
+
+#define PHY_DDR3_RON_RTT_DISABLE	(0)
+#define PHY_DDR3_RON_RTT_451ohm		(1)
+#define PHY_DDR3_RON_RTT_225ohm		(2)
+#define PHY_DDR3_RON_RTT_150ohm		(3)
+#define PHY_DDR3_RON_RTT_112ohm		(4)
+#define PHY_DDR3_RON_RTT_90ohm		(5)
+#define PHY_DDR3_RON_RTT_75ohm		(6)
+#define PHY_DDR3_RON_RTT_64ohm		(7)
+#define PHY_DDR3_RON_RTT_56ohm		(16)
+#define PHY_DDR3_RON_RTT_50ohm		(17)
+#define PHY_DDR3_RON_RTT_45ohm		(18)
+#define PHY_DDR3_RON_RTT_41ohm		(19)
+#define PHY_DDR3_RON_RTT_37ohm		(20)
+#define PHY_DDR3_RON_RTT_34ohm		(21)
+#define PHY_DDR3_RON_RTT_33ohm		(22)
+#define PHY_DDR3_RON_RTT_30ohm		(23)
+#define PHY_DDR3_RON_RTT_28ohm		(24)
+#define PHY_DDR3_RON_RTT_26ohm		(25)
+#define PHY_DDR3_RON_RTT_25ohm		(26)
+#define PHY_DDR3_RON_RTT_23ohm		(27)
+#define PHY_DDR3_RON_RTT_22ohm		(28)
+#define PHY_DDR3_RON_RTT_21ohm		(29)
+#define PHY_DDR3_RON_RTT_20ohm		(30)
+#define PHY_DDR3_RON_RTT_19ohm		(31)
+
+#define PHY_DDR4_LPDDR3_RON_RTT_DISABLE (0)
+#define PHY_DDR4_LPDDR3_RON_RTT_480ohm	(1)
+#define PHY_DDR4_LPDDR3_RON_RTT_240ohm	(2)
+#define PHY_DDR4_LPDDR3_RON_RTT_160ohm	(3)
+#define PHY_DDR4_LPDDR3_RON_RTT_120ohm	(4)
+#define PHY_DDR4_LPDDR3_RON_RTT_96ohm	(5)
+#define PHY_DDR4_LPDDR3_RON_RTT_80ohm	(6)
+#define PHY_DDR4_LPDDR3_RON_RTT_68ohm	(7)
+#define PHY_DDR4_LPDDR3_RON_RTT_60ohm	(16)
+#define PHY_DDR4_LPDDR3_RON_RTT_53ohm	(17)
+#define PHY_DDR4_LPDDR3_RON_RTT_48ohm	(18)
+#define PHY_DDR4_LPDDR3_RON_RTT_43ohm	(19)
+#define PHY_DDR4_LPDDR3_RON_RTT_40ohm	(20)
+#define PHY_DDR4_LPDDR3_RON_RTT_37ohm	(21)
+#define PHY_DDR4_LPDDR3_RON_RTT_34ohm	(22)
+#define PHY_DDR4_LPDDR3_RON_RTT_32ohm	(23)
+#define PHY_DDR4_LPDDR3_RON_RTT_30ohm	(24)
+#define PHY_DDR4_LPDDR3_RON_RTT_28ohm	(25)
+#define PHY_DDR4_LPDDR3_RON_RTT_26ohm	(26)
+#define PHY_DDR4_LPDDR3_RON_RTT_25ohm	(27)
+#define PHY_DDR4_LPDDR3_RON_RTT_24ohm	(28)
+#define PHY_DDR4_LPDDR3_RON_RTT_22ohm	(29)
+#define PHY_DDR4_LPDDR3_RON_RTT_21ohm	(30)
+#define PHY_DDR4_LPDDR3_RON_RTT_20ohm	(31)
+
+#endif /*_DT_BINDINGS_DRAM_ROCKCHIP_RK3328_H*/
diff --git a/include/soc/rockchip/rk3228_grf.h b/include/soc/rockchip/rk3228_grf.h
new file mode 100644
index 000000000000..e37406814fad
--- /dev/null
+++ b/include/soc/rockchip/rk3228_grf.h
@@ -0,0 +1,14 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
+/*
+ * Rockchip General Register Files definitions for RK3228
+ *
+ * Author: Paolo Sabatino <paolo.sabatino@gmail.com>
+ */
+
+#ifndef __SOC_RK3228_GRF_H
+#define __SOC_RK3228_GRF_H
+
+#define RK3228_GRF_OS_REG2		0x5d0
+#define RK3228_GRF_OS_REG2_DDRTYPE	GENMASK(15, 13)
+
+#endif
diff --git a/include/soc/rockchip/rk3328_grf.h b/include/soc/rockchip/rk3328_grf.h
new file mode 100644
index 000000000000..bf6d209be7e6
--- /dev/null
+++ b/include/soc/rockchip/rk3328_grf.h
@@ -0,0 +1,14 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
+/*
+ * Rockchip General Register Files definitions for RK3328
+ *
+ * Author: Paolo Sabatino <paolo.sabatino@gmail.com>
+ */
+
+#ifndef __SOC_RK3328_GRF_H
+#define __SOC_RK3328_GRF_H
+
+#define RK3328_GRF_OS_REG2		0x5d0
+#define RK3328_GRF_OS_REG2_DDRTYPE	GENMASK(15, 13)
+
+#endif
diff --git a/include/soc/rockchip/rockchip_sip.h b/include/soc/rockchip/rockchip_sip.h
index 501ad1fedb20..92117958adc7 100644
--- a/include/soc/rockchip/rockchip_sip.h
+++ b/include/soc/rockchip/rockchip_sip.h
@@ -19,5 +19,16 @@
 #define ROCKCHIP_SIP_CONFIG_DRAM_CLR_IRQ	0x06
 #define ROCKCHIP_SIP_CONFIG_DRAM_SET_PARAM	0x07
 #define ROCKCHIP_SIP_CONFIG_DRAM_SET_ODT_PD	0x08
+#define ROCKCHIP_SIP_CONFIG_DRAM_GET_VERSION	0x08
+
+#define ROCKCHIP_SIP_SHARE_MEM			0x82000009
+
+/* Share mem page types */
+typedef enum {
+    SHARE_PAGE_TYPE_INVALID = 0,
+    SHARE_PAGE_TYPE_UARTDBG,
+    SHARE_PAGE_TYPE_DDR,
+    SHARE_PAGE_TYPE_MAX,
+} share_page_type_t;
 
 #endif
-- 
2.51.2

