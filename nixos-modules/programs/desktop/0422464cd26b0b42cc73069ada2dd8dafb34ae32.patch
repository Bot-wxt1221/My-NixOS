diff --git a/src/input/mod.rs b/src/input/mod.rs
index 5e055e6e..2d038208 100644
--- a/src/input/mod.rs
+++ b/src/input/mod.rs
@@ -20,6 +20,7 @@ use smithay::backend::input::{
 };
 use smithay::backend::libinput::LibinputInputBackend;
 use smithay::input::dnd::DnDGrab;
+use smithay::input::keyboard::KeyboardHandle;
 use smithay::input::keyboard::{keysyms, FilterResult, Keysym, Layout, ModifiersState};
 use smithay::input::pointer::{
     AxisFrame, ButtonEvent, CursorIcon, CursorImageStatus, Focus, GestureHoldBeginEvent,
@@ -360,16 +361,18 @@ impl State {
             .is_some_and(KeyboardShortcutsInhibitor::is_active)
     }
 
-    fn on_keyboard<I: InputBackend>(
+    pub fn on_keyboard_real(
         &mut self,
-        event: I::KeyboardKeyEvent,
+        key: Keycode,
+        state: KeyState,
+        time: u32,
+        keyboard: KeyboardHandle<Self>,
         consumed_by_a11y: &mut bool,
     ) {
         let mod_key = self.backend.mod_key(&self.niri.config.borrow());
 
         let serial = SERIAL_COUNTER.next_serial();
-        let time = Event::time_msec(&event);
-        let pressed = event.state() == KeyState::Pressed;
+        let pressed = state == KeyState::Pressed;
 
         // Stop bind key repeat on any release. This won't work 100% correctly in cases like:
         // 1. Press Mod
@@ -397,11 +400,8 @@ impl State {
         // other changes.
         #[cfg(feature = "dbus")]
         let block = {
-            let block = self.a11y_process_key(
-                Duration::from_millis(u64::from(time)),
-                event.key_code(),
-                event.state(),
-            );
+            let block = self.a11y_process_key(Duration::from_millis(u64::from(time)), key, state);
+
             if block != KbMonBlock::Pass {
                 *consumed_by_a11y = true;
             }
@@ -415,14 +415,14 @@ impl State {
         #[cfg(not(feature = "dbus"))]
         let _ = consumed_by_a11y;
 
-        let Some(Some(bind)) = self.niri.seat.get_keyboard().unwrap().input(
+        let Some(Some(bind)) = keyboard.input(
             self,
-            event.key_code(),
-            event.state(),
+            key,
+            state,
             serial,
             time,
             |this, mods, keysym| {
-                let key_code = event.key_code();
+                let key_code = key;
                 let modified = keysym.modified_sym();
                 let raw = keysym.raw_latin_sym_or_raw_current_sym();
                 let modifiers = modifiers_from_state(*mods);
@@ -556,6 +556,19 @@ impl State {
 
         self.start_key_repeat(bind);
     }
+    fn on_keyboard<I: InputBackend>(
+        &mut self,
+        event: I::KeyboardKeyEvent,
+        consumed_by_a11y: &mut bool,
+    ) {
+        self.on_keyboard_real(
+            event.key_code(),
+            event.state(),
+            Event::time_msec(&event),
+            self.niri.seat.get_keyboard().unwrap(),
+            consumed_by_a11y,
+        );
+    }
 
     fn start_key_repeat(&mut self, bind: Bind) {
         if !bind.repeat {
diff --git a/src/niri.rs b/src/niri.rs
index 324b3c26..efdc8970 100644
--- a/src/niri.rs
+++ b/src/niri.rs
@@ -19,7 +19,7 @@ use niri_config::{
     WorkspaceReference, Xkb,
 };
 use smithay::backend::allocator::Fourcc;
-use smithay::backend::input::Keycode;
+use smithay::backend::input::{KeyState, Keycode};
 use smithay::backend::renderer::damage::OutputDamageTracker;
 use smithay::backend::renderer::element::memory::MemoryRenderBufferRenderElement;
 use smithay::backend::renderer::element::surface::{
@@ -46,6 +46,8 @@ use smithay::desktop::{
     find_popup_root_surface, layer_map_for_output, LayerMap, LayerSurface, PopupGrab, PopupManager,
     PopupUngrabStrategy, Space, Window, WindowSurfaceType,
 };
+use smithay::input::keyboard::xkb::ModMask;
+use smithay::input::keyboard::KeyboardHandle;
 use smithay::input::keyboard::{Layout as KeyboardLayout, XkbConfig};
 use smithay::input::pointer::{
     CursorIcon, CursorImageStatus, CursorImageSurfaceData, Focus,
@@ -107,7 +109,7 @@ use smithay::wayland::socket::ListeningSocketSource;
 use smithay::wayland::tablet_manager::TabletManagerState;
 use smithay::wayland::text_input::TextInputManagerState;
 use smithay::wayland::viewporter::ViewporterState;
-use smithay::wayland::virtual_keyboard::VirtualKeyboardManagerState;
+use smithay::wayland::virtual_keyboard::{VirtualKeyboardHandler, VirtualKeyboardManagerState};
 use smithay::wayland::xdg_activation::XdgActivationState;
 use smithay::wayland::xdg_foreign::XdgForeignState;
 
@@ -6558,6 +6560,60 @@ fn scale_relocate_crop<E: Element>(
     CropRenderElement::from_element(elem, output_scale, ws_geo)
 }
 
+impl VirtualKeyboardHandler for State {
+    fn on_keyboard_event(
+        &mut self,
+        keycode: Keycode,
+        state: KeyState,
+        time: u32,
+        keyboard: KeyboardHandle<Self>,
+    ) {
+        // Make sure some logic like workspace clean-up has a chance to run before doing actions.
+        self.niri.advance_animations();
+
+        if self.niri.monitors_active {
+            // Notify the idle-notifier of activity.
+            self.niri.notify_activity();
+        } else {
+            // Power on monitors if they were off.
+            self.niri.activate_monitors(&mut self.backend);
+
+            // Notify the idle-notifier of activity only if we're also powering on the
+            // monitors.
+            self.niri.notify_activity();
+        }
+        let mut consumed_by_a11y = false;
+
+        self.on_keyboard_real(keycode, state, time, keyboard,&mut consumed_by_a11y);
+
+        let hide_hotkey_overlay = self.niri.hotkey_overlay.is_open();
+
+        let hide_exit_confirm_dialog = self.niri.exit_confirm_dialog.is_open();
+        if consumed_by_a11y {
+            return;
+        }
+
+        // Do this last so that screenshot still gets it.
+        if hide_hotkey_overlay && self.niri.hotkey_overlay.hide() {
+            self.niri.queue_redraw_all();
+        }
+
+        if hide_exit_confirm_dialog && self.niri.exit_confirm_dialog.hide() {
+            self.niri.queue_redraw_all();
+        }
+    }
+
+    /// We handle modifiers when the key event is sent
+    fn on_keyboard_modifiers(
+        &mut self,
+        _depressed_mods: ModMask,
+        _latched_mods: ModMask,
+        _locked_mods: ModMask,
+        _keyboard: KeyboardHandle<Self>,
+    ) {
+    }
+}
+
 niri_render_elements! {
     OutputRenderElements<R> => {
         Monitor = MonitorRenderElement<R>,
