From e8042b3c4ea4aa04b67c321ab49178a17d276b3e Mon Sep 17 00:00:00 2001
From: wxt <3264117476@qq.com>
Date: Sun, 14 Sep 2025 18:18:06 +0800
Subject: [PATCH] feat: handle virtual keyboard by ourself

---
 src/input/mod.rs | 36 +++++++++++++++++++----------
 src/niri.rs      | 60 ++++++++++++++++++++++++++++++++++++++++++++++--
 2 files changed, 82 insertions(+), 14 deletions(-)

diff --git a/src/input/mod.rs b/src/input/mod.rs
index 9fc48c09..079b1fef 100644
--- a/src/input/mod.rs
+++ b/src/input/mod.rs
@@ -17,6 +17,7 @@ use smithay::backend::input::{
     TabletToolTipState, TouchEvent,
 };
 use smithay::backend::libinput::LibinputInputBackend;
+use smithay::input::keyboard::KeyboardHandle;
 use smithay::input::keyboard::{keysyms, FilterResult, Keysym, Layout, ModifiersState};
 use smithay::input::pointer::{
     AxisFrame, ButtonEvent, CursorIcon, CursorImageStatus, Focus, GestureHoldBeginEvent,
@@ -333,16 +334,18 @@ impl State {
             .is_some_and(KeyboardShortcutsInhibitor::is_active)
     }
 
-    fn on_keyboard<I: InputBackend>(
+    fn on_keyboard_real<I: InputBackend>(
         &mut self,
-        event: I::KeyboardKeyEvent,
+        key: Keycode,
+        state: KeyState,
+        time: u32,
+        keyboard: KeyboardHandle<Self>,
         consumed_by_a11y: &mut bool,
     ) {
         let mod_key = self.backend.mod_key(&self.niri.config.borrow());
 
         let serial = SERIAL_COUNTER.next_serial();
-        let time = Event::time_msec(&event);
-        let pressed = event.state() == KeyState::Pressed;
+        let pressed = state == KeyState::Pressed;
 
         // Stop bind key repeat on any release. This won't work 100% correctly in cases like:
         // 1. Press Mod
@@ -366,23 +369,19 @@ impl State {
         // Accessibility modifier grabs should override XKB state changes (e.g. Caps Lock), so we
         // need to process them before keyboard.input() below.
         #[cfg(feature = "dbus")]
-        if self.a11y_process_key(
-            Duration::from_millis(u64::from(time)),
-            event.key_code(),
-            event.state(),
-        ) {
+        if self.a11y_process_key(Duration::from_millis(u64::from(time)), key, state) {
             *consumed_by_a11y = true;
             return;
         }
 
         let Some(Some(bind)) = self.niri.seat.get_keyboard().unwrap().input(
             self,
-            event.key_code(),
-            event.state(),
+            key,
+            state,
             serial,
             time,
             |this, mods, keysym| {
-                let key_code = event.key_code();
+                let key_code = key;
                 let modified = keysym.modified_sym();
                 let raw = keysym.raw_latin_sym_or_raw_current_sym();
 
@@ -456,6 +455,19 @@ impl State {
 
         self.start_key_repeat(bind);
     }
+    fn on_keyboard<I: InputBackend>(
+        &mut self,
+        event: I::KeyboardKeyEvent,
+        consumed_by_a11y: &mut bool,
+    ) {
+        self.on_keyboard_real(
+            event.key_code(),
+            event.state(),
+            Event::time_msec(&event),
+            self.niri.seat.get_keyboard().unwrap(),
+            consumed_by_a11y,
+        );
+    }
 
     fn start_key_repeat(&mut self, bind: Bind) {
         if !bind.repeat {
diff --git a/src/niri.rs b/src/niri.rs
index 612d5417..0e8dea70 100644
--- a/src/niri.rs
+++ b/src/niri.rs
@@ -19,7 +19,7 @@ use niri_config::{
     WorkspaceReference, Xkb,
 };
 use smithay::backend::allocator::Fourcc;
-use smithay::backend::input::Keycode;
+use smithay::backend::input::{KeyState, Keycode};
 use smithay::backend::renderer::damage::OutputDamageTracker;
 use smithay::backend::renderer::element::memory::MemoryRenderBufferRenderElement;
 use smithay::backend::renderer::element::surface::{
@@ -46,6 +46,8 @@ use smithay::desktop::{
     find_popup_root_surface, layer_map_for_output, LayerMap, LayerSurface, PopupGrab, PopupManager,
     PopupUngrabStrategy, Space, Window, WindowSurfaceType,
 };
+use smithay::input::keyboard::xkb::ModMask;
+use smithay::input::keyboard::KeyboardHandle;
 use smithay::input::keyboard::{Layout as KeyboardLayout, XkbConfig};
 use smithay::input::pointer::{
     CursorIcon, CursorImageStatus, CursorImageSurfaceData, Focus,
@@ -107,7 +109,7 @@ use smithay::wayland::socket::ListeningSocketSource;
 use smithay::wayland::tablet_manager::TabletManagerState;
 use smithay::wayland::text_input::TextInputManagerState;
 use smithay::wayland::viewporter::ViewporterState;
-use smithay::wayland::virtual_keyboard::VirtualKeyboardManagerState;
+use smithay::wayland::virtual_keyboard::{VirtualKeyboardHandler, VirtualKeyboardManagerState};
 use smithay::wayland::xdg_activation::XdgActivationState;
 use smithay::wayland::xdg_foreign::XdgForeignState;
 
@@ -6305,6 +6307,60 @@ fn scale_relocate_crop<E: Element>(
     CropRenderElement::from_element(elem, output_scale, ws_geo)
 }
 
+impl VirtualKeyboardHandler for State {
+    fn on_keyboard_event(
+        &mut self,
+        keycode: Keycode,
+        state: KeyState,
+        time: u32,
+        keyboard: KeyboardHandle<Self>,
+    ) {
+        // Make sure some logic like workspace clean-up has a chance to run before doing actions.
+        self.niri.advance_animations();
+
+        if self.niri.monitors_active {
+            // Notify the idle-notifier of activity.
+            self.niri.notify_activity();
+        } else {
+            // Power on monitors if they were off.
+            self.niri.activate_monitors(&mut self.backend);
+
+            // Notify the idle-notifier of activity only if we're also powering on the
+            // monitors.
+            self.niri.notify_activity();
+        }
+        let mut consumed_by_a11y = false;
+
+        self.on_keyboard_real(keycode, state, time, keyboard, consumed_by_a11y);
+
+        let hide_hotkey_overlay = self.niri.hotkey_overlay.is_open();
+
+        let hide_exit_confirm_dialog = self.niri.exit_confirm_dialog.is_open();
+        if consumed_by_a11y {
+            return;
+        }
+
+        // Do this last so that screenshot still gets it.
+        if hide_hotkey_overlay && self.niri.hotkey_overlay.hide() {
+            self.niri.queue_redraw_all();
+        }
+
+        if hide_exit_confirm_dialog && self.niri.exit_confirm_dialog.hide() {
+            self.niri.queue_redraw_all();
+        }
+    }
+
+    /// We handle modifiers when the key event is sent
+    fn on_keyboard_modifiers(
+        &mut self,
+        _depressed_mods: ModMask,
+        _latched_mods: ModMask,
+        _locked_mods: ModMask,
+        _keyboard: KeyboardHandle<Self>,
+    ) {
+    }
+}
+
 niri_render_elements! {
     OutputRenderElements<R> => {
         Monitor = MonitorRenderElement<R>,
-- 
2.50.1

