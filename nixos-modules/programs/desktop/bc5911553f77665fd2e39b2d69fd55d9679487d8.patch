From 53321eb8ff56ad5bf704b68da1ae2b8758bc5466 Mon Sep 17 00:00:00 2001
From: wxt <3264117476@qq.com>
Date: Sat, 16 Aug 2025 11:29:10 +0800
Subject: [PATCH] feat: allow handle virtual keyboard input by WM

---
 Cargo.toml                                    |  1 +
 src/wayland/virtual_keyboard/mod.rs           | 17 ++++-
 .../virtual_keyboard_handle.rs                | 76 +++++++++++++++++--
 3 files changed, 86 insertions(+), 8 deletions(-)

diff --git a/Cargo.toml b/Cargo.toml
index f1a1ab581..76c8e1926 100644
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -110,6 +110,7 @@ wayland_frontend = ["wayland-server", "wayland-protocols", "wayland-protocols-wl
 x11rb_event_source = ["x11rb"]
 xwayland = ["encoding_rs", "wayland_frontend", "x11rb/composite", "x11rb/xfixes", "x11rb/randr", "x11rb_event_source", "scopeguard"]
 test_all_features = ["default", "use_system_lib", "renderer_glow", "renderer_test"]
+virtual_keyboard_not_use_default_handler = [ ]
 
 [[example]]
 name = "minimal"
diff --git a/src/wayland/virtual_keyboard/mod.rs b/src/wayland/virtual_keyboard/mod.rs
index 335221e33..d8a132df7 100644
--- a/src/wayland/virtual_keyboard/mod.rs
+++ b/src/wayland/virtual_keyboard/mod.rs
@@ -57,9 +57,10 @@ use wayland_protocols_misc::zwp_virtual_keyboard_v1::server::{
 };
 use wayland_server::{backend::GlobalId, Client, DataInit, Dispatch, DisplayHandle, GlobalDispatch, New};
 
-use crate::input::{Seat, SeatHandler};
-
 use self::virtual_keyboard_handle::VirtualKeyboardHandle;
+use crate::backend::input::{KeyState, Keycode};
+use crate::input::keyboard::KeyboardHandle;
+use crate::input::{Seat, SeatHandler};
 
 const MANAGER_VERSION: u32 = 1;
 
@@ -91,6 +92,18 @@ where
     display.create_global::<D, ZwpVirtualKeyboardManagerV1, _>(MANAGER_VERSION, data)
 }
 
+/// Handle keyboard event
+pub trait VirtualKeyboardHandler: SeatHandler {
+    /// Handle KeyboardEvent as usual
+    fn on_keyboard_event(
+        &mut self,
+        keycode: Keycode,
+        state: KeyState,
+        time: u32,
+        keyboard: KeyboardHandle<Self>,
+    );
+}
+
 impl VirtualKeyboardManagerState {
     /// Initialize a virtual keyboard manager global.
     pub fn new<D, F>(display: &DisplayHandle, filter: F) -> Self
diff --git a/src/wayland/virtual_keyboard/virtual_keyboard_handle.rs b/src/wayland/virtual_keyboard/virtual_keyboard_handle.rs
index 502893fc2..5672ac1c4 100644
--- a/src/wayland/virtual_keyboard/virtual_keyboard_handle.rs
+++ b/src/wayland/virtual_keyboard/virtual_keyboard_handle.rs
@@ -10,20 +10,22 @@ use wayland_protocols_misc::zwp_virtual_keyboard_v1::server::zwp_virtual_keyboar
     self, ZwpVirtualKeyboardV1,
 };
 use wayland_server::{
-    backend::ClientId,
-    protocol::wl_keyboard::{KeyState, KeymapFormat},
-    Client, DataInit, Dispatch, DisplayHandle, Resource,
+    backend::ClientId, protocol::wl_keyboard::KeymapFormat, Client, DataInit, Dispatch, DisplayHandle,
+    Resource,
 };
 use xkbcommon::xkb;
 
 use crate::input::keyboard::{KeyboardTarget, KeymapFile, ModifiersState};
+use crate::wayland::input_method::InputMethodSeat;
 use crate::{
     input::{Seat, SeatHandler},
     utils::SERIAL_COUNTER,
     wayland::seat::{keyboard::for_each_focused_kbds, WaylandFocus},
 };
 
-use super::VirtualKeyboardManagerState;
+use crate::backend::input::KeyState;
+
+use super::{VirtualKeyboardHandler, VirtualKeyboardManagerState};
 
 #[derive(Debug, Default)]
 pub(crate) struct VirtualKeyboard {
@@ -75,11 +77,12 @@ impl<D> Dispatch<ZwpVirtualKeyboardV1, VirtualKeyboardUserData<D>, D> for Virtua
 where
     D: Dispatch<ZwpVirtualKeyboardV1, VirtualKeyboardUserData<D>>,
     D: SeatHandler + 'static,
+    D: VirtualKeyboardHandler,
     <D as SeatHandler>::KeyboardFocus: WaylandFocus,
 {
     fn request(
         user_data: &mut D,
-        _client: &Client,
+        client: &Client,
         virtual_keyboard: &ZwpVirtualKeyboardV1,
         request: zwp_virtual_keyboard_v1::Request,
         data: &VirtualKeyboardUserData<D>,
@@ -90,6 +93,67 @@ where
             zwp_virtual_keyboard_v1::Request::Keymap { format, fd, size } => {
                 update_keymap(data, format, fd, size as usize);
             }
+            #[cfg(feature = "virtual_keyboard_not_use_default_handler")]
+            zwp_virtual_keyboard_v1::Request::Key { time, key, state } => {
+                // Ensure keymap was initialized.
+                let mut virtual_data = data.handle.inner.lock().unwrap();
+                let vk_state = match virtual_data.state.as_mut() {
+                    Some(vk_state) => vk_state,
+                    None => {
+                        virtual_keyboard.post_error(NoKeymap, "`key` sent before keymap.");
+                        return;
+                    }
+                };
+                // Ensure virtual keyboard's keymap is active.
+                let keyboard_handle = data.seat.get_keyboard().unwrap();
+
+                let ime_keyboard_grabbed = data
+                    .seat
+                    .input_method()
+                    .inner
+                    .lock()
+                    .unwrap()
+                    .keyboard_grab
+                    .inner
+                    .lock()
+                    .unwrap()
+                    .grab
+                    .clone();
+                if ime_keyboard_grabbed.is_some()
+                    && ime_keyboard_grabbed.unwrap().client().unwrap() == *client
+                {
+                    use wayland_server::protocol::wl_keyboard::KeyState;
+                    let mut internal = keyboard_handle.arc.internal.lock().unwrap();
+                    let focus = internal.focus.as_mut().map(|(focus, _)| focus);
+                    keyboard_handle.send_keymap(user_data, &focus, &vk_state.keymap, vk_state.mods);
+                    if let Some(wl_surface) = focus.and_then(|f| f.wl_surface()) {
+                        for_each_focused_kbds(&data.seat, &wl_surface, |kbd| {
+                            // This should be wl_keyboard::KeyState, but the protocol does not state
+                            // the parameter is an enum.
+                            let key_state = if state == 1 {
+                                KeyState::Pressed
+                            } else {
+                                KeyState::Released
+                            };
+
+                            kbd.key(SERIAL_COUNTER.next_serial().0, time, key, key_state);
+                        });
+                    }
+                } else {
+                    {
+                        let mut internal = keyboard_handle.arc.internal.lock().unwrap();
+                        let focus = internal.focus.as_mut().map(|(focus, _)| focus);
+                        keyboard_handle.send_keymap(user_data, &focus, &vk_state.keymap, vk_state.mods);
+                    }
+                    let key_state = if state == 1 {
+                        KeyState::Pressed
+                    } else {
+                        KeyState::Released
+                    };
+                    user_data.on_keyboard_event((key + 8).into(), key_state, time, keyboard_handle);
+                }
+            }
+            #[cfg(not(feature = "virtual_keyboard_not_use_default_handler"))]
             zwp_virtual_keyboard_v1::Request::Key { time, key, state } => {
                 // Ensure keymap was initialized.
                 let mut virtual_data = data.handle.inner.lock().unwrap();
@@ -106,7 +170,7 @@ where
                 let mut internal = keyboard_handle.arc.internal.lock().unwrap();
                 let focus = internal.focus.as_mut().map(|(focus, _)| focus);
                 keyboard_handle.send_keymap(user_data, &focus, &vk_state.keymap, vk_state.mods);
-
+                use wayland_server::protocol::wl_keyboard::KeyState;
                 if let Some(wl_surface) = focus.and_then(|f| f.wl_surface()) {
                     for_each_focused_kbds(&data.seat, &wl_surface, |kbd| {
                         // This should be wl_keyboard::KeyState, but the protocol does not state
-- 
2.50.1

