From bc5911553f77665fd2e39b2d69fd55d9679487d8 Mon Sep 17 00:00:00 2001
From: wxt <3264117476@qq.com>
Date: Sat, 16 Aug 2025 11:29:10 +0800
Subject: [PATCH] feat: allow handle virtual keyboard input by WM

---
 Cargo.toml                                    |  1 +
 src/wayland/virtual_keyboard/mod.rs           |  8 +++-
 .../virtual_keyboard_handle.rs                | 47 ++++++++++++++++---
 3 files changed, 48 insertions(+), 8 deletions(-)

diff --git a/Cargo.toml b/Cargo.toml
index f1a1ab581377..76c8e1926d59 100644
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -110,6 +110,7 @@ wayland_frontend = ["wayland-server", "wayland-protocols", "wayland-protocols-wl
 x11rb_event_source = ["x11rb"]
 xwayland = ["encoding_rs", "wayland_frontend", "x11rb/composite", "x11rb/xfixes", "x11rb/randr", "x11rb_event_source", "scopeguard"]
 test_all_features = ["default", "use_system_lib", "renderer_glow", "renderer_test"]
+virtual_keyboard_not_use_default_handler = [ ]
 
 [[example]]
 name = "minimal"
diff --git a/src/wayland/virtual_keyboard/mod.rs b/src/wayland/virtual_keyboard/mod.rs
index 335221e337fe..caa5b71ff04f 100644
--- a/src/wayland/virtual_keyboard/mod.rs
+++ b/src/wayland/virtual_keyboard/mod.rs
@@ -57,9 +57,9 @@ use wayland_protocols_misc::zwp_virtual_keyboard_v1::server::{
 };
 use wayland_server::{backend::GlobalId, Client, DataInit, Dispatch, DisplayHandle, GlobalDispatch, New};
 
-use crate::input::{Seat, SeatHandler};
-
 use self::virtual_keyboard_handle::VirtualKeyboardHandle;
+use crate::backend::input::{KeyState, Keycode};
+use crate::input::{Seat, SeatHandler};
 
 const MANAGER_VERSION: u32 = 1;
 
@@ -91,6 +91,10 @@ where
     display.create_global::<D, ZwpVirtualKeyboardManagerV1, _>(MANAGER_VERSION, data)
 }
 
+pub trait VirtualKeyboardHandler {
+    fn on_keyboard_event(&mut self, keycode: Keycode, state: KeyState, time: u32);
+}
+
 impl VirtualKeyboardManagerState {
     /// Initialize a virtual keyboard manager global.
     pub fn new<D, F>(display: &DisplayHandle, filter: F) -> Self
diff --git a/src/wayland/virtual_keyboard/virtual_keyboard_handle.rs b/src/wayland/virtual_keyboard/virtual_keyboard_handle.rs
index 502893fc2962..8698f490635d 100644
--- a/src/wayland/virtual_keyboard/virtual_keyboard_handle.rs
+++ b/src/wayland/virtual_keyboard/virtual_keyboard_handle.rs
@@ -10,9 +10,8 @@ use wayland_protocols_misc::zwp_virtual_keyboard_v1::server::zwp_virtual_keyboar
     self, ZwpVirtualKeyboardV1,
 };
 use wayland_server::{
-    backend::ClientId,
-    protocol::wl_keyboard::{KeyState, KeymapFormat},
-    Client, DataInit, Dispatch, DisplayHandle, Resource,
+    backend::ClientId, protocol::wl_keyboard::KeymapFormat, Client, DataInit, Dispatch, DisplayHandle,
+    Resource,
 };
 use xkbcommon::xkb;
 
@@ -20,10 +19,12 @@ use crate::input::keyboard::{KeyboardTarget, KeymapFile, ModifiersState};
 use crate::{
     input::{Seat, SeatHandler},
     utils::SERIAL_COUNTER,
-    wayland::seat::{keyboard::for_each_focused_kbds, WaylandFocus},
+    wayland::seat::WaylandFocus,
 };
 
-use super::VirtualKeyboardManagerState;
+use crate::backend::input::{KeyState, Keycode};
+
+use super::{VirtualKeyboardHandler, VirtualKeyboardManagerState};
 
 #[derive(Debug, Default)]
 pub(crate) struct VirtualKeyboard {
@@ -71,10 +72,18 @@ impl<D: SeatHandler> fmt::Debug for VirtualKeyboardUserData<D> {
     }
 }
 
+#[cfg(not(feature = "virtual_keyboard_not_use_default_handler"))]
+impl<T: SeatHandler + 'static> VirtualKeyboardHandler for T {
+    fn on_keyboard_event(&mut self, keycode: Keycode, state: KeyState, time: u32) {
+        unreachable!()
+    }
+}
+
 impl<D> Dispatch<ZwpVirtualKeyboardV1, VirtualKeyboardUserData<D>, D> for VirtualKeyboardManagerState
 where
     D: Dispatch<ZwpVirtualKeyboardV1, VirtualKeyboardUserData<D>>,
     D: SeatHandler + 'static,
+    D: VirtualKeyboardHandler,
     <D as SeatHandler>::KeyboardFocus: WaylandFocus,
 {
     fn request(
@@ -90,6 +99,32 @@ where
             zwp_virtual_keyboard_v1::Request::Keymap { format, fd, size } => {
                 update_keymap(data, format, fd, size as usize);
             }
+            #[cfg(feature = "virtual_keyboard_not_use_default_handler")]
+            zwp_virtual_keyboard_v1::Request::Key { time, key, state } => {
+                // Ensure keymap was initialized.
+                let mut virtual_data = data.handle.inner.lock().unwrap();
+                let vk_state = match virtual_data.state.as_mut() {
+                    Some(vk_state) => vk_state,
+                    None => {
+                        virtual_keyboard.post_error(NoKeymap, "`key` sent before keymap.");
+                        return;
+                    }
+                };
+                {
+                    // Ensure virtual keyboard's keymap is active.
+                    let keyboard_handle = data.seat.get_keyboard().unwrap();
+                    let mut internal = keyboard_handle.arc.internal.lock().unwrap();
+                    let focus = internal.focus.as_mut().map(|(focus, _)| focus);
+                    keyboard_handle.send_keymap(user_data, &focus, &vk_state.keymap, vk_state.mods);
+                }
+                let key_state = if state == 1 {
+                    KeyState::Pressed
+                } else {
+                    KeyState::Released
+                };
+                user_data.on_keyboard_event((key + 8).into(), key_state, time);
+            }
+            #[cfg(not(feature = "virtual_keyboard_not_use_default_handler"))]
             zwp_virtual_keyboard_v1::Request::Key { time, key, state } => {
                 // Ensure keymap was initialized.
                 let mut virtual_data = data.handle.inner.lock().unwrap();
@@ -106,7 +141,7 @@ where
                 let mut internal = keyboard_handle.arc.internal.lock().unwrap();
                 let focus = internal.focus.as_mut().map(|(focus, _)| focus);
                 keyboard_handle.send_keymap(user_data, &focus, &vk_state.keymap, vk_state.mods);
-
+                use wayland_server::protocol::wl_keyboard::KeyState;
                 if let Some(wl_surface) = focus.and_then(|f| f.wl_surface()) {
                     for_each_focused_kbds(&data.seat, &wl_surface, |kbd| {
                         // This should be wl_keyboard::KeyState, but the protocol does not state
